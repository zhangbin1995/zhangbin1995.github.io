<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring集成dubbo开发环境搭建]]></title>
    <url>%2F2019%2F03%2F02%2Fspring%E9%9B%86%E6%88%90dubbo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[更多文章欢迎访问个人博客 www.herobin.top 首先新建maven项目选择quickstart为项目原型。 点击项目添加两个module分别命名provider和consumer，原型同样选择quickstart分别作为服务提供者和消费者。（注意新建后暂时没有src文件夹，要等maven配置全部加载完才有，如果过慢，记得检查是否配置好idea的maven配置是否改为aliyun仓库）。这里我们用不到测试用例，可以将test文件删掉。 添加放置资源文件的resources文件夹，并在project structrue中添加进Resources中。 将需要的jar包依赖拷贝到父工程的pom中，这样各个模块就都可以使用了，注意在实际开发中，应该是各个模块分别引入该模块要用到的jar包，再在各模块的resources中新建applicationContext.xml即spring配置文件。 这样简单的spring环境就搭好了，接下来我们要集成dubbo环境。可以参考dubbo用户手册：https://dubbo.gitbooks.io/dubbo-user-book/content/quick-start.html 在provider中新建一个服务接口DemoService和它的实现类。用Spring配置声明暴露服务。 编写服务启动类App.java 至此，我们的provider模块就写好了，将它启动起来。编辑consumer里的applicationContext.xml文件通过spring配置引用远程服务。 这样就已经可以访问到provider接口提供的服务了。编写App类加载consumer的spring配置文件并进行测试。 启动消费者服务，输入zhangbin，得到服务提供者接口的返回值，由此，spring与dubbo集成环境配置成功。 项目代码已放到github：https://github.com/zhangbin1995/springdubbo.git]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个docker化的java应用]]></title>
    <url>%2F2019%2F02%2F23%2F%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E5%8C%96%E7%9A%84java%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[更多文章欢迎访问个人博客 www.herobin.top 制作镜像Dockerfile这里制作镜像主要分为三步 Dockerfiledocker buildJpress：http://jpress.io/ (开源java web应用 博客平台) 下载tomcat镜像首先我们的镜像是要依托tomcat运行的，所以先到网易云的镜像中心下载tomcat的镜像docker pull hub.c.163.com/library/tomcat:latest在tomcat镜像的介绍中可以看到使用方法，如找到启动方法，查看tomcat路径等。 新建编辑Dockerfilevi Dockerfile 通过docker build生成镜像 这里-t jpress:latest是指定了镜像名字和标签，注意后面有个 . 用于查找当前目录下的构建文件，即Dockerfile用docker images查看，发现有了jpress。 运行容器在tomcat的镜像中心我们可以看到运行指令，执行：docker run -d -p 8888:8080 jpress启动镜像，发现可以访问我们的jpress程序了。 这里要正常使用jpress需要配置好数据库信息。我们也可以在docker中安装运行一个mysql数据库。去镜像中心下载mysql镜像：docker pull hub.c.163.com/library/mysql:latest同样可以在介绍中看到使用方式。 下载完后新建一个名为jpress的数据库并将mysql运行起来： docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest回到网站将信息配置好。 注意这里点击下一步的时候失败了，使用docker ps命令发现mysql镜像并没有执行，再次执行run发现启动报错。 因为本机有mysql服务正在使用，3306端口是占用状态的，将3306改为3307即可。再下一页配置好网站信息，jpress网站即搭建成功可以正常使用了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker运行nginx镜像]]></title>
    <url>%2F2019%2F02%2F22%2Fdocker%E8%BF%90%E8%A1%8Cnginx%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[@TOC 更多文章欢迎访问个人博客 www.herobin.top 下载并运行nginx镜像在网易云的镜像中心找到nginx的镜像https://c.163yun.com/hub#/m/home/ 复制nginx的下载地址：hub.c.163.com/library/nginx:latest使用docker pull hub.c.163.com/library/nginx:latest下载nginx镜像到本地 这时再使用docker images可以查看到本地已有的nignx镜像 使用docker run hub.c.163.com/library/nginx发现没有任何输出，新建窗口输入docker ps可以查看本机当前运行的所有容器。 这时只要通过ctrl+c既可以停止程序，所以我们通常推荐在后台运行镜像 通过加 -d1docker run -d hub.c.163.com/library/nginx 运行后可以通过docker exec命令进入指定镜像： 可以看到 docker run nginx镜像成功后返回一串此镜像运行的唯一标识id。 通过docker exec –help查看 docker exec命令帮助。 通过docker exec -it 603 bash来进入已运行的nginx镜像 这里只输入了604因为已经可以唯一标识确定，若不能再多输。 可通过exit命令退出镜像。 可以使用docker stop 603命令来结束nginx镜像的运行。 网络访问nginx运行了docker中的nginx后要怎样才能在网络（浏览器）中访问到nginx呢？ docker网络类型 bridge模式（桥接，默认类型，实现网络独立性）：docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。 host模式：容器不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 none模式：Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。docker将不会和外界的任何网络进行通讯。 container模式：新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。 进行访问 docker启动 -p 的使用： docker run -d -p 主机端口:容器端口 容器的名称docker启动 -P 的使用（所有的监听端口都会和主机建立一个映射）： docker run -d -P 容器名称停止docker：docker stop 容器Id -p 的使用 (注意这里是小写的p，下面是大写的P) -P 的使用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>服务器</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos下安装docker]]></title>
    <url>%2F2019%2F02%2F22%2Fcentos%E4%B8%8B%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[更多文章欢迎访问个人博客 www.herobin.top 1. 检查内核版本uname -r返回的值大于3.10即可。 2. 使用sudo或root权限的用户登录终端。3. 卸载旧版本（如果安装过旧版本的话）1234$ yum remove docker \ docker-common \ docker-selinux \ docker-engine 4. 安装需要的软件包12345#yum-util提供yum-config-manager功能#另外两个是devicemapper驱动依赖的$ yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 5. 设置yum源123$ yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 6. 安装docker6.1. 安装最新版本yum install -y docker-ce 6.2. 安装指定版本12345678910111213#查询版本列表$ yum list docker-ce --showduplicates | sort -r已加载插件：fastestmirror, langpacks已安装的软件包可安装的软件包 * updates: mirrors.163.comLoading mirror speeds from cached hostfile * extras: mirrors.163.comdocker-ce.x86_64 17.09.1.ce-1.el7.centos docker-ce-stabledocker-ce.x86_64 17.09.0.ce-1.el7.centos docker-ce-stable...#指定版本安装(这里的例子是安装上面列表中的第二个)$ yum install -y docker-ce-17.09.0.ce 7. 启动dockersystemctl start docker.service 8.验证安装是否成功（有client和service两部分表示docker安装启动都成功了）1234567891011121314151617$ docker versionClient: Version: 17.09.0-ce API version: 1.32 Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:41:23 2017 OS/Arch: linux/amd64Server: Version: 17.09.0-ce API version: 1.32 (minimum version 1.12) Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:42:49 2017 OS/Arch: linux/amd64 Experimental: false 原文链接：https://www.imooc.com/article/16448]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下安装docker]]></title>
    <url>%2F2019%2F02%2F22%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[@TOC 更多文章欢迎访问个人博客 www.herobin.top mac下安装docker下载并安装dockermac版的docker可以直接去docker官网下载桌面版，傻瓜式安装后运行docker，会发现在桌面的右上角出现了docker的图标 验证docker打开终端输入命令：docker version 正常出现版本信息即安装成功。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对null字段的两种处理]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%AF%B9null%E5%AD%97%E6%AE%B5%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[在查询订单列表时，有的订单详情为空返回值为null，不利于前端展示，如下： 1234567891011121314151617181920212223242526272829303132&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ &#123; &quot;orderId&quot;: &quot;1550025663184309586&quot;, &quot;buyerName&quot;: &quot;admin&quot;, &quot;buyerPhone&quot;: &quot;123456&quot;, &quot;buyerAddress&quot;: &quot;11111&quot;, &quot;buyerOpenid&quot;: &quot;123456&quot;, &quot;orderAmount&quot;: 3.2, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;, &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;, &quot;orderDetailList&quot;: null &#125;, &#123; &quot;orderId&quot;: &quot;1550025830175838897&quot;, &quot;buyerName&quot;: &quot;admin&quot;, &quot;buyerPhone&quot;: &quot;123456&quot;, &quot;buyerAddress&quot;: &quot;11111&quot;, &quot;buyerOpenid&quot;: &quot;123456&quot;, &quot;orderAmount&quot;: 3.2, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;, &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;, &quot;orderDetailList&quot;: null &#125; ]&#125; 可以看到上面orderDetailList的值为null。 这里我们可以给orderDTO添加注释JsonInclude来解决： 1@JsonInclude(JsonInclude.Include.NON_NULL) 这样为空的属性就不会返回给前端了，运行结果： 123456789101112131415161718192021222324252627282930&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ &#123; &quot;orderId&quot;: &quot;1550025663184309586&quot;, &quot;buyerName&quot;: &quot;admin&quot;, &quot;buyerPhone&quot;: &quot;123456&quot;, &quot;buyerAddress&quot;: &quot;11111&quot;, &quot;buyerOpenid&quot;: &quot;123456&quot;, &quot;orderAmount&quot;: 3.2, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;, &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot; &#125;, &#123; &quot;orderId&quot;: &quot;1550025830175838897&quot;, &quot;buyerName&quot;: &quot;admin&quot;, &quot;buyerPhone&quot;: &quot;123456&quot;, &quot;buyerAddress&quot;: &quot;11111&quot;, &quot;buyerOpenid&quot;: &quot;123456&quot;, &quot;orderAmount&quot;: 3.2, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;, &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot; &#125; ]&#125; 也可以在application.yml中配置： 12345678910111213141516spring: datasource: driver-class-name: com.mysql.jdbc.Driver username: herobin password: Zhangbin1995@ url: jdbc:mysql://101.132.138.185:3306/sell?characterEncoding=utf-8&amp;useSSL=false jpa: show-sql: true database-platform: org.hibernate.dialect.MySQL5InnoDBDialect hibernate.ddl-auto: update # 配置所有的类只返回非空属性 jackson: default-property-inclusion: non_nullserver: servlet: context-path: /sell 可是有的时候我们想要返回orderDetailList，还是值不为空，而是一个方括号。 可以在orderDTO中给orderDetailList赋初值。 1List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;(); 运行结果： 1234567891011121314151617181920212223242526272829303132&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;成功&quot;, &quot;data&quot;: [ &#123; &quot;orderId&quot;: &quot;1550025663184309586&quot;, &quot;buyerName&quot;: &quot;admin&quot;, &quot;buyerPhone&quot;: &quot;123456&quot;, &quot;buyerAddress&quot;: &quot;11111&quot;, &quot;buyerOpenid&quot;: &quot;123456&quot;, &quot;orderAmount&quot;: 3.2, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;, &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;, &quot;orderDetailList&quot;: [] &#125;, &#123; &quot;orderId&quot;: &quot;1550025830175838897&quot;, &quot;buyerName&quot;: &quot;admin&quot;, &quot;buyerPhone&quot;: &quot;123456&quot;, &quot;buyerAddress&quot;: &quot;11111&quot;, &quot;buyerOpenid&quot;: &quot;123456&quot;, &quot;orderAmount&quot;: 3.2, &quot;orderStatus&quot;: 0, &quot;payStatus&quot;: 0, &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;, &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;, &quot;orderDetailList&quot;: [] &#125; ]&#125; 同理，String类型和int类型也都可以通过赋初值的方法避免null问题。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageRequest过时替换]]></title>
    <url>%2F2019%2F02%2F13%2FPageRequest%E8%BF%87%E6%97%B6%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[使用SpringbootJPA的PageRequest时提示已过时 1PageRequest request = new PageRequest(page, size); 解决方法： 用PageRequest.of(page, size)替换。 1PageRequest request = PageRequest.of(page, size); 顺便列出一个分页的查询方法代码： 1234567891011121314151617//订单列表 @GetMapping(&quot;/list&quot;) public ResultVO&lt;List&lt;OrderDTO&gt;&gt; list(@RequestParam(&quot;openid&quot;) String openid, @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) Integer page, @RequestParam(value = &quot;size&quot;, defaultValue = &quot;10&quot;) Integer size)&#123; if(StringUtils.isEmpty(openid))&#123; log.error(&quot;[查询订单列表] openid为空&quot;); throw new SellException(ResultEnum.PARAM_ERROR); &#125; //PageRequest已经过时 用PageRequest.of替换 //PageRequest request = new PageRequest(page, size); PageRequest request = PageRequest.of(page, size); Page&lt;OrderDTO&gt; orderDTOPage = orderService.findList(openid, request); return ResultVOUtil.success(orderDTOPage.getContent()); &#125; orderDTOPage中会有三个最主要的方法： getContent: 获得该页的记录集合 getTotalElements: 获得总记录条数 getTotalPages： 获得总页数]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot中Jpa的使用]]></title>
    <url>%2F2019%2F02%2F01%2FSpringboot%E4%B8%ADJpa%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[springboot中可以通过使用Jpa实现dao层的简单配置，使用jpa后可以省略复杂的sql语句编写，自带简单的增删改查功能。 application.yml的配置12345678910spring: datasource: driver-class-name: com.mysql.jdbc.Driver username: herobin password: Zhangbin1995@ url: jdbc:mysql://101.132.138.185:3306/sell?characterEncoding=utf-8&amp;useSSL=false jpa: show-sql: true database-platform: org.hibernate.dialect.MySQL5InnoDBDialect hibernate.ddl-auto: update dao类的编写dao接口直接集成JpaRepository接口即可。 123456789101112131415package com.imooc.dao;import com.imooc.entity.ProductCategory;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;/** * Created by binzhang on 19/1/21. */public interface ProductCategoryDao extends JpaRepository&lt;ProductCategory, Integer&gt; &#123; List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; categoryTypeList);&#125; dao层测试方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.imooc.dao;import com.imooc.entity.ProductCategory;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.Arrays;import java.util.List;import java.util.Optional;import static org.junit.Assert.*;/** * Created by binzhang on 19/1/21. */@RunWith(SpringRunner.class)@SpringBootTestpublic class ProductCategoryDaoTest &#123; @Autowired private ProductCategoryDao pcDao; @Test @Ignore public void findOneTest()&#123; ProductCategory productCategory = pcDao.findById(1).get(); System.out.println(productCategory.toString()); &#125; @Test public void findAllTest()&#123; List&lt;ProductCategory&gt; pcList = pcDao.findAll(); for (ProductCategory pc : pcList)&#123; System.out.println(pc.getCategoryName()); &#125; &#125; @Test public void saveTest()&#123; ProductInfo productInfo = new ProductInfo(); productInfo.setProductId(&quot;123456&quot;); productInfo.setProductName(&quot;皮蛋粥&quot;); productInfo.setProductPrice(new BigDecimal(3.2)); productInfo.setProductStock(100); productInfo.setProductDescription(&quot;很好喝的粥&quot;); productInfo.setProductIcon(&quot;xxx.png&quot;); productInfo.setProductStatus(0); productInfo.setCategoryType(2); ProductInfo result = productInfoDao.save(productInfo); Assert.assertNotNull(result); &#125; @Test public void findByCategoryTypeInTest()&#123; List&lt;Integer&gt; list = Arrays.asList(2,3,4); List&lt;ProductCategory&gt; result = pcDao.findByCategoryTypeIn(list); Assert.assertNotEquals(0,result.size()); &#125;&#125; 这里测试了 单个查找的findById()方法和findAll()方法，注意这里的findById()方法返回的是Optional&lt;T&gt;,可以进到JpaRepository的CrudRepository里看到. 123456789101112131415161718192021222324252627282930313233//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.data.repository;import java.util.Optional;@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S var1); &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); Optional&lt;T&gt; findById(ID var1); boolean existsById(ID var1); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable&lt;? extends T&gt; var1); void deleteAll();&#125; 所以在findById()后我们还要用get()方法才能得到我们想要查询的对象。 查看get方法的源码： 123456public T get() &#123; if (value == null) &#123; throw new NoSuchElementException(&quot;No value present&quot;); &#125; return value;&#125; 可以看到当查询结果为空时会抛出异常，所以在我们的代码中不要忘记做判断抛出异常。 分页方法的使用使用分页方法要将返回类型定义为PageAble。 dao方法： 12345678/** * Created by binzhang on 19/2/1. */public interface OrderMasterDao extends JpaRepository&lt;OrderMaster,String&gt;&#123; Page&lt;OrderMaster&gt; findByBuyerOpenid(String buyerOpenId, Pageable pageable);&#125; 测试方法： 123456789@Testpublic void findByBuyerOpenId() throws Exception &#123; /** PageRequest实现了PageAble接口 */ PageRequest pageRequest = new PageRequest(0,1); Page&lt;OrderMaster&gt; request = orderMasterDao.findByBuyerOpenid(&quot;123321&quot;,pageRequest); //这个是总条数 不是分页返回的条数 System.out.println(request.getTotalElements()); System.out.println(request.getContent().get(0).getBuyerName());&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-乐观锁与悲观锁]]></title>
    <url>%2F2019%2F01%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[悲观锁与乐观锁悲观锁 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 乐观锁 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 两种锁的使用场景 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 乐观锁常见的两种实现方式 乐观锁一般会使用版本号机制或CAS算法实现。 1. 版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。 举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。 2. CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。 乐观锁的缺点 ABA 问题是乐观锁一个常见的问题 1 ABA 问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。 JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 2 循环时间长开销大自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3 只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。 CAS与synchronized的使用情景 简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少）， synchronized适用于写比较多的情况下（多写场景，冲突一般较多） 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-线程池与Executor框架]]></title>
    <url>%2F2019%2F01%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8EExecutor%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一 使用线程池的好处线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 使用线程池的好处（《Java并发编程的艺术》）： 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 二 Executor框架2.1 简介Executor 框架是Java5之后引进的，在Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。 补充：this逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。 2.2 Executor 框架结构(主要由三大部分组成)1 任务。执行任务需要实现的Runnable接口或Callable接口。Runnable接口或Callable接口实现类都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。 两者的区别： Runnable接口不会返回结果但是Callable接口可以返回结果。后面介绍Executors类的一些方法的时候会介绍到两者的相互转换。 2 任务的执行如下图所示，包括任务执行机制的核心接口Executor ，以及继承自Executor 接口的ExecutorService接口。ScheduledThreadPoolExecutor和ThreadPoolExecutor这两个关键类实现了ExecutorService接口。 注意： 通过查看ScheduledThreadPoolExecutor源代码我们发现ScheduledThreadPoolExecutor实际上是继承了ThreadPoolExecutor并实现了ScheduledExecutorService ，而ScheduledExecutorService又实现了ExecutorService，正如我们下面给出的类关系图显示的一样。 ThreadPoolExecutor类描述: 12//AbstractExecutorService实现了ExecutorService接口public class ThreadPoolExecutor extends AbstractExecutorService ScheduledThreadPoolExecutor类描述: 1234//ScheduledExecutorService实现了ExecutorService接口public class ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService 3 异步计算的结果Future接口以及Future接口的实现类FutureTask类。 当我们把Runnable接口或Callable接口的实现类提交（调用submit方法）给ThreadPoolExecutor或ScheduledThreadPoolExecutor时，会返回一个FutureTask对象。 我们以AbstractExecutorService接口中的一个submit方法为例子来看看源代码： 123456public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125; 上面方法调用的newTaskFor方法返回了一个FutureTask对象。 123protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125; 2.3 Executor框架的使用示意图 1. 主线程首先要创建实现Runnable或者Callable接口的任务对象。备注： 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。 2. 然后可以把创建完成的Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callable task））。 执行execute()方法和submit()方法的区别是什么呢？ 1) execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； 2) submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 3. 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（我们刚刚也提到过了执行execute()方法和submit()方法的区别，到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。 4. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。三 ThreadPoolExecutor详解线程池实现类ThreadPoolExecutor是Executor框架最核心的类，先来看一下这个类中比较重要的四个属性。 3.1 ThreadPoolExecutor类的四个比较重要的属性 3.2 ThreadPoolExecutor类中提供的四个构造方法我们看最长的那个，其余三个都是在这个构造方法的基础上产生（给定某些默认参数的构造方法） 1234567891011121314151617181920212223242526272829303132333435363738/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 * @param keepAliveTime 当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交， *核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime； * @param unit keepAliveTime参数的时间单位 * @param workQueue 等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列； * * @param threadFactory 执行者创建新线程时使用的工厂 * @param handler RejectedExecutionHandler类型的变量，表示线程池的饱和策略。 * 如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。 * 线程池提供了4种策略： 1.AbortPolicy：直接抛出异常，这是默认策略； 2.CallerRunsPolicy：用调用者所在的线程来执行任务； 3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； 4.DiscardPolicy：直接丢弃任务； */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 3.3 如何创建ThreadPoolExecutor在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。 为什么呢？ 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险 Executors 返回线程池对象的弊端如下： FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。 CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。 方式一：通过构造方法实现 方式二：通过Executor 框架的工具类Executors来实现 我们可以创建三种类型的ThreadPoolExecutor： FixedThreadPool SingleThreadExecutor CachedThreadPool 对应Executors工具类中的方法如图所示： 3.4 FixedThreadPool详解FixedThreadPool被称为可重用固定线程数的线程池。通过Executors类中的相关源代码来看一下相关实现： 12345678910111213141516171819 /** * 创建一个可重用固定数量线程的线程池*在任何时候至多有n个线程处于活动状态*如果在所有线程处于活动状态时提交其他任务，则它们将在队列中等待，*直到线程可用。 如果任何线程在关闭之前的执行期间由于失败而终止，*如果需要执行后续任务，则一个新的线程将取代它。池中的线程将一直存在*知道调用shutdown方法 * @param nThreads 线程池中的线程数 * @param threadFactory 创建新线程时使用的factory * @return 新创建的线程池 * @throws NullPointerException 如果threadFactory为null * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory); &#125; 另外还有一个FixedThreadPool的实现方法，和上面的类似，所以这里不多做阐述： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 从上面源代码可以看出新创建的FixedThreadPool的corePoolSize和maximumPoolSize都被设置为nThreads。 FixedThreadPool的execute()方法运行示意图（该图片来源：《Java并发编程的艺术》）： 上图说明： 如果当前运行的线程数小于corePoolSize，则创建新的线程来执行任务； 当前运行的线程数等于corePoolSize后，将任务加入LinkedBlockingQueue； 线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行； FixedThreadPool使用无界队列 LinkedBlockingQueue（队列的容量为Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响： 当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize； 由于1，使用无界队列时maximumPoolSize将是一个无效参数； 由于1和2，使用无界队列时keepAliveTime将是一个无效参数； 运行中的FixedThreadPool（未执行shutdown()或shutdownNow()方法）不会拒绝任务 3.5 SingleThreadExecutor详解SingleThreadExecutor是使用单个worker线程的Executor。下面看看SingleThreadExecutor的实现： 12345678910111213141516 /** *创建使用单个worker线程运行无界队列的Executor*并使用提供的ThreadFactory在需要时创建新线程 * * @param threadFactory 创建新线程时使用的factory * * @return 新创建的单线程Executor * @throws NullPointerException 如果ThreadFactory为空 */ public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory)); &#125; 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 从上面源代码可以看出新创建的SingleThreadExecutor的corePoolSize和maximumPoolSize都被设置为1.其他参数和FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Intger.MAX_VALUE）。SingleThreadExecutor使用无界队列作为线程池的工作队列会对线程池带来的影响与FixedThreadPool相同。 SingleThreadExecutor的运行示意图（该图片来源：《Java并发编程的艺术》）： 上图说明; 如果当前运行的线程数少于corePoolSize，则创建一个新的线程执行任务； 当前线程池中有一个运行的线程后，将任务加入LinkedBlockingQueue; 线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行； 3.6 CachedThreadPool详解CachedThreadPool是一个会根据需要创建新线程的线程池。下面通过源码来看看 CachedThreadPool的实现： 12345678910111213 /** * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它，*并在需要时使用提供的ThreadFactory创建新线程。 * @param threadFactory 创建新线程使用的factory * @return 新创建的线程池 * @throws NullPointerException 如果threadFactory为空 */ public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory); &#125; 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; CachedThreadPool的corePoolSize被设置为空（0），maximumPoolSize被设置为Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新的线程。极端情况下，这样会导致耗尽cpu和内存资源。 CachedThreadPool的execute()方法的执行示意图（该图片来源：《Java并发编程的艺术》）： 上图说明： 首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有闲线程正在执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤2； 当初始maximumPool为空，或者maximumPool中没有空闲线程时，将没有线程执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤1将失败，此时CachedThreadPool会创建新线程执行任务，execute方法执行完成； 3.7 ThreadPoolExecutor使用示例3.7.1 示例代码首先创建一个Runnable接口的实现类（当然也可以是Callable接口，我们上面也说了两者的区别是：Runnable接口不会返回结果但是Callable接口可以返回结果。后面介绍Executors类的一些方法的时候会介绍到两者的相互转换。） 123456789101112131415161718192021222324252627282930313233import java.util.Date;/** * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。 */public class WorkerThread implements Runnable &#123; private String command; public WorkerThread(String s) &#123; this.command = s; &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; Start. Time = &quot; + new Date()); processCommand(); System.out.println(Thread.currentThread().getName() + &quot; End. Time = &quot; + new Date()); &#125; private void processCommand() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public String toString() &#123; return this.command; &#125;&#125; 编写测试程序，我们这里以FixedThreadPool为例子 123456789101112131415161718192021import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExecutorDemo &#123; public static void main(String[] args) &#123; //创建一个FixedThreadPool对象 ExecutorService executor = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 10; i++) &#123; //创建WorkerThread对象（WorkerThread类实现了Runnable 接口） Runnable worker = new WorkerThread(&quot;&quot; + i); //执行Runnable executor.execute(worker); &#125; //终止线程池 executor.shutdown(); while (!executor.isTerminated()) &#123; &#125; System.out.println(&quot;Finished all threads&quot;); &#125;&#125; 输出示例： 123456789101112131415161718192021pool-1-thread-5 Start. Time = Thu May 31 10:22:52 CST 2018pool-1-thread-3 Start. Time = Thu May 31 10:22:52 CST 2018pool-1-thread-2 Start. Time = Thu May 31 10:22:52 CST 2018pool-1-thread-4 Start. Time = Thu May 31 10:22:52 CST 2018pool-1-thread-1 Start. Time = Thu May 31 10:22:52 CST 2018pool-1-thread-4 End. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-1 End. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-2 End. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-5 End. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-3 End. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-5 Start. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-2 Start. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-1 Start. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-4 Start. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-3 Start. Time = Thu May 31 10:22:57 CST 2018pool-1-thread-5 End. Time = Thu May 31 10:23:02 CST 2018pool-1-thread-1 End. Time = Thu May 31 10:23:02 CST 2018pool-1-thread-2 End. Time = Thu May 31 10:23:02 CST 2018pool-1-thread-3 End. Time = Thu May 31 10:23:02 CST 2018pool-1-thread-4 End. Time = Thu May 31 10:23:02 CST 2018Finished all threads 3.7.2 shutdown（）VS shutdownNow（）shutdown（）方法表明关闭已在Executor上调用，因此不会再向DelayedPool添加任何其他任务（由ScheduledThreadPoolExecutor类在内部使用）。 但是，已经在队列中提交的任务将被允许完成。另一方面，shutdownNow（）方法试图终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的List。 3.7.3 isTerminated() Vs isShutdown()isShutdown（）表示执行程序正在关闭，但并非所有任务都已完成执行。另一方面，isShutdown（）表示所有线程都已完成执行。 四 ScheduledThreadPoolExecutor详解4.1 简介ScheduledThreadPoolExecutor主要用来在给定的延迟后运行任务，或者定期执行任务。 ScheduledThreadPoolExecutor使用的任务队列DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask的time变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask的squenceNumber变量小的先执行)。 ScheduledThreadPoolExecutor和Timer的比较： Timer对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是； Timer只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor可以配置任意数量的线程。 此外，如果你想（通过提供ThreadFactory），你可以完全控制创建的线程; 在TimerTask中抛出的运行时异常会杀死一个线程，从而导致Timer死机:-( …即计划任务将不再运行。ScheduledThreadExecutor不仅捕获运行时异常，还允许您在需要时处理它们（通过重写afterExecute方法 ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。 综上，在JDK1.5之后，你没有理由再使用Timer进行任务调度了。 备注： Quartz是一个由java编写的任务调度库，由OpenSymphony组织开源出来。在实际项目开发中使用Quartz的还是居多，比较推荐使用Quartz。因为Quartz理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。 4.2 ScheduledThreadPoolExecutor运行机制 ScheduledThreadPoolExecutor的执行主要分为两大部分： 当调用ScheduledThreadPoolExecutor的 scheduleAtFixedRate() 方法或者scheduleWirhFixedDelay() 方法时，会向ScheduledThreadPoolExecutor的 DelayQueue 添加一个实现了 RunnableScheduledFutur 接口的 ScheduledFutureTask 。 线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。 ScheduledThreadPoolExecutor为了实现周期性的执行任务，对ThreadPoolExecutor做了如下修改： 使用 DelayQueue 作为任务队列； 获取任务的方不同 执行周期任务后，增加了额外的处理 4.3 ScheduledThreadPoolExecutor执行周期任务的步骤 线程1从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前系统的时间； 线程1执行这个ScheduledFutureTask； 线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间； 线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add())。 4.4 ScheduledThreadPoolExecutor使用示例 创建一个简单的实现Runnable接口的类（我们上面的例子已经实现过） 测试程序使用ScheduledExecutorService和ScheduledThreadPoolExecutor实现的java调度。 123456789101112131415161718192021222324252627282930/** * 使用ScheduledExecutorService和ScheduledThreadPoolExecutor实现的java调度程序示例程序。 */public class ScheduledThreadPoolDemo &#123; public static void main(String[] args) throws InterruptedException &#123; //创建一个ScheduledThreadPoolExecutor对象 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); //计划在某段时间后运行 System.out.println(&quot;Current Time = &quot;+new Date()); for(int i=0; i&lt;3; i++)&#123; Thread.sleep(1000); WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;); //创建并执行在给定延迟后启用的单次操作。 scheduledThreadPool.schedule(worker, 10, TimeUnit.SECONDS); &#125; //添加一些延迟让调度程序产生一些线程 Thread.sleep(30000); System.out.println(&quot;Current Time = &quot;+new Date()); //关闭线程池 scheduledThreadPool.shutdown(); while(!scheduledThreadPool.isTerminated())&#123; //等待所有任务完成 &#125; System.out.println(&quot;Finished all threads&quot;); &#125;&#125; 运行结果： 123456789Current Time = Wed May 30 17:11:16 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:11:27 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:11:28 CST 2018pool-1-thread-3 Start. Time = Wed May 30 17:11:29 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:11:32 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:11:33 CST 2018pool-1-thread-3 End. Time = Wed May 30 17:11:34 CST 2018Current Time = Wed May 30 17:11:49 CST 2018Finished all threads 4.4.1 ScheduledExecutorService scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)方法我们可以使用ScheduledExecutorService scheduleAtFixedRate方法来安排任务在初始延迟后运行，然后在给定的时间段内运行。 时间段是从池中第一个线程的开始，因此如果您将period指定为1秒并且线程运行5秒，那么只要第一个工作线程完成执行，下一个线程就会开始执行。 1234567for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(1000); WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;); // schedule task to execute at fixed rate scheduledThreadPool.scheduleAtFixedRate(worker, 0, 10, TimeUnit.SECONDS);&#125; 输出示例： 123456789101112131415161718192021222324252627Current Time = Wed May 30 17:47:09 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:47:10 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:47:11 CST 2018pool-1-thread-3 Start. Time = Wed May 30 17:47:12 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:47:15 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:47:16 CST 2018pool-1-thread-3 End. Time = Wed May 30 17:47:17 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:47:20 CST 2018pool-1-thread-4 Start. Time = Wed May 30 17:47:21 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:47:22 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:47:25 CST 2018pool-1-thread-4 End. Time = Wed May 30 17:47:26 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:47:27 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:47:30 CST 2018pool-1-thread-3 Start. Time = Wed May 30 17:47:31 CST 2018pool-1-thread-5 Start. Time = Wed May 30 17:47:32 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:47:35 CST 2018pool-1-thread-3 End. Time = Wed May 30 17:47:36 CST 2018pool-1-thread-5 End. Time = Wed May 30 17:47:37 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:47:40 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:47:41 CST 2018Current Time = Wed May 30 17:47:42 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:47:45 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:47:46 CST 2018Finished all threadsProcess finished with exit code 0 4.4.2 ScheduledExecutorService scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)方法ScheduledExecutorService scheduleWithFixedDelay方法可用于以初始延迟启动周期性执行，然后以给定延迟执行。 延迟时间是线程完成执行的时间。 123456for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(1000); WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;); scheduledThreadPool.scheduleWithFixedDelay(worker, 0, 1, TimeUnit.SECONDS);&#125; 输出示例： 12345678910111213141516171819202122232425262728293031323334353637Current Time = Wed May 30 17:58:09 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:58:10 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:58:11 CST 2018pool-1-thread-3 Start. Time = Wed May 30 17:58:12 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:58:15 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:58:16 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:58:16 CST 2018pool-1-thread-3 End. Time = Wed May 30 17:58:17 CST 2018pool-1-thread-4 Start. Time = Wed May 30 17:58:17 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:58:18 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:58:21 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:58:22 CST 2018pool-1-thread-4 End. Time = Wed May 30 17:58:22 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:58:23 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:58:23 CST 2018pool-1-thread-4 Start. Time = Wed May 30 17:58:24 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:58:27 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:58:28 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:58:28 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:58:29 CST 2018pool-1-thread-4 End. Time = Wed May 30 17:58:29 CST 2018pool-1-thread-4 Start. Time = Wed May 30 17:58:30 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:58:33 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:58:34 CST 2018pool-1-thread-1 Start. Time = Wed May 30 17:58:34 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:58:35 CST 2018pool-1-thread-4 End. Time = Wed May 30 17:58:35 CST 2018pool-1-thread-4 Start. Time = Wed May 30 17:58:36 CST 2018pool-1-thread-1 End. Time = Wed May 30 17:58:39 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:58:40 CST 2018pool-1-thread-5 Start. Time = Wed May 30 17:58:40 CST 2018pool-1-thread-4 End. Time = Wed May 30 17:58:41 CST 2018pool-1-thread-2 Start. Time = Wed May 30 17:58:41 CST 2018Current Time = Wed May 30 17:58:42 CST 2018pool-1-thread-5 End. Time = Wed May 30 17:58:45 CST 2018pool-1-thread-2 End. Time = Wed May 30 17:58:46 CST 2018Finished all threads 4.4.3 scheduleWithFixedDelay() vs scheduleAtFixedRate()scheduleAtFixedRate（…）将延迟视为两个任务开始之间的差异（即定期调用）scheduleWithFixedDelay（…）将延迟视为一个任务结束与下一个任务开始之间的差异 scheduleAtFixedRate(): 创建并执行在给定的初始延迟之后，随后以给定的时间段首先启用的周期性动作; 那就是执行将在initialDelay之后开始，然后initialDelay+period ，然后是initialDelay + 2 * period ，等等。 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行人终止。 如果任务执行时间比其周期长，则后续执行可能会迟到，但不会同时执行。 scheduleWithFixedDelay() : 创建并执行在给定的初始延迟之后首先启用的定期动作，随后在一个执行的终止和下一个执行的开始之间给定的延迟。 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行终止。 五 各种线程池的适用场景介绍 FixedThreadPool： 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器； SingleThreadExecutor： 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。 CachedThreadPool： 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器； ScheduledThreadPoolExecutor： 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景， SingleThreadScheduledExecutor： 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。 六 总结本节只是简单的介绍了一下使用线程池的好处，然后花了大量篇幅介绍Executor 框架。详细介绍了Executor 框架中ThreadPoolExecutor和ScheduledThreadPoolExecutor，并且通过实例详细讲解了ScheduledThreadPoolExecutor的使用。对于FutureTask 只是粗略带过，因为篇幅问题，并没有深究它的原理，后面的文章会进行补充。这一篇文章只是大概带大家过一下线程池的基本概览，深入讲解的地方不是很多，后续会通过源码深入研究其中比较重要的一些知识点。 原博链接：https://blog.csdn.net/qq_34337272/article/details/79959271 （侵权删）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-Lock锁的使用]]></title>
    <url>%2F2019%2F01%2F19%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-Lock%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Lock锁的使用一 Lock接口1.1 Lock接口简介锁是用于通过多个线程控制对共享资源的访问的工具。通常，锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，一些锁可能允许并发访问共享资源，如ReadWriteLock的读写锁。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的。JDK1.5之后并发包中新增了Lock接口以及相关实现类来实现锁功能。 虽然synchronized方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。例如，用于遍历并发访问的数据结构的一些算法需要使用“手动”或“链锁定”：您获取节点A的锁定，然后获取节点B，然后释放A并获取C，然后释放B并获得D等。在这种场景中synchronized关键字就不那么容易实现了，使用Lock接口容易很多。 Lock接口的实现类： ReentrantLock ， ReentrantReadWriteLock.ReadLock ， ReentrantReadWriteLock.WriteLock 1.2 Lock的简单使用123456Lock lock=new ReentrantLock()；lock.lock(); try&#123; &#125;finally&#123; lock.unlock(); &#125; 因为Lock是接口所以使用时要结合它的实现类，另外在finall语句块中释放锁的目的是保证获取到锁之后，最终能够被释放。 注意： 最好不要把获取锁的过程写在try语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放。 1.3 Lock接口的特性和常见方法Lock接口提供的synchronized关键字不具备的主要特性： 尝试非阻塞地获取锁 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 能被中断地获取锁 获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 超时获取锁 在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回 Lock接口基本的方法： void lock() 获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。 void lockInterruptibly() 获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是在锁的获取中可以中断当前线程（相应中断）。 Condition newCondition() 获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。 boolean tryLock() 只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为true；如果锁不可用，则此方法将立即返回值为false 。 boolean tryLock(long time, TimeUnit unit) 超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false. void unlock() 释放锁。 二 Lock接口的实现类：ReentrantLockReentrantLock和synchronized关键字一样可以用来实现线程之间的同步互斥，但是在功能是比synchronized关键字更强大而且更灵活。 ReentrantLock类常见方法： 构造方法： ReentrantLock() 创建一个 ReentrantLock的实例。ReentrantLock(boolean fair) 创建一个特定锁类型（公平锁/非公平锁）的ReentrantLock的实例 ReentrantLock类常见方法(Lock接口已有方法这里没加上)： int getHoldCount() 查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。 protected Thread getOwner() 返回当前拥有此锁的线程，如果不拥有，则返回 null protected Collection getQueuedThreads() 返回包含可能正在等待获取此锁的线程的集合 int getQueueLength() 返回等待获取此锁的线程数的估计。 protected Collection getWaitingThreads(Condition condition) 返回包含可能在与此锁相关联的给定条件下等待的线程的集合。 int getWaitQueueLength(Condition condition) 返回与此锁相关联的给定条件等待的线程数的估计。 boolean hasQueuedThread(Thread thread) 查询给定线程是否等待获取此锁。 boolean hasQueuedThreads() 查询是否有线程正在等待获取此锁。 boolean hasWaiters(Condition condition) 查询任何线程是否等待与此锁相关联的给定条件 boolean isFair() 如果此锁的公平设置为true，则返回 true 。 boolean isHeldByCurrentThread() 查询此锁是否由当前线程持有。 boolean isLocked() 查询此锁是否由任何线程持有。 2.1 第一个ReentrantLock程序ReentrantLockTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ReentrantLockTest &#123; public static void main(String[] args) &#123; MyService service = new MyService(); MyThread a1 = new MyThread(service); MyThread a2 = new MyThread(service); MyThread a3 = new MyThread(service); MyThread a4 = new MyThread(service); MyThread a5 = new MyThread(service); a1.start(); a2.start(); a3.start(); a4.start(); a5.start(); &#125; static public class MyService &#123; private Lock lock = new ReentrantLock(); public void testMethod() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName() + (&quot; &quot; + (i + 1))); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; static public class MyThread extends Thread &#123; private MyService service; public MyThread(MyService service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.testMethod(); &#125; &#125;&#125; 运行结果： 12345678910111213141516171819202122232425ThreadName=Thread-0 1ThreadName=Thread-0 2ThreadName=Thread-0 3ThreadName=Thread-0 4ThreadName=Thread-0 5ThreadName=Thread-1 1ThreadName=Thread-1 2ThreadName=Thread-1 3ThreadName=Thread-1 4ThreadName=Thread-1 5ThreadName=Thread-2 1ThreadName=Thread-2 2ThreadName=Thread-2 3ThreadName=Thread-2 4ThreadName=Thread-2 5ThreadName=Thread-3 1ThreadName=Thread-3 2ThreadName=Thread-3 3ThreadName=Thread-3 4ThreadName=Thread-3 5ThreadName=Thread-4 1ThreadName=Thread-4 2ThreadName=Thread-4 3ThreadName=Thread-4 4ThreadName=Thread-4 5 从运行结果可以看出，当一个线程运行完毕后才把锁释放，其他线程才能执行，其他线程的执行顺序是不确定的。 2.2 Condition接口简介我们通过之前的学习知道了：synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是有JVM选择的，使用ReentrantLock类结合Condition实例可以实现“选择性通知”，这个功能非常重要，而且是Condition接口默认提供的。 而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程 Condition接口的常见方法： void await() 相当于Object类的wait方法 boolean await(long time, TimeUnit unit) 相当于Object类的wait(long timeout)方法 signal() 相当于Object类的notify方法 signalAll() 相当于Object类的notifyAll方法 2.3 使用Condition实现等待/通知机制1. 使用单个Condition实例实现等待/通知机制： UseSingleConditionWaitNotify.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class UseSingleConditionWaitNotify &#123; public static void main(String[] args) throws InterruptedException &#123; MyService service = new MyService(); ThreadA a = new ThreadA(service); a.start(); Thread.sleep(3000); service.signal(); &#125; static public class MyService &#123; private Lock lock = new ReentrantLock(); public Condition condition = lock.newCondition(); public void await() &#123; lock.lock(); try &#123; System.out.println(&quot; await时间为&quot; + System.currentTimeMillis()); condition.await(); System.out.println(&quot;这是condition.await()方法之后的语句，condition.signal()方法之后我才被执行&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void signal() throws InterruptedException &#123; lock.lock(); try &#123; System.out.println(&quot;signal时间为&quot; + System.currentTimeMillis()); condition.signal(); Thread.sleep(3000); System.out.println(&quot;这是condition.signal()方法之后的语句&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; static public class ThreadA extends Thread &#123; private MyService service; public ThreadA(MyService service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.await(); &#125; &#125;&#125; 运行结果： 在使用wait/notify实现等待通知机制的时候我们知道必须执行完notify()方法所在的synchronized代码块后才释放锁。在这里也差不多，必须执行完signal所在的try语句块之后才释放锁，condition.await()后的语句才能被执行。 注意： 必须在condition.await()方法调用之前调用lock.lock()代码获得同步监视器，不然会报错。 2. 使用多个Condition实例实现等待/通知机制： UseMoreConditionWaitNotify.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class UseMoreConditionWaitNotify &#123; public static void main(String[] args) throws InterruptedException &#123; MyserviceMoreCondition service = new MyserviceMoreCondition(); ThreadA a = new ThreadA(service); a.setName(&quot;A&quot;); a.start(); ThreadB b = new ThreadB(service); b.setName(&quot;B&quot;); b.start(); Thread.sleep(3000); service.signalAll_A(); &#125; static public class ThreadA extends Thread &#123; private MyserviceMoreCondition service; public ThreadA(MyserviceMoreCondition service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.awaitA(); &#125; &#125; static public class ThreadB extends Thread &#123; private MyserviceMoreCondition service; public ThreadB(MyserviceMoreCondition service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.awaitB(); &#125; &#125;&#125; MyserviceMoreCondition.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyserviceMoreCondition &#123; private Lock lock = new ReentrantLock(); public Condition conditionA = lock.newCondition(); public Condition conditionB = lock.newCondition(); public void awaitA() &#123; lock.lock(); try &#123; System.out.println(&quot;begin awaitA时间为&quot; + System.currentTimeMillis() + &quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionA.await(); System.out.println(&quot; end awaitA时间为&quot; + System.currentTimeMillis() + &quot; ThreadName=&quot; + Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void awaitB() &#123; lock.lock(); try &#123; System.out.println(&quot;begin awaitB时间为&quot; + System.currentTimeMillis() + &quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionB.await(); System.out.println(&quot; end awaitB时间为&quot; + System.currentTimeMillis() + &quot; ThreadName=&quot; + Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void signalAll_A() &#123; lock.lock(); try &#123; System.out.println(&quot; signalAll_A时间为&quot; + System.currentTimeMillis() + &quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionA.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void signalAll_B() &#123; lock.lock(); try &#123; System.out.println(&quot; signalAll_B时间为&quot; + System.currentTimeMillis() + &quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionB.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 运行结果： 只有A线程被唤醒了。 3. 使用Condition实现顺序执行 ConditionSeqExec.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ConditionSeqExec &#123; volatile private static int nextPrintWho = 1; private static ReentrantLock lock = new ReentrantLock(); final private static Condition conditionA = lock.newCondition(); final private static Condition conditionB = lock.newCondition(); final private static Condition conditionC = lock.newCondition(); public static void main(String[] args) &#123; Thread threadA = new Thread() &#123; public void run() &#123; try &#123; lock.lock(); while (nextPrintWho != 1) &#123; conditionA.await(); &#125; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;ThreadA &quot; + (i + 1)); &#125; nextPrintWho = 2; //通知conditionB实例的线程运行 conditionB.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;; Thread threadB = new Thread() &#123; public void run() &#123; try &#123; lock.lock(); while (nextPrintWho != 2) &#123; conditionB.await(); &#125; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;ThreadB &quot; + (i + 1)); &#125; nextPrintWho = 3; //通知conditionC实例的线程运行 conditionC.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;; Thread threadC = new Thread() &#123; public void run() &#123; try &#123; lock.lock(); while (nextPrintWho != 3) &#123; conditionC.await(); &#125; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;ThreadC &quot; + (i + 1)); &#125; nextPrintWho = 1; //通知conditionA实例的线程运行 conditionA.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;; Thread[] aArray = new Thread[5]; Thread[] bArray = new Thread[5]; Thread[] cArray = new Thread[5]; for (int i = 0; i &lt; 5; i++) &#123; aArray[i] = new Thread(threadA); bArray[i] = new Thread(threadB); cArray[i] = new Thread(threadC); aArray[i].start(); bArray[i].start(); cArray[i].start(); &#125; &#125;&#125; 运行结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445ThreadA 1ThreadA 2ThreadA 3ThreadB 1ThreadB 2ThreadB 3ThreadC 1ThreadC 2ThreadC 3ThreadA 1ThreadA 2ThreadA 3ThreadB 1ThreadB 2ThreadB 3ThreadC 1ThreadC 2ThreadC 3ThreadA 1ThreadA 2ThreadA 3ThreadB 1ThreadB 2ThreadB 3ThreadC 1ThreadC 2ThreadC 3ThreadA 1ThreadA 2ThreadA 3ThreadB 1ThreadB 2ThreadB 3ThreadC 1ThreadC 2ThreadC 3ThreadA 1ThreadA 2ThreadA 3ThreadB 1ThreadB 2ThreadB 3ThreadC 1ThreadC 2ThreadC 3 通过代码很好理解，说简单就是在一个线程运行完之后通过condition.singal()/condition.signalAll()方法通知下一个特定的线程运行，就这样循环往复即可。 注意：默认情况下ReentranLock类使用的是非公平锁。 2.4 公平锁与非公平锁 Lock锁分为：公平锁 和 非公平锁。公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO先进先出顺序。而非公平锁就是一种获取锁的抢占机制，是随机获取锁的，和公平锁不一样的就是先来的不一定先的到锁，这样可能造成某些线程一直拿不到锁，结果也就是不公平的了。 FairorNofairLock.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.locks.ReentrantLock;public class FairorNofairLock &#123; public static void main(String[] args) throws InterruptedException &#123; final Service service = new Service(true);//true为公平锁，false为非公平锁 Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;★线程&quot; + Thread.currentThread().getName() + &quot;运行了&quot;); service.serviceMethod(); &#125; &#125;; Thread[] threadArray = new Thread[10]; for (int i = 0; i &lt; 10; i++) &#123; threadArray[i] = new Thread(runnable); &#125; for (int i = 0; i &lt; 10; i++) &#123; threadArray[i].start(); &#125; &#125; static public class Service &#123; private ReentrantLock lock; public Service(boolean isFair) &#123; super(); lock = new ReentrantLock(isFair); &#125; public void serviceMethod() &#123; lock.lock(); try &#123; System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName() + &quot;获得锁定&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920★线程Thread-0运行了★线程Thread-2运行了★线程Thread-1运行了ThreadName=Thread-0获得锁定★线程Thread-3运行了★线程Thread-4运行了★线程Thread-5运行了ThreadName=Thread-2获得锁定ThreadName=Thread-1获得锁定★线程Thread-6运行了★线程Thread-7运行了ThreadName=Thread-3获得锁定ThreadName=Thread-4获得锁定★线程Thread-8运行了ThreadName=Thread-5获得锁定ThreadName=Thread-6获得锁定ThreadName=Thread-7获得锁定★线程Thread-9运行了ThreadName=Thread-8获得锁定ThreadName=Thread-9获得锁定 公平锁的运行结果是有序的。 把Service的参数修改为false则为非公平锁 1final Service service = new Service(false); //true为公平锁，false为非公平锁 运行结果： 1234567891011121314151617181920★线程Thread-1运行了★线程Thread-3运行了★线程Thread-2运行了★线程Thread-0运行了★线程Thread-4运行了ThreadName=Thread-1获得锁定★线程Thread-5运行了ThreadName=Thread-5获得锁定★线程Thread-6运行了ThreadName=Thread-6获得锁定★线程Thread-7运行了ThreadName=Thread-2获得锁定ThreadName=Thread-3获得锁定★线程Thread-8运行了ThreadName=Thread-0获得锁定ThreadName=Thread-4获得锁定ThreadName=Thread-7获得锁定★线程Thread-9运行了ThreadName=Thread-8获得锁定ThreadName=Thread-9获得锁定 非公平锁的运行结果是无序的。 三 ReadWriteLock接口的实现类：ReentrantReadWriteLock3.1 简介我们刚刚接触到的ReentrantLock（排他锁）具有完全互斥排他的效果，即同一时刻只允许一个线程访问，这样做虽然虽然保证了实例变量的线程安全性，但效率非常低下。ReadWriteLock接口的实现类-ReentrantReadWriteLock读写锁就是为了解决这个问题。 读写锁维护了两个锁，一个是读操作相关的锁也成为共享锁，一个是写操作相关的锁 也称为排他锁。通过分离读锁和写锁，其并发性比一般排他锁有了很大提升。 多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥（只要出现写操作的过程就是互斥的）。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。 3.2 ReentrantReadWriteLock的特性与常见方法ReentrantReadWriteLock的特性： 公平性选择 支持非公平（默认）和公平的锁获取方式，吞吐量上来看还是非公平优于公平 重进入 该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁也能够同时获取读锁 锁降级 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁 ReentrantReadWriteLock常见方法： 构造方法 ReentrantReadWriteLock() 创建一个 ReentrantReadWriteLock()的实例 ReentrantReadWriteLock(boolean fair) 创建一个特定锁类型（公平锁/非公平锁）的ReentrantReadWriteLock的实例 常见方法： 和ReentrantLock类 类似。 3.3 ReentrantReadWriteLock的使用1. 读读共享 两个线程同时运行read方法，你会发现两个线程可以同时或者说是几乎同时运行lock()方法后面的代码，输出的两句话显示的时间一样。这样提高了程序的运行效率。 1234567891011121314151617private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();public void read() &#123; try &#123; try &#123; lock.readLock().lock(); System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName() + &quot; &quot; + System.currentTimeMillis()); Thread.sleep(10000); &#125; finally &#123; lock.readLock().unlock(); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 2. 写写互斥 把上面的代码的 1lock.readLock().lock(); 改为： 1lock.writeLock().lock(); 两个线程同时运行read方法，你会发现同一时间只允许一个线程执行lock()方法后面的代码。 3. 读写互斥 12345678910111213141516171819202122232425262728293031private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();public void read() &#123; try &#123; try &#123; lock.readLock().lock(); System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName() + &quot; &quot; + System.currentTimeMillis()); Thread.sleep(10000); &#125; finally &#123; lock.readLock().unlock(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;public void write() &#123; try &#123; try &#123; lock.writeLock().lock(); System.out.println(&quot;获得写锁&quot; + Thread.currentThread().getName() + &quot; &quot; + System.currentTimeMillis()); Thread.sleep(10000); &#125; finally &#123; lock.writeLock().unlock(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 测试代码： 1234567891011Service service = new Service();ThreadA a = new ThreadA(service);a.setName(&quot;A&quot;);a.start();Thread.sleep(1000);ThreadB b = new ThreadB(service);b.setName(&quot;B&quot;);b.start(); 输出结果： 12获得读锁A 1547869177028获得写锁B 1547869187031 第一条语句和第二条语句间隔10秒，第二条语句和结束间隔10秒，说明是互斥的。 运行两个使用同一个Service对象实例的线程a,b，线程a执行上面的read方法，线程b执行上面的write方法。你会发现同一时间只允许一个线程执行lock()方法后面的代码。记住：只要出现写操作的过程就是互斥的。 4. 写读互斥 和读写互斥类似。记住：只要出现写操作的过程就是互斥的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-join和ThreadLocal的使用]]></title>
    <url>%2F2019%2F01%2F18%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-join%E5%92%8CThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Thread.join()的使用在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。另外，一个线程需要等待另一个线程也需要用到join()方法。 Thread类除了提供join()方法之外，还提供了join(long millis)、join(long millis, int nanos)两个具有超时特性的方法。这两个超时方法表示，如果线程thread在指定的超时时间没有终止，那么将会从该超时方法中返回。 2.1 join方法使用不使用join方法的问题： Test.java 1234567891011121314151617public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread threadTest = new MyThread(); threadTest.start(); //Thread.sleep(?);//因为不知道子线程要花的时间这里不知道填多少时间 System.out.println(&quot;我想当threadTest对象执行完毕后我再执行&quot;); &#125; static public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;我想先执行&quot;); &#125; &#125;&#125; 运行结果： 可以看到子线程中后被执行，这里的例子只是一个简单的演示，我们想一下：假如子线程运行的结果被主线程运行需要怎么办？sleep方法？当然可以，但是子线程运行需要的时间是不确定的，所以sleep多长时间当然也就不确定了。这里就需要使用join方法解决上面的问题。 使用join方法解决上面的问题： Run.java 1234567891011121314151617181920public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread threadTest = new MyThread(); threadTest.start(); //Thread.sleep(?);//因为不知道子线程要花的时间这里不知道填多少时间 threadTest.join(); System.out.println(&quot;我想当threadTest对象执行完毕后我再执行&quot;); &#125; static public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;我想先执行&quot;); &#125; &#125;&#125; 上面的代码仅仅加了一句：threadTest.join()。在这里join方法的作用就是主线程需要等待子线程执行完成之后再结束。 2.2 join(long millis)方法的使用join(long millis)中的参数就是设定的等待时间。 Run.java 12345678910111213141516171819202122232425262728293031public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread threadTest = new MyThread(); threadTest.start(); threadTest.join(2000);// 只等2秒 //Thread.sleep(2000); System.out.println(&quot; end timer=&quot; + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static public class MyThread extends Thread &#123; @Override public void run() &#123; try &#123; System.out.println(&quot;begin Timer=&quot; + System.currentTimeMillis()); Thread.sleep(10000); System.out.println(&quot;last Timer=&quot; + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 输出结果： 可以看到begin和end之间间隔两秒，end和last之间间隔八秒。而且在main中不管是用threadTest.join(2000)还是Thread.sleep(2000)，begin和end的间隔都是两秒，threadTest.join(2000) 和Thread.sleep(2000) 和区别在于： Thread.sleep(2000)不会释放锁，threadTest.join(2000)会释放锁 。 三 ThreadLocal的使用变量值的共享可以使用public static变量的形式，所有线程都使用一个public static变量。如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的ThreadLocal类正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。 再举个简单的例子： 比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。 ThreadLocal类相关方法：get() 返回当前线程的此线程局部变量的副本中的值。set(T value) 将当前线程的此线程局部变量的副本设置为指定的值remove() 删除此线程局部变量的当前线程的值。initialValue() 返回此线程局部变量的当前线程的“初始值” 3.1 ThreadLocal类的初试Test1.java 123456789101112public class Test1 &#123; public static ThreadLocal&lt;String&gt; t1 = new ThreadLocal&lt;String&gt;(); public static void main(String[] args) &#123; if (t1.get() == null) &#123; System.out.println(&quot;为ThreadLocal类对象放入值:aaa&quot;); t1.set(&quot;aaaֵ&quot;); &#125; System.out.println(t1.get());//aaa System.out.println(t1.get());//aaa &#125;&#125; 运行结果： 123为ThreadLocal类对象放入值:aaaaaaֵaaaֵ 从运行结果可以看出，第一次调用ThreadLocal对象的get()方法时返回的值是null,通过调用set()方法可以为ThreadLocal对象赋值。 如果想要解决get()方法null的问题，可以使用ThreadLocal对象的initialValue方法。如下： Test2.java 123456789101112131415161718public class Test2 &#123; public static ThreadLocalExt t1 = new ThreadLocalExt(); public static void main(String[] args) &#123; if (t1.get() == null) &#123; System.out.println(&quot;从未放过值&quot;); t1.set(&quot;我的值&quot;); &#125; System.out.println(t1.get()); System.out.println(t1.get()); &#125; static public class ThreadLocalExt extends ThreadLocal &#123; @Override protected Object initialValue() &#123; return &quot;我是默认值 第一次get不再为null&quot;; &#125; &#125;&#125; 运行结果： 12我是默认值 第一次get不再为null我是默认值 第一次get不再为null 3.2 验证线程变量间的隔离性Test3.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Date;/** *TODO 验证线程变量间的隔离性 */public class Test3 &#123; public static void main(String[] args) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot; 在Main线程中取值=&quot; + Tools.tl.get()); Thread.sleep(100); &#125; Thread.sleep(5000); ThreadA a = new ThreadA(); a.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static public class Tools &#123; public static ThreadLocalExt tl = new ThreadLocalExt(); &#125; static public class ThreadLocalExt extends ThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125; &#125; static public class ThreadA extends Thread &#123; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(&quot;在ThreadA线程中取值=&quot; + Tools.tl.get()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果： 从运行结果可以看出子线程和父线程各自拥有各自的值。 3.3 InheritableThreadLocalThreadLocal类固然很好，但是子线程并不能取到父线程的ThreadLocal类的变量，InheritableThreadLocal类就是解决这个问题的。 取父线程的值： 修改Test3.java的内部类Tools 和ThreadLocalExt类如下： 123456789static public class Tools &#123; public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt(); &#125; static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125; &#125; 运行结果： 取父线程的值并修改： 修改Test3.java的内部类Tools和InheritableThreadLocalExt类如下： 1234567891011121314static public class Tools &#123; public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt();&#125;static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125; @Override protected Object childValue(Object parentValue) &#123; return parentValue + &quot; 我在子线程加的~!&quot;; &#125;&#125; 运行结果： 在使用InheritableThreadLocal类需要注意的一点是：如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的还是旧值。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-wait/notify机制]]></title>
    <url>%2F2019%2F01%2F18%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-wait-notify%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[等待/通知（wait/notify）机制一 等待/通知机制介绍1.1 不使用等待/通知机制当两个线程之间存在生产和消费者关系，也就是说第一个线程（生产者）做相应的操作然后第二个线程（消费者）感知到了变化又进行相应的操作。比如像下面的whie语句一样，假设这个value值就是第一个线程操作的结果，doSomething()是第二个线程要做的事，当满足条件value=desire后才执行doSomething()。 但是这里有个问题就是：第二个语句不停的通过轮询机制来检测判断条件是否成立。如果轮询时间的间隔太小会浪费CPU资源，轮询时间的间隔太大，就可能取不到自己想要的数据。所以这里就需要我们今天讲到的等待/通知（wait/notify）机制来解决这两个矛盾。 while(value=desire){ doSomething(); } 1.2 什么是等待/通知机制？通俗来讲： 等待/通知机制在我们生活中比比皆是，一个形象的例子就是厨师和服务员之间就存在等待/通知机制。 厨师做完一道菜的时间是不确定的，所以菜到服务员手中的时间是不确定的； 服务员就需要去“等待（wait）”； 厨师把菜做完之后，按一下铃，这里的按铃就是“通知（nofity）”； 服务员听到铃声之后就知道菜做好了，他可以去端菜了。 用专业术语讲： 等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()/notifyAll()方法，线程A收到通知后退出等待队列，进入可运行状态，进而执行后续操作。上诉两个线程通过对象O来完成交互，而对象上的wait()方法和notify()/notifyAll()方法的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。 1.3 等待/通知机制的相关方法notify() 随机唤醒等待队列中等待同一共享资源的 “一个线程”，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知“一个线程”. notifyAll() 使所有正在等待队列中等待同一共享资源的 “全部线程” 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现. wait() 使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒 wait(long) 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回. wait(long，int) 对于超时时间更细力度的控制，可以达到纳秒. 二 等待/通知机制的实现2.1 我的第一个等待/通知机制程序MyList.java 12345678910111213141516import java.util.ArrayList;import java.util.List;/** * Created by binzhang on 19/1/16. */public class MyList &#123; private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); public static void add() &#123; list.add(&quot;anyString&quot;); &#125; public static int size() &#123; return list.size(); &#125;&#125; ThreadA.java 1234567891011121314151617181920212223242526272829/** * Created by binzhang on 19/1/16. */public class ThreadA extends Thread &#123; private Object lock; public ThreadA(Object lock) &#123; super(); this.lock = lock; &#125; @Override public void run() &#123; try &#123; synchronized (lock) &#123; if (MyList.size() != 5) &#123; System.out.println(&quot;wait begin &quot; + System.currentTimeMillis()); lock.wait(); System.out.println(&quot;wait end &quot; + System.currentTimeMillis()); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ThreadB.java 123456789101112131415161718192021222324252627282930/** * Created by binzhang on 19/1/16. */public class ThreadB extends Thread &#123; private Object lock; public ThreadB(Object lock) &#123; super(); this.lock = lock; &#125; @Override public void run() &#123; try &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 10; i++) &#123; MyList.add(); if (MyList.size() == 5) &#123; lock.notify(); System.out.println(&quot;已发出通知！&quot;); &#125; System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;); Thread.sleep(1000); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Run.java 12345678910111213141516171819/** * Created by binzhang on 19/1/16. */public class Run &#123; public static void main(String[] args) &#123; try &#123; Object lock = new Object(); ThreadA a = new ThreadA(lock); a.start(); Thread.sleep(50); ThreadB b = new ThreadB(lock); b.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 可以看到：nofify()执行后并不会立即释放锁。 synchronized关键字可以将任何一个Object对象作为同步对象来看待，而Java为每个Object都实现了等待/通知（wait/notify）机制的相关方法，它们必须用在synchronized关键字同步的Object的临界区内。通过调用wait()方法可以使处于临界区内的线程进入等待状态，同时释放被同步对象的锁。而notify()方法可以唤醒一个因调用wait操作而处于阻塞状态中的线程，使其进入就绪状态。被重新唤醒的线程会视图重新获得临界区的控制权也就是锁，并继续执行wait方法之后的代码。如果发出notify操作时没有处于阻塞状态中的线程，那么该命令会被忽略。 如果我们这里不通过等待/通知（wait/notify）机制实现，而是使用如下的while循环实现的话，我们上面也讲过会有很大的弊端。 123while(MyList.size() == 5)&#123; doSomething(); &#125; 2.2 线程的基本状态上面我们已经提到了和线程有关的大部分API，这些API可以改变线程对象的状态。如下图所示： 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 备注：可以用早起坐地铁来比喻这个过程： 还没起床：sleeping 起床收拾好了，随时可以坐地铁出发：Runnable 等地铁来：Waiting 地铁来了，但要排队上地铁：I/O阻塞 上了地铁，发现暂时没座位：synchronized阻塞 地铁上找到座位：Running 到达目的地：Dead 2.3 notify()锁不释放当方法wait()被执行后，锁自动被释放，但执行完notify()方法后，锁不会自动释放。必须执行完notify()方法所在的synchronized代码块后才释放。 2.4 当interrupt方法遇到wait方法当线程呈现wait状态时，对线程对象调用interrupt方法会出现interruptedException异常。 service.java 1234567891011121314151617/** * Created by binzhang on 19/1/17. */public class Service &#123; public void testMethod(Object lock) &#123; try &#123; synchronized (lock) &#123; System.out.println(&quot;begin wait()&quot;); lock.wait(); System.out.println(&quot; end wait()&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println(&quot;出现异常了，因为呈wait状态的线程被interrupt了！&quot;); &#125; &#125;&#125; ThreadA.java 123456789101112131415public class ThreadA extends Thread &#123; private Object lock; public ThreadA(Object lock) &#123; super(); this.lock = lock; &#125; @Override public void run() &#123; Service service = new Service(); service.testMethod(lock); &#125;&#125; Run.java 123456789101112131415public class Run &#123; public static void main(String[] args) &#123; try &#123; Object lock = new Object(); ThreadA a = new ThreadA(lock); a.start(); Thread.sleep(5000); a.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-volatile关键字]]></title>
    <url>%2F2019%2F01%2F18%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[volatile关键字一 简介Java中的“volatile关键字”： 在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。 要解决这个问题，就需要把变量声明为 volatile，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 二 volatile关键字的可见性volatile 修饰的成员变量在每次被线程访问时，都强迫从主存（共享内存）中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主存（共享内存）。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值，这样也就保证了同步数据的可见性。 RunThread.java 12345678910111213141516171819202122232425/** * Created by binzhang on 19/1/16. */public class RunThread extends Thread&#123; private boolean isRunning = true; int m; public boolean isRunning() &#123; return isRunning; &#125; public void setRunning(boolean isRunning) &#123; this.isRunning = isRunning; &#125; @Override public void run() &#123; System.out.println(&quot;进入run了&quot;); while (isRunning == true) &#123; int a=2; int b=3; int c=a+b; m=c; &#125; System.out.println(m); System.out.println(&quot;线程被停止了！&quot;); &#125;&#125; Run.java 1234567891011121314/** * Created by binzhang on 19/1/16. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; RunThread thread = new RunThread(); thread.start(); Thread.sleep(1000); thread.setRunning(false); System.out.println(&quot;已经赋值为false&quot;); &#125;&#125; 运行结果： RunThread类中的isRunning变量没有加上volatile关键字时，运行以上代码会出现死循环，这是因为isRunning变量虽然被修改但是没有被写到主存中，这也就导致该线程在本地内存中的值一直为true，这样就导致了死循环的产生。 解决办法也很简单：isRunning变量前加上volatile关键字即可。 1volatile private boolean isRunning = true; 这样运行就不会出现死循环了。加上volatile关键字后的运行结果： 奇怪的是如果我们在while循环代码里加上任意一个输出语句或者sleep方法你会发现死循环也会停止，不管isRunning变量是否被加上volatile关键字。 这是为什么呢？ 因为：JVM会尽力保证内存的可见性，即使这个变量没有加同步关键字。换句话说，只要CPU有时间，JVM会尽力去保证变量值的更新。这种与volatile关键字的不同在于，volatile关键字会强制的保证线程的可见性。而不加这个关键字，JVM也会尽力去保证可见性，但是如果CPU一直有其他的事情在处理，它也没办法。最开始的代码，一直处于死循环中，CPU处于一直占用的状态，这个时候CPU没有时间，JVM也不能强制要求CPU分点时间去取最新的变量值。而加了输出或者sleep语句之后，CPU就有可能有时间去保证内存的可见性，于是while循环可以被终止。 三 volatile关键字能保证原子性吗？没有确切的说法，《Java并发编程艺术》这本书上说保证但是在自增操作（非原子操作）上不保证，《Java多线程编程核心艺术》这本书说不保证。不过应该是volatile无法保证对变量原子性的，要保证数据的原子性还是要使用synchronized关键字。 四 synchronized关键字和volatile关键字比较volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用synchronized关键字还是更多一些。 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞 volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。 volatile关键字用于解决变量在多个线程之间的可见性，而ynchronized关键字解决的是多个线程之间访问资源的同步性。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-synchronized关键字]]></title>
    <url>%2F2019%2F01%2F17%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[synchronized关键字一 简介Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为“重量级锁”。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后变得在某些情况下并不是那么重了。 本次总结不会介绍synchronized关键字的实现原理，更多的是synchronized关键字的使用。后面在看过《Java并发编程的艺术》之后会再次分析它的实现原理。 本篇博文参考出处:https://blog.csdn.net/qq_34337272/article/details/79655194 二 变量安全性“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量，则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。 如果两个线程同时操作对象中的实例变量，则会出现“非线程安全”，解决办法就是在方法前加上synchronized关键字即可。 三 多个对象多个锁先看例子： HasSelfPrivateNum.java 12345678910111213141516171819202122public class HasSelfPrivateNum &#123; private int num = 0; synchronized public void addI(String username) &#123; try &#123; if (username.equals(&quot;a&quot;)) &#123; num = 100; System.out.println(&quot;a set over!&quot;); //如果去掉hread.sleep(2000)，那么运行结果就会显示为同步的效果 Thread.sleep(2000); &#125; else &#123; num = 200; System.out.println(&quot;b set over!&quot;); &#125; System.out.println(username + &quot; num=&quot; + num); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; ThreadA.java 12345678910111213public class ThreadA extends Thread &#123; private HasSelfPrivateNum numRef; public ThreadA(HasSelfPrivateNum numRef) &#123; super(); this.numRef = numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI(&quot;a&quot;); &#125;&#125; 1234567891011121314ThreadB.javapublic class ThreadB extends Thread &#123; private HasSelfPrivateNum numRef; public ThreadB(HasSelfPrivateNum numRef) &#123; super(); this.numRef = numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI(&quot;b&quot;); &#125;&#125; 1234567891011Run.javapublic class Run &#123; public static void main(String[] args) &#123; HasSelfPrivateNum numRef1 = new HasSelfPrivateNum(); HasSelfPrivateNum numRef2 = new HasSelfPrivateNum(); ThreadA athread = new ThreadA(numRef1); athread.start(); ThreadB bthread = new ThreadB(numRef2); bthread.start(); &#125;&#125; 运行结果：（a num=100停顿一会才执行出来） （按说定义了synchronized，应该等a执行完才执行b的啊，往下看。。。） 上面实例中两个线程ThreadA和ThreadB分别访问同一个类的不同实例的相同名称的同步方法，但是效果确实异步执行。 为什么会这样呢？ 这是因为synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。所以在上面的实例中，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法所属对象的锁Lock，那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象。本例中很显然是两个对象。 在本例中创建了两个HasSelfPrivateNum类对象，所以就产生了两个锁。当ThreadA的引用执行到addI方法中的runThread.sleep(2000)语句时，ThreadB就会“乘机执行”。所以才会导致执行结果如上图所示（备注：由于runThread.sleep(2000)，“a num=100”停顿了两秒才输出） 四 synchronized方法与锁对象通过上面我们知道synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁。如果多个线程访问的是同一个对象，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法，那么其他线程只能呈等待状态。如果多个线程访问的是多个对象则不一定，因为多个对象会产生多个锁。 那么我们思考一下当多个线程访问的是同一个对象中的非synchronized类型方法会是什么效果？ 答案是：会异步调用非synchronized类型方法，解决办法也很简单在非synchronized类型方法前加上synchronized关键字即可。 五 脏读发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过。 PublicVar.java 12345678910111213141516171819202122232425public class PublicVar &#123; public String username = &quot;A&quot;; public String password = &quot;AA&quot;; synchronized public void setValue(String username, String password) &#123; try &#123; this.username = username; Thread.sleep(5000); this.password = password; System.out.println(&quot;setValue method thread name=&quot; + Thread.currentThread().getName() + &quot; username=&quot; + username + &quot; password=&quot; + password); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //该方法前加上synchronized关键字就同步了 public void getValue() &#123; System.out.println(&quot;getValue method thread name=&quot; + Thread.currentThread().getName() + &quot; username=&quot; + username + &quot; password=&quot; + password); &#125;&#125; 12345678910111213141516ThreadA.javapublic class ThreadA extends Thread &#123; private PublicVar publicVar; public ThreadA(PublicVar publicVar) &#123; super(); this.publicVar = publicVar; &#125; @Override public void run() &#123; super.run(); publicVar.setValue(&quot;B&quot;, &quot;BB&quot;); &#125;&#125; 12345678910111213141516171819Test.javapublic class Test &#123; public static void main(String[] args) &#123; try &#123; PublicVar publicVarRef = new PublicVar(); ThreadA thread = new ThreadA(publicVarRef); thread.start(); Thread.sleep(200);//打印结果受此值大小影响 publicVarRef.getValue(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果： 解决办法：getValue()方法前加上synchronized关键字即可。 加上后运行结果： 六 synchronized锁重入“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。 Service.java 123456789101112131415public class Service &#123; synchronized public void service1() &#123; System.out.println(&quot;service1&quot;); service2(); &#125; synchronized public void service2() &#123; System.out.println(&quot;service2&quot;); service3(); &#125; synchronized public void service3() &#123; System.out.println(&quot;service3&quot;); &#125;&#125; MyThread.java 1234567public class MyThread extends Thread &#123; @Override public void run() &#123; Service service = new Service(); service.service1(); &#125;&#125; Run.java 123456public class Run &#123; public static void main(String[] args) &#123; MyThread t = new MyThread(); t.start(); &#125;&#125; 运行结果： 另外可重入锁也支持在父子类继承的环境中 Main.java 123456789101112131415public class Main &#123; public int i = 10; synchronized public void operateIMainMethod() &#123; try &#123; i--; System.out.println(&quot;main print i=&quot; + i); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Sub.java 123456789101112131415public class Sub extends Main &#123; synchronized public void operateISubMethod() &#123; try &#123; while (i &gt; 0) &#123; i--; System.out.println(&quot;sub print i=&quot; + i); Thread.sleep(100); this.operateIMainMethod(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; MyThread.java 1234567public class MyThread extends Thread &#123; @Override public void run() &#123; Sub sub = new Sub(); sub.operateISubMethod(); &#125;&#125; Run.java 123456public class Run &#123; public static void main(String[] args) &#123; MyThread t = new MyThread(); t.start(); &#125;&#125; 运行结果： 说明当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法。 另外出现异常时，其锁持有的锁会自动释放。 七 同步不具有继承性如果父类有一个带synchronized关键字的方法，子类继承并重写了这个方法。但是同步不能继承，所以还是需要在子类方法中添加synchronized关键字。 synchronized同步语句块一 synchronized方法的缺点使用synchronized关键字声明方法有些时候是有很大的弊端的，比如我们有两个线程一个线程A调用同步方法后获得锁，那么另一个线程B就需要等待A执行完，但是如果说A执行的是一个很费时间的任务的话这样就会很耗时。先来看一个暴露synchronized方法的缺点实例，然后在看看如何通过synchronized同步语句块解决这个问题。 Task.java 12345678910111213141516171819202122public class Task &#123; private String getData1; private String getData2; public synchronized void doLongTimeTask() &#123; try &#123; System.out.println(&quot;begin task&quot;); Thread.sleep(3000); getData1 = &quot;长时间处理任务后从远程返回的值1 threadName=&quot; + Thread.currentThread().getName(); getData2 = &quot;长时间处理任务后从远程返回的值2 threadName=&quot; + Thread.currentThread().getName(); System.out.println(getData1); System.out.println(getData2); System.out.println(&quot;end task&quot;); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; CommonUtils.java 12345678public class CommonUtils &#123; public static long beginTime1; public static long endTime1; public static long beginTime2; public static long endTime2;&#125; MyThread1.java 1234567891011121314public class MyThread1 extends Thread &#123; private Task task; public MyThread1(Task task) &#123; super(); this.task = task; &#125; @Override public void run() &#123; super.run(); CommonUtils.beginTime1 = System.currentTimeMillis(); task.doLongTimeTask(); CommonUtils.endTime1 = System.currentTimeMillis(); &#125;&#125; MyThread2.java 1234567891011121314public class MyThread2 extends Thread &#123; private Task task; public MyThread2(Task task) &#123; super(); this.task = task; &#125; @Override public void run() &#123; super.run(); CommonUtils.beginTime2 = System.currentTimeMillis(); task.doLongTimeTask(); CommonUtils.endTime2 = System.currentTimeMillis(); &#125;&#125; Run.java 123456789101112131415161718192021222324252627282930public class Run &#123; public static void main(String[] args) &#123; Task task = new Task(); MyThread1 thread1 = new MyThread1(task); thread1.start(); MyThread2 thread2 = new MyThread2(task); thread2.start(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long beginTime = CommonUtils.beginTime1; if (CommonUtils.beginTime2 &lt; CommonUtils.beginTime1) &#123; beginTime = CommonUtils.beginTime2; &#125; long endTime = CommonUtils.endTime1; if (CommonUtils.endTime2 &gt; CommonUtils.endTime1) &#123; endTime = CommonUtils.endTime2; &#125; System.out.println(&quot;耗时：&quot; + ((endTime - beginTime) / 1000)); &#125;&#125; 运行结果： 从运行时间来看，synchronized方法的问题很明显。可以使用synchronized同步块来解决这个问题。但是要注意synchronized同步块的使用方法，如果synchronized同步块使用不好的话并不会带来效率的提升。 二 synchronized（this）同步代码块的使用修改上例中的Task.java如下： 1234567891011121314151617181920212223242526272829public class Task &#123; private String getData1; private String getData2; public void doLongTimeTask() &#123; try &#123; System.out.println(&quot;begin task&quot;); Thread.sleep(3000); String privateGetData1 = &quot;长时间处理任务后从远程返回的值1 threadName=&quot; + Thread.currentThread().getName(); String privateGetData2 = &quot;长时间处理任务后从远程返回的值2 threadName=&quot; + Thread.currentThread().getName(); synchronized (this) &#123; getData1 = privateGetData1; getData2 = privateGetData2; &#125; System.out.println(getData1); System.out.println(getData2); System.out.println(&quot;end task&quot;); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果： 从上面代码可以看出当一个线程访问一个对象的synchronized同步代码块时，另一个线程仍然可以访问该对象非synchronized同步代码块。 时间虽然缩短了，但是大家考虑一下synchronized代码块真的是同步的吗？它真的持有当前调用对象的锁吗？ 是的。不在synchronized代码块中就异步执行，在synchronized代码块中就是同步执行。 三 synchronized（object）代码块间使用MyObject.java 12public class MyObject &#123;&#125; Service.java 123456789101112131415161718public class Service &#123; public void testMethod1(MyObject object) &#123; synchronized (object) &#123; try &#123; System.out.println(&quot;testMethod1 ____getLock time=&quot; + System.currentTimeMillis() + &quot; run ThreadName=&quot; + Thread.currentThread().getName()); Thread.sleep(2000); System.out.println(&quot;testMethod1 releaseLock time=&quot; + System.currentTimeMillis() + &quot; run ThreadName=&quot; + Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ThreadA.java 12345678910111213141516public class ThreadA extends Thread &#123; private Service service; private MyObject object; public ThreadA(Service service, MyObject object) &#123; super(); this.service = service; this.object = object; &#125; @Override public void run() &#123; super.run(); service.testMethod1(object); &#125;&#125; ThreadB.java 12345678910111213141516public class ThreadB extends Thread &#123; private Service service; private MyObject object; public ThreadB(Service service, MyObject object) &#123; super(); this.service = service; this.object = object; &#125; @Override public void run() &#123; super.run(); service.testMethod1(object); &#125;&#125; Run.java 123456789101112131415public class Run &#123; public static void main(String[] args) &#123; Service service = new Service(); MyObject object = new MyObject(); ThreadA a = new ThreadA(service, object); a.setName(&quot;a&quot;); a.start(); ThreadB b = new ThreadB(service, object); b.setName(&quot;b&quot;); b.start(); &#125;&#125; 运行结果： 可以看出如下图所示，两个线程使用了同一个“对象监视器”，所以运行结果是同步的。 那么如果使用不同的对象监视器会出现什么情况呢？ 修改Run.java： 12345678910111213141516public class Run &#123; public static void main(String[] args) &#123; Service service = new Service(); MyObject object1 = new MyObject(); MyObject object2 = new MyObject(); ThreadA a = new ThreadA(service, object1); a.setName(&quot;a&quot;); a.start(); ThreadB b = new ThreadB(service, object2); b.setName(&quot;b&quot;); b.start(); &#125;&#125; 运行结果： 可以看出如下图所示，两个线程使用了不同的“对象监视器”，所以运行结果就不是同步的了。 四 synchronized代码块间的同步性当一个对象访问synchronized(this)代码块时，其他线程对同一个对象中所有其他synchronized(this)代码块代码块的访问将被阻塞，这说明synchronized(this)代码块使用的“对象监视器”是一个。也就是说和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的。 另外通过上面的学习我们可以得出两个结论。 其他线程执行对象中synchronized同步方法和synchronized(this)代码块时呈现同步效果; 如果两个线程使用了同一个“对象监视器”,运行结果同步，否则不同步. 五 静态同步synchronized方法与synchronized(class)代码块synchronized关键字加到static静态方法和synchronized(class)代码块上都是是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。 Service.java 1234567891011121314151617181920212223242526public class Service &#123; public static void printA() &#123; synchronized (Service.class) &#123; try &#123; System.out.println( &quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printA&quot;); Thread.sleep(3000); System.out.println( &quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printA&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; synchronized public static void printB() &#123; System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printB&quot;); System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printB&quot;); &#125; synchronized public void printC() &#123; System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printC&quot;); System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printC&quot;); &#125;&#125; ThreadA.java 1234567891011public class ThreadA extends Thread &#123; private Service service; public ThreadA(Service service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.printA(); &#125;&#125; ThreadB.java 1234567891011public class ThreadB extends Thread &#123; private Service service; public ThreadB(Service service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.printB(); &#125;&#125; ThreadC.java 1234567891011public class ThreadB extends Thread &#123; private Service service; public ThreadB(Service service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.printB(); &#125;&#125; Run.java 12345678910111213141516public class Run &#123; public static void main(String[] args) &#123; Service service = new Service(); ThreadA a = new ThreadA(service); a.setName(&quot;A&quot;); a.start(); ThreadB b = new ThreadB(service); b.setName(&quot;B&quot;); b.start(); ThreadC c = new ThreadC(service); c.setName(&quot;C&quot;); c.start(); &#125;&#125; 运行结果： 从运行结果可以看出:静态同步synchronized方法与synchronized(class)代码块持有的锁一样，都是Class锁，Class锁对对象的所有实例起作用。synchronized关键字加到非static静态方法上持有的是对象锁。线程A,B和线程C持有的锁不一样，所以A和B运行同步，但是和C运行不同步。 六 数据类型String的常量池属性在Jvm中具有String常量池缓存的功能 123String s1 = &quot;a&quot;;String s2 = &quot;a&quot;;System.out.println(s1==s2);//true 上面代码输出为true.这是为什么呢？ 字符串常量池中的字符串只存在一份！ 即执行完第一行代码后，常量池中已存在 “a”，那么s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。 因为数据类型String的常量池属性，所以synchronized(string)在使用时某些情况下会出现一些问题，比如两个线程运行 1234synchronized(“abc”)｛ ｝和 synchronized(“abc”)｛ ｝ 修饰的方法时，这两个线程就会持有相同的锁，导致某一时刻只有一个线程能运行。所以尽量不要使用synchronized(string)而使用synchronized(object)]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码学习]]></title>
    <url>%2F2019%2F01%2F15%2FHashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HashMap简介HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。 底层数据结构分析JDK1.8之前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 JDK 1.8 HashMap 的 hash 方法源码: JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 对比一下 JDK1.7的 HashMap 的 hash 方法源码. 12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 JDK1.8之后相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 类的属性： 12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 填充因子 final float loadFactor;&#125; loadFactor加载因子 loadFactor加载因子是控制数组存放数组的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load Factor越小，也就是趋近于0 loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 threshold threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 Node节点类源码： 123456789101112131415161718192021222324252627282930313233343536373839 // 继承自 Map.Entry&lt;K,V&gt; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; // 重写hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 重写 equals() 方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 树节点类源码 12345678910111213141516static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 判断颜色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 返回根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; HashMap源码分析构造方法12345678910111213141516171819202122232425262728// 默认构造函数。// 加载因子默认初值 0.75f public More ...HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; // 包含另一个“Map”的构造函数 public More ...HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 &#125; // 指定“容量大小”的构造函数 public More ...HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 指定“容量大小”和“加载因子”的构造函数 public More ...HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; putMapEntries方法： 123456789101112131415161718192021222324final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; put方法HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 对putVal方法添加元素的分析如下： ① 如果定位到的数组位置没有元素 就直接插入。 ② 如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125; 我们再来对比一下 JDK1.7 put方法的代码 对于put方法的分析如下： ① 如果定位到的数组位置没有元素 就直接插入。 ② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。 12345678910111213141516171819202122public V put(K key, V value) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 再插入 return null;&#125; get方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; resize方法进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap常用方法测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package map;import java.util.Collection;import java.util.HashMap;import java.util.Set;public class HashMapDemo &#123; public static void main(String[] args) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 键不能重复，值可以重复 map.put(&quot;san&quot;, &quot;张三&quot;); map.put(&quot;si&quot;, &quot;李四&quot;); map.put(&quot;wu&quot;, &quot;王五&quot;); map.put(&quot;wang&quot;, &quot;老王&quot;); map.put(&quot;wang&quot;, &quot;老王2&quot;);// 老王被覆盖 map.put(&quot;lao&quot;, &quot;老王&quot;); System.out.println(&quot;-------直接输出hashmap:-------&quot;); System.out.println(map); /** * 遍历HashMap */ // 1.获取Map中的所有键 System.out.println(&quot;-------foreach获取Map中所有的键:------&quot;); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+&quot; &quot;); &#125; System.out.println();//换行 // 2.获取Map中所有值 System.out.println(&quot;-------foreach获取Map中所有的值:------&quot;); Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+&quot; &quot;); &#125; System.out.println();//换行 // 3.得到key的值的同时得到key所对应的值 System.out.println(&quot;-------得到key的值的同时得到key所对应的值:-------&quot;); Set&lt;String&gt; keys2 = map.keySet(); for (String key : keys2) &#123; System.out.print(key + &quot;：&quot; + map.get(key)+&quot; &quot;); &#125; /** * 另外一种不常用的遍历方式 */ // 当我调用put(key,value)方法的时候，首先会把key和value封装到 // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取 // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来 // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了 Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue()); &#125; /** * HashMap其他常用方法 */ System.out.println(&quot;after map.size()：&quot;+map.size()); System.out.println(&quot;after map.isEmpty()：&quot;+map.isEmpty()); System.out.println(map.remove(&quot;san&quot;)); System.out.println(&quot;after map.remove()：&quot;+map); System.out.println(&quot;after map.get(si)：&quot;+map.get(&quot;si&quot;)); System.out.println(&quot;after map.containsKey(si)：&quot;+map.containsKey(&quot;si&quot;)); System.out.println(&quot;after containsValue(李四)：&quot;+map.containsValue(&quot;李四&quot;)); System.out.println(map.replace(&quot;si&quot;, &quot;李四2&quot;)); System.out.println(&quot;after map.replace(si, 李四2):&quot;+map); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码学习]]></title>
    <url>%2F2019%2F01%2F14%2FLinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法： 1List list=Collections.synchronizedList(new LinkedList(...)); 内部结构分析 结合上图和LinkedList类中的内部私有类Node就很好理解了： 1234567891011private static class Node&lt;E&gt; &#123; E item;//节点值 Node&lt;E&gt; next;//后继节点 Node&lt;E&gt; prev;//前驱节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。 LinkedList源码分析构造方法空构造方法： 12public LinkedList() &#123; &#125; 用已有的集合创建链表的构造方法： 1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; add()方法add(E e)方法：将元素添加到链表尾部 12345678910111213141516171819public boolean add(E e) &#123; linkLast(e);//这里就只调用了这一个方法 return true; &#125; /** * 链接使e作为最后一个元素。 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode;//新建节点 if (l == null) first = newNode; else l.next = newNode;//指向后继元素也就是指向下一个元素 size++; modCount++; &#125; add(int index, E e)：在指定位置添加元素 12345678public void add(int index, E element) &#123; checkPositionIndex(index); //检查索引是否处于[0-size]之间 if (index == size)//添加在链表尾部 linkLast(element); else//添加在链表中间 linkBefore(element, node(index)); &#125; linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node addAll(Collection c )：将集合插入到链表尾部 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; addAll(int index, Collection c)： 将集合从指定位置开始插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //1:检查index范围是否在size之内 checkPositionIndex(index); //2:toArray()方法把集合的数据存到对象数组中 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; //3：得到插入位置的前驱节点和后继节点 Node&lt;E&gt; pred, succ; //如果插入位置为尾部，前驱节点为last，后继节点为null if (index == size) &#123; succ = null; pred = last; &#125; //否则，调用node()方法得到后继节点，再得到前驱节点 else &#123; succ = node(index); pred = succ.prev; &#125; // 4：遍历数据将数据插入 for (Object o : a) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; //创建新节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果插入位置在链表头部 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果插入位置在尾部，重置last节点 if (succ == null) &#123; last = pred; &#125; //否则，将插入的链表与先前链表连接起来 else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 上面可以看出addAll方法通常包括下面四个步骤： 检查index范围是否在size之内 toArray()方法把集合的数据存到对象数组中 得到插入位置的前驱和后继节点 遍历数据，将数据插入到指定位置 addFirst(E e)： 将元素添加到链表头部 1234567891011121314151617 public void addFirst(E e) &#123; linkFirst(e); &#125; private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点 first = newNode; //如果链表为空，last节点也指向该节点 if (f == null) last = newNode; //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素 else f.prev = newNode; size++; modCount++; &#125; addLast(E e)： 将元素添加到链表尾部，与 add(E e) 方法一样 123public void addLast(E e) &#123; linkLast(e); &#125; 根据位置取数据的方法get(int index)：：根据指定索引返回数据 123456public E get(int index) &#123; //检查index范围是否在size之内 checkElementIndex(index); //调用Node(index)去找到index对应的node然后返回它的值 return node(index).item; &#125; 获取头节点（index=0）数据方法: 123456789101112131415161718public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125;public E element() &#123; return getFirst(); &#125;public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125;public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; 区别： getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中getFirst() 和element() 方法将会在链表为空时，抛出异常 element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException 获取尾节点（index=-1）数据方法: 12345678910public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; &#125; 两者区别： getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只是会返回 null。 根据对象得到索引的方法int indexOf(Object o)： 从头遍历找 12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; int lastIndexOf(Object o)： 从尾遍历找 12345678910111213141516171819public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; 检查链表是否包含某对象的方法：contains(Object o)： 检查对象o是否存在于链表中 123public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; 删除方法 remove() ,removeFirst(),pop(): 删除头节点 123456789101112public E pop() &#123; return removeFirst(); &#125;public E remove() &#123; return removeFirst(); &#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; removeLast(),pollLast(): 删除尾节点 12345678910public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125;public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; 区别： removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。 remove(Object o): 删除指定元素 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; //如果删除对象为null if (o == null) &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (x.item == null) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; else &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (o.equals(x.item)) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; return false; &#125; 当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。 unlink(Node x) 方法： 123456789101112131415161718192021222324252627E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next;//得到后继节点 final Node&lt;E&gt; prev = x.prev;//得到前驱节点 //删除前驱指针 if (prev == null) &#123; first = next;如果删除的节点是头节点,令头节点指向该节点的后继节点 &#125; else &#123; prev.next = next;//将前驱节点的后继节点指向后继节点 x.prev = null; &#125; //删除后继指针 if (next == null) &#123; last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点 &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; remove(int index)：删除指定位置的元素 123456public E remove(int index) &#123; //检查index范围 checkElementIndex(index); //将节点删除 return unlink(node(index)); &#125; LinkedList类常用方法测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package list;import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] srgs) &#123; //创建存放int类型的linkedList LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); /************************** linkedList的基本操作 ************************/ linkedList.addFirst(0); // 添加元素到列表开头 linkedList.add(1); // 在列表结尾添加元素 linkedList.add(2, 2); // 在指定位置添加元素 linkedList.addLast(3); // 添加元素到列表结尾 System.out.println(&quot;LinkedList（直接输出的）: &quot; + linkedList); System.out.println(&quot;getFirst()获得第一个元素: &quot; + linkedList.getFirst()); // 返回此列表的第一个元素 System.out.println(&quot;getLast()获得第最后一个元素: &quot; + linkedList.getLast()); // 返回此列表的最后一个元素 System.out.println(&quot;removeFirst()删除第一个元素并返回: &quot; + linkedList.removeFirst()); // 移除并返回此列表的第一个元素 System.out.println(&quot;removeLast()删除最后一个元素并返回: &quot; + linkedList.removeLast()); // 移除并返回此列表的最后一个元素 System.out.println(&quot;After remove:&quot; + linkedList); System.out.println(&quot;contains()方法判断列表是否包含1这个元素:&quot; + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true System.out.println(&quot;该linkedList的大小 : &quot; + linkedList.size()); // 返回此列表的元素个数 /************************** 位置访问操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素 System.out.println(&quot;After set(1, 3):&quot; + linkedList); System.out.println(&quot;get(1)获得指定位置（这里为1）的元素: &quot; + linkedList.get(1)); // 返回此列表中指定位置处的元素 /************************** Search操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.add(3); System.out.println(&quot;indexOf(3): &quot; + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引 System.out.println(&quot;lastIndexOf(3): &quot; + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引 /************************** Queue操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); System.out.println(&quot;peek(): &quot; + linkedList.peek()); // 获取但不移除此列表的头 System.out.println(&quot;element(): &quot; + linkedList.element()); // 获取但不移除此列表的头 linkedList.poll(); // 获取并移除此列表的头 System.out.println(&quot;After poll():&quot; + linkedList); linkedList.remove(); System.out.println(&quot;After remove():&quot; + linkedList); // 获取并移除此列表的头 linkedList.offer(4); System.out.println(&quot;After offer(4):&quot; + linkedList); // 将指定元素添加到此列表的末尾 /************************** Deque操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.offerFirst(2); // 在此列表的开头插入指定的元素 System.out.println(&quot;After offerFirst(2):&quot; + linkedList); linkedList.offerLast(5); // 在此列表末尾插入指定的元素 System.out.println(&quot;After offerLast(5):&quot; + linkedList); System.out.println(&quot;peekFirst(): &quot; + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素 System.out.println(&quot;peekLast(): &quot; + linkedList.peekLast()); // 获取但不移除此列表的第一个元素 linkedList.pollFirst(); // 获取并移除此列表的第一个元素 System.out.println(&quot;After pollFirst():&quot; + linkedList); linkedList.pollLast(); // 获取并移除此列表的最后一个元素 System.out.println(&quot;After pollLast():&quot; + linkedList); linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头） System.out.println(&quot;After push(2):&quot; + linkedList); linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素） System.out.println(&quot;After pop():&quot; + linkedList); linkedList.add(3); linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表） System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList); linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表） System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList); /************************** 遍历操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.clear(); for (int i = 0; i &lt; 100000; i++) &#123; linkedList.add(i); &#125; // 迭代器遍历 long start = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; iterator.next(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;Iterator：&quot; + (end - start) + &quot; ms&quot;); // 顺序遍历(随机遍历) start = System.currentTimeMillis(); for (int i = 0; i &lt; linkedList.size(); i++) &#123; linkedList.get(i); &#125; end = System.currentTimeMillis(); System.out.println(&quot;for：&quot; + (end - start) + &quot; ms&quot;); // 另一种for循环遍历 start = System.currentTimeMillis(); for (Integer i : linkedList) ; end = System.currentTimeMillis(); System.out.println(&quot;for2：&quot; + (end - start) + &quot; ms&quot;); // 通过pollFirst()或pollLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;(); temp1.addAll(linkedList); start = System.currentTimeMillis(); while (temp1.size() != 0) &#123; temp1.pollFirst(); &#125; end = System.currentTimeMillis(); System.out.println(&quot;pollFirst()或pollLast()：&quot; + (end - start) + &quot; ms&quot;); // 通过removeFirst()或removeLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;(); temp2.addAll(linkedList); start = System.currentTimeMillis(); while (temp2.size() != 0) &#123; temp2.removeFirst(); &#125; end = System.currentTimeMillis(); System.out.println(&quot;removeFirst()或removeLast()：&quot; + (end - start) + &quot; ms&quot;); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[透过源码角度分析ArrayList扩容机制]]></title>
    <url>%2F2019%2F01%2F14%2F%E9%80%8F%E8%BF%87%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一 先从ArrayList的构造函数说起ArrayList有三种方式来初始化，构造方法源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 /** * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 用于默认大小的空数组实例。用它与EMPTY_ELEMENTDATA区别开，以便了解在添加第一个元素时要扩容多少 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认构造函数，初始容量为空构造一个空列表(无参数构造) * 添加第一个元素时，容量扩为10 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123;//初始容量大于0 //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;//初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123;//初始容量小于0，抛出异常 throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; /** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125;``` 可以发现：以无参构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10.## 二 一步一步分析ArrayList扩容机制以无参构造函数创建的ArrayList为例分析：### 1.先来看add()方法 /** * 将指定的元素追加到此列表的末尾。 */ public boolean add(E e) { //添加元素之前，先调用ensureCapacityInternal方法 ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; }1### 2.在看ensureCapacityInternal()方法 //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) { //如果还是空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } 12345当要add进第一个元素时，minCapacity为1，在Math.max()方法比较后，minCatacity为10.### 3.ensureExplicitCapacity()方法如果调用ensureCapacityInternal()方法就一定会执行这个方法： //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); } 12345678我们来仔细分析一下：&gt; * 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length &gt; 0 成立，所以会进入 grow(minCapacity) 方法。&gt; * 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。&gt; * 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。&gt; * 直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。### 4.grow()方法 /** * 要分配的最大数组大小 * 要分配的最大数组大小。 一些VM在阵列中保留一些标题字。 * 尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超过VM限制 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法。 */ private void grow(int minCapacity) { // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 12345678910111213分析grow()方法：&gt; * 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。&gt; * 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。&gt; * 以此类推······补充：&gt; * java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.&gt; * java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.&gt; * java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!### 5.hugeCapacity()方法从上面 grow() 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。 private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); //对minCapacity和MAX_ARRAY_SIZE进行比较 //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小 //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小 //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 123456## 三 System.arraycopy()和Arrays.copyOf()方法阅读源码可以发现ArrayList中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、toArray() 等方法中都用到了该方法！### 3.1 System.arraycopy() 方法 /** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) { rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } 1我们写一个简单的方法测试以下： public class ArraycopyTest { public static void main(String[] args) { // TODO Auto-generated method stub int[] a = new int[10]; a[0] = 0; a[1] = 1; a[2] = 2; a[3] = 3; System.arraycopy(a, 2, a, 3, 3); a[2]=99; for (int i = 0; i &lt; a.length; i++) { System.out.println(a[i]); } } }结果： 0 1 99 2 3 0 0 0 0 01### 3.2 Arrays.copyOf()方法 /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); } 12个人觉得Arrays.copyOf()方法主要是为了给原有数组扩容，测试代码如下： public class ArrayscopyOfTest { public static void main(String[] args) { int[] a = new int[3]; a[0] = 0; a[1] = 1; a[2] = 2; int[] b = Arrays.copyOf(a, 10); System.out.println(&quot;b.length&quot;+b.length); } }结果： 1012345678910### 3.3两者联系和区别联系：&gt; 看两者源代码可以发现copyOf()内部实际调用了System.arraycopy()方法区别：&gt; arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf() 是系统自动在内部新建一个数组，并返回该数组。## 四 ensureCapacity方法ArrayList 源码中有一个 ensureCapacity 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？ /** 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。 * * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&apos;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) { ensureExplicitCapacity(minCapacity); } } 1234最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量从新分配的次数我们通过下面的代码实际测试以下这个方法的效果： public class EnsureCapacityTest { public static void main(String[] args) { ArrayList list = new ArrayList(); final int N = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) { list.add(i); } long endTime = System.currentTimeMillis(); System.out.println(“使用ensureCapacity方法前：”+(endTime - startTime)); list = new ArrayList&lt;Object&gt;(); long startTime1 = System.currentTimeMillis(); list.ensureCapacity(N); for (int i = 0; i &lt; N; i++) { list.add(i); } long endTime1 = System.currentTimeMillis(); System.out.println(&quot;使用ensureCapacity方法后：&quot;+(endTime1 - startTime1)); } }运行结果： 使用ensureCapacity方法前：4637使用ensureCapacity方法后：241`通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量从新分配的次数.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源码阅读-ArrayList]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList简介ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。 它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。 在我们学数据结构的时候就知道了线性表的顺序存储，插入删除元素的时间复杂度为O（n）,求表长以及增加元素，取第 i 元素的时间复杂度为O（1） ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandomAccess 接口，即提供了随机访问功能。RandomAccess 是 Java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。 ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，能被克隆。 ArrayList 实现java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。 ArrayList核心源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176package java.util;import java.util.function.Consumer;import java.util.function.Predicate;import java.util.function.UnaryOperator;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; /** * Default initial capacity. * 默认初始容量大小 */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. * 空数组（用于空实例） */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 用于默认大小空实例的共享空数组实例 * 我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存ArrayList数据的数组 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList 所包含的元素个数 * @serial */ private int size; /** * 带初始容量参数的构造函数。（用户自己指定容量） */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. * 默认构造函数， DEFAULTCAPACITY_EMPTY_ELEMENTDATA为0.初始值为10 * 也就是说初始其实是空数组，当添加一个元素的时候数组容量变为10 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定集合的元素的列表 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; /** * 修改这个ArrayList实例的容量是列表的当前大小 * 可以使用此操作来最小化ArrayList实例的存储 */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; //下面是ArrayList的扩容机制 //ArrayList的扩容机制提高了性能，如果每次只扩充一个 //那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCatacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&apos;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; /** * 要分配的最大数组大小 */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * ArrayList扩容的核心方法 * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为ArrayList定义的最大容量，否则，新容量大小则为 minCapacity。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; //比较minCapacity和MAX_ARRAY_SIZE private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; /** * 返回此列表中的元素数 */ public int size() &#123; return size; &#125; /** * 如果此列表不包含元素，则返回 true */ public boolean isEmpty() &#123; return size == 0; &#125; /** * 如果此列表包含指定的元素，则返回 true */ public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; /** * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1 */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 返回此ArrayList实例的拷贝 * * @return a clone of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance */ public Object clone() &#123; try &#123; ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); &#125; &#125; /** * List转数组 * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 */ public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。 *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(&quot;unchecked&quot;) E elementData(int index) &#123; return (E) elementData[index]; &#125; /** * 返回此列表中指定位置的元素。 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 用指定的元素替换此列表中指定位置的元素。 */ public E set(int index, E element) &#123; //对index进行界限检查 rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; //返回原来在这个位置的元素 return oldValue; &#125; /** * 将特定的元素追加到此列表的末尾 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! //这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true; &#125; /** * 在此列表中的指定位置插入指定的元素。 * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work //返回从列表中删除的元素 return oldValue; &#125; /** * 从列表中删除指定元素的第一个出现位置的元素（如果存在）。 如果列表不包含该元素，则它不会更改。 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /* * 快速删除，用的较少，用时再深究 */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 从列表中删除所有元素 */ public void clear() &#123; modCount++; // 把数组中所有元素的值设为null（？不是释放 应该是后面用垃圾回收机制回收内存） for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; /** * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。 * 将任何后续元素移动到左侧（减少其索引）。 */ protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize; &#125; /** * 检查给定的索引是否在范围内。 */ private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * A version of rangeCheck used by add and addAll. * add和addAll使用的rangeCheck的一个版本 */ private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; /** * 返回IndexOutOfBoundsException细节信息 */ private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+size; &#125; /** * 从此列表中删除指定集合中包含的所有元素。 */ public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; /** * 仅保留此列表中包含在指定集合中的元素。 （取交集） * 即 从此列表中删除其中不包含在指定集合中的所有元素。 * @see Collection#contains(Object) */ public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; /** * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that * is, serialize it). * * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt; * instance is emitted (int), followed by all of its elements * (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order. */ private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is, * deserialize it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; /** * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。 */ public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); return new ListItr(index); &#125; /** * 返回列表中的列表迭代器（按适当的顺序）。 * * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */ public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; /** * 以正确的顺序返回该列表中的元素的迭代器。 * */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; /** * An optimized version of AbstractList.Itr */ private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; /** * An optimized version of AbstractList.ListItr */ private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; /** * Returns a view of the portion of this list between the specified * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * empty.) The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list. For example, the following idiom * removes a range of elements from a list: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * &#123;@link Collections&#125; class can be applied to a subList. * * &lt;p&gt;The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned list. (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; static void subListRangeCheck(int fromIndex, int toIndex, int size) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex); if (toIndex &gt; size) throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex + &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;); &#125; private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125; &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); final int expectedModCount = modCount; @SuppressWarnings(&quot;unchecked&quot;) final E[] elementData = (E[]) this.elementData; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; /** * Creates a &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt; * and &lt;em&gt;fail-fast&lt;/em&gt; &#123;@link Spliterator&#125; over the elements in this * list. * * &lt;p&gt;The &#123;@code Spliterator&#125; reports &#123;@link Spliterator#SIZED&#125;, * &#123;@link Spliterator#SUBSIZED&#125;, and &#123;@link Spliterator#ORDERED&#125;. * Overriding implementations should document the reporting of additional * characteristic values. * * @return a &#123;@code Spliterator&#125; over the elements in this list * @since 1.8 */ @Override public Spliterator&lt;E&gt; spliterator() &#123; return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0); &#125; /** Index-based split-by-two, lazily initialized Spliterator */ static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; &#123; private final ArrayList&lt;E&gt; list; private int index; // current index, modified on advance/split private int fence; // -1 until used; then one past last index private int expectedModCount; // initialized when fence set /** Create new spliterator covering the given range */ ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence, int expectedModCount) &#123; this.list = list; // OK if null unless traversed this.index = origin; this.fence = fence; this.expectedModCount = expectedModCount; &#125; private int getFence() &#123; // initialize fence to size on first use int hi; // (a specialized variant appears in method forEach) ArrayList&lt;E&gt; lst; if ((hi = fence) &lt; 0) &#123; if ((lst = list) == null) hi = fence = 0; else &#123; expectedModCount = lst.modCount; hi = fence = lst.size; &#125; &#125; return hi; &#125; public ArrayListSpliterator&lt;E&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid) ? null : // divide range in half unless too small new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid, expectedModCount); &#125; public boolean tryAdvance(Consumer&lt;? super E&gt; action) &#123; if (action == null) throw new NullPointerException(); int hi = getFence(), i = index; if (i &lt; hi) &#123; index = i + 1; @SuppressWarnings(&quot;unchecked&quot;) E e = (E)list.elementData[i]; action.accept(e); if (list.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; return false; &#125; public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) &#123; if ((hi = fence) &lt; 0) &#123; mc = lst.modCount; hi = lst.size; &#125; else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) &#123; for (; i &lt; hi; ++i) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) a[i]; action.accept(e); &#125; if (lst.modCount == mc) return; &#125; &#125; throw new ConcurrentModificationException(); &#125; public long estimateSize() &#123; return (long) (getFence() - index); &#125; public int characteristics() &#123; return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED; &#125; &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; Objects.requireNonNull(filter); // figure out which elements are to be removed // any exception thrown from the filter predicate at this stage // will leave the collection unmodified int removeCount = 0; final BitSet removeSet = new BitSet(size); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) final E element = (E) elementData[i]; if (filter.test(element)) &#123; removeSet.set(i); removeCount++; &#125; &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; // shift surviving elements left over the spaces left by removed elements final boolean anyToRemove = removeCount &gt; 0; if (anyToRemove) &#123; final int newSize = size - removeCount; for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123; i = removeSet.nextClearBit(i); elementData[j] = elementData[i]; &#125; for (int k=newSize; k &lt; size; k++) &#123; elementData[k] = null; // Let gc do its work &#125; this.size = newSize; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; return anyToRemove; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; elementData[i] = operator.apply((E) elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; Arrays.sort((E[]) elementData, 0, size, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++; &#125;&#125; 源码重点方法分析System.arraycopy()和Arrays.copyOf()方法在ArrayList的源码中我们发现这两个数组复制的方法都被使用到了。如在add中用到了arraycopy()方法实现让数组从index+1的位置开始复制原数组从index开始到最后的元素再在index位置插入新元素 123456789101112131415/** * 在此列表中的指定位置插入指定的元素。 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! //arraycopy()方法实现数组自己复制自己 //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 在toArray()方法中用到了copyOf()方法 123456789/** *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。 *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。 */ public Object[] toArray() &#123; //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); &#125; 联系: 看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法。区别:1.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置2.copyOf()是系统自动在内部新建一个数组，并返回该数组。 ArrayList核心扩容技术1234567891011121314151617181920212223242526272829303132333435363738//下面是ArrayList的扩容机制//ArrayList的扩容机制提高了性能，如果每次只扩充一个，//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。 /** * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量 * @param minCapacity 所需的最小容量 */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&apos;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125; //得到最小扩容量 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; //判断是否需要扩容,上面两个方法都要调用 private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 如果说minCapacity也就是所需的最小容量大于保存ArrayList数据的数组的长度的话，就需要调用grow(minCapacity)方法扩容。 //这个minCapacity到底为多少呢？举个例子在添加元素(add)方法中这个minCapacity的大小就为现在数组的长度加1 if (minCapacity - elementData.length &gt; 0) //调用grow方法进行扩容，调用此方法代表已经开始扩容了 grow(minCapacity); &#125; 12345678910111213141516171819202122/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) &#123; //elementData为保存ArrayList数据的数组 ///elementData.length求数组长度elementData.size是求数组中的元素个数 // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; //将oldCapacity 右移一位，其效果相当于oldCapacity /2， //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍， int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量， if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //再检查新容量是否超出了ArrayList所定义的最大容量， //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE， //如果minCapacity大于最大容量，则新容量则为ArrayList定义的最大容量，否则，新容量大小则为 minCapacity。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 扩容机制代码中的已经做了详细的注释解释。另外值得注意的是大家很容易忽略的一个运算符：移位运算符 简介：移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移)和&gt;&gt;&gt;(无符号右移)。 作用：对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源 比如这里：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。 另外需要注意的是： java 中的length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性. java 中的length()方法是针对字 符串String说的,如果想看这个字符串的长度则用到 length()这个方法. java 中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看! ArrayList经典Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package list;import java.util.ArrayList;import java.util.Iterator;public class ArrayListDemo &#123; public static void main(String[] srgs)&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); System.out.printf(&quot;Before add:arrayList.size() = %d\n&quot;,arrayList.size()); arrayList.add(1); arrayList.add(3); arrayList.add(5); arrayList.add(7); arrayList.add(9); System.out.printf(&quot;After add:arrayList.size() = %d\n&quot;,arrayList.size()); System.out.println(&quot;Printing elements of arrayList&quot;); // 三种遍历方式打印元素 // 第一种：通过迭代器遍历 System.out.print(&quot;通过迭代器遍历:&quot;); Iterator&lt;Integer&gt; it = arrayList.iterator(); while(it.hasNext())&#123; System.out.print(it.next() + &quot; &quot;); &#125; System.out.println(); // 第二种：通过索引值遍历 System.out.print(&quot;通过索引值遍历:&quot;); for(int i = 0; i &lt; arrayList.size(); i++)&#123; System.out.print(arrayList.get(i) + &quot; &quot;); &#125; System.out.println(); // 第三种：for循环遍历 System.out.print(&quot;for循环遍历:&quot;); for(Integer number : arrayList)&#123; System.out.print(number + &quot; &quot;); &#125; // toArray用法 // 第一种方式(最常用) Integer[] integer = arrayList.toArray(new Integer[0]); // 第二种方式(容易理解) Integer[] integer1 = new Integer[arrayList.size()]; arrayList.toArray(integer1); // 抛出异常，java不支持向下转型 //Integer[] integer2 = new Integer[arrayList.size()]; //integer2 = arrayList.toArray(); System.out.println(); // 在指定位置添加元素 arrayList.add(2,2); // 删除指定位置上的元素 arrayList.remove(2); // 删除指定元素 arrayList.remove((Object)3); // 判断arrayList是否包含5 System.out.println(&quot;ArrayList contains 5 is: &quot; + arrayList.contains(5)); // 清空ArrayList arrayList.clear(); // 判断ArrayList是否为空 System.out.println(&quot;ArrayList is empty: &quot; + arrayList.isEmpty()); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this is incompatible with sql_mode=only_full_group_by问题解决]]></title>
    <url>%2F2019%2F01%2F02%2Fthis-is-incompatible-with-sql-mode-only-full-group-by%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[在编写好xml代码在测试类中测试时报错 1this is incompatible with sql_mode=only_full_group_by 看一下ONLY_FULL_GROUP_BY的意思是：对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中，也就是说查出来的列必须在group by后面出现否则就会报错，或者这个字段出现在聚合函数里面。 进入到mysql中查看mysql版本 select version();查看sql_model参数命令：SELECT @@GLOBAL.sql_mode; SELECT @@SESSION.sql_mode;可以看到当前sql_mode。 这里是我改过了的，所以已经没有ONLY_FULL_GROUP_BY了。而我们的解决办法也是去掉这里的ONLY_FULL_GROUP_BY。 方法一：命令行输入：12set @@GLOBAL.sql_mode=&apos;&apos;;set sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;; 默认关掉ONLY_FULL_GROUP_BY！ 这个时候 在用工具select 一下SELECT @@sql_mode;SELECT @@GLOBAL.sql_mode; 发现已经不存在ONLY_FULL_GROUP_BY,代码运行正常。但是如果你重启Mysql服务的话，发现ONLY_FULL_GROUP_BY还是会存在的。 方法二：（推荐）想要彻底解决这个问题还是要去配置文件my.cnf中修改，加入下图内容，保存，重启mysql。 注意这里开始的时候重启有报错，原因是因为mysql8.0以上已经取消了NO_AUTO_CREATE_USER这个关键字，删掉sql语句中的这个关键字即可。 1sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION 12service mysqld stopservice mysqld start 问题解决。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot项目的打包与部署]]></title>
    <url>%2F2018%2F12%2F28%2FSpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[SpringBoot项目的打包与部署1.打包到我们的项目目录下执行打包命令 1mvn clean package -Dmaven.test.skip=true 打包成功后可以看到 BUILD SUCCESS。 target目录下的o2o-0.0.1-SNAPSHOT.jar就是我们打包好的jar包了。这里生成这个版本的jar包的原因是我们在pom.xml中的配置。这里可以通过命令 java -jar o2o-0.0.1-SNAPSHOT.jar来启动我们的项目（注意要将IDE中已经启动的服务关掉否则会冲突）。 这个时候访问我们项目 localhost:8080/frontend/index 发现报404。原因是我们并没有将html页面成功打包进去。其实我们将jar改为war就好了。我们常规需要的也是要打包成war包。 2.部署将war包上传到服务器上scp o2o-0.0.1-SNAPSHOT.war work@101.132.138.185:~将之前的java和tomcat进程都kill掉。去服务器中启动我们的war包程序java -jar o2o-0.0.1-SNAPSHOT.war这里默认是8080端口，可以在application.properties中设置成其它端口。输入地址，可以访问到了，部署成功。 这里java -jar 启动有一个问题，当我们的终端与服务器失去连接后，程序就不再运行了那么要如何让服务器能持续的运行呢创建一个脚本文件 startup.sh 123vim startup.sh#!/bin/sh nohup后台运行 （守护进程）nohup java -jar /home/work/o2o-0.0.1-SNAPSHOT.war &amp; 保存退出后启动startup.sh就好了sh startup.sh 这样就一直跑在我们的服务器了如果要关掉kill掉就好了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot验证码Kaptcha的使用]]></title>
    <url>%2F2018%2F12%2F28%2FSpringBoot%E9%AA%8C%E8%AF%81%E7%A0%81Kaptcha%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在ssm中kapcha的配置主要写在web.xml中，而springboot中并没有使用web.xml文件，所以我们要重新总结下验证码在springboot中的使用。首先我们要将和web.xml中的Kaptcha的相关配置写入到application.properties中 12345678910#Kaptcha的配置kaptcha.border=nokaptcha.textproducer.font.color=redkaptcha.textproducer.font.size=43kaptcha.image.width=135kaptcha.image.height=50kaptcha.textproducer.char.string=ACDEFHKPRSTWX345679kaptcha.noise.color=blackkaptcha.textproducer.char.length=4kaptcha.textproducer.font.names=Arial 再在MvcConfiguration类中进行配置 123456789101112131415161718192021222324252627282930313233343536373839@Value(&quot;$&#123;kaptcha.border&#125;&quot;) private String border; @Value(&quot;$&#123;kaptcha.textproducer.font.color&#125;&quot;) private String fcolor; @Value(&quot;$&#123;kaptcha.image.width&#125;&quot;) private String width; @Value(&quot;$&#123;kaptcha.textproducer.char.string&#125;&quot;) private String cString; @Value(&quot;$&#123;kaptcha.image.height&#125;&quot;) private String height; @Value(&quot;$&#123;kaptcha.textproducer.font.size&#125;&quot;) private String fsize; @Value(&quot;$&#123;kaptcha.noise.color&#125;&quot;) private String nColor; @Value(&quot;$&#123;kaptcha.textproducer.char.length&#125;&quot;) private String clength; @Value(&quot;$&#123;kaptcha.textproducer.font.names&#125;&quot;) private String fnames; /** * 由于web.xml不生效了，需要在这里配置Kaptcha验证码Servlet * @return * @throws ServletException */ @Bean public ServletRegistrationBean servletRegistrationBean() throws ServletException&#123; //只要在前端访问Kaptcha这个路由就会启动这个servlet ServletRegistrationBean servlet = new ServletRegistrationBean(new KaptchaServlet(),&quot;/Kaptcha&quot;); servlet.addInitParameter(&quot;keptcha.border&quot;, border);//无边框 servlet.addInitParameter(&quot;kaptcha.textproducer.font.color&quot;, fcolor);//字体颜色 servlet.addInitParameter(&quot;kaptcha.image.width&quot;, width);//图片宽度 servlet.addInitParameter(&quot;kaptcha.textproducer.char.string&quot;, cString);//使用哪些字符生成验证码 servlet.addInitParameter(&quot;kaptcha.image.height&quot;, height);//图片高度 servlet.addInitParameter(&quot;kaptcha.textproducer.font.size&quot;, fsize);//字体大小 servlet.addInitParameter(&quot;kaptcha.noise.color&quot;, nColor);//干扰线的颜色 servlet.addInitParameter(&quot;kaptcha.textproducer.char.length&quot;, clength);//字符个数 servlet.addInitParameter(&quot;kaptcha.textproducer.font.names&quot;, fnames);//字体 return servlet; &#125; 当然还有别忘了pom里面jar包的引入。 1234567&lt;!-- 验证码相关 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.github.penggle/kaptcha --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot初体验]]></title>
    <url>%2F2018%2F12%2F27%2FSpringBoot%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[首先SpringBoot的开发有两种主流的软件Idea和Spring Tool Suite（感觉就是集成了spring开发环境的eclipse）。这里我们选用后者。可在springboot的官网spring.io里下载。配置好jdk和maven的配置信息。 创建项目 new -&gt; spring starter project输入配置信息，这里我们选用了springboot2.1.1版本选中我们需要的部分包。 另外还要注意最好将我们的maven配置改为阿里云镜像仓库(maven安装目录下的conf/setting.xml中)。 application.properties是springboot非常核心的一个部分。几乎所有的配置信息都会写在这里面包括端口，数据库，mybatis，redis，验证码等等。不过在初始编辑application.properties时写中文注释可以会乱码，编码改为utf8即可。 修改pom文件，写入我们需要的jar包依赖，和ssm比较，因为我们新建的时候预先引入了web和mybatis两个模块，所以这两个不用再次引入，因为springboot自带测试所以junit也不需要了(去掉spring，mybatis，junit)。将dao entity mapper创建好后在测试用例中测试报错如下 1java.lang.AbstractMethodError: Method com/mchange/v2/c3p0/impl/NewProxyPreparedStatement.isClosed()Z is abstract 将pom中的c3p0镜像替换后问题得到解决 将全部package及webapp写好后启动springboot发现跳转到了测试接口hello springboot中，发现是将value写成了name（小坑注意）。 再次访问index接口发现前端报错404。 这里是因为以前的springboot的版本是1.5.8，这里我们使用了2.1.1.在新版本中WebMvcConfigurationAdapter已经废弃，使用了系统建议的WebMvcConfigurationSupport也出现了上图的问题。考虑应该是静态资源的配置问题和视图跳转控制器的问题，也就是原属于WebMvcConfigurationAdapter的addResourceHandlers方法和addViewController方法没有起到应该起到的作用。解决方法：1.解决视图跳转问题，不再采用继承WebMvcConfigurationSupport的方式，改为直接实现WebMvcConfigurer接口，将生成视图解析器由方法转为@Bean注解的类生成 跳转成功解决。2.跳转成功解决后发现前端页面加载静态资源出错 这里其实是我们的addResourceHandlers方法编写错误了，其实重写的时候并不需要对resource进行重写，空方法即可。但是这里我们要写好对图片路径的拼接。（这里是替代ssm中在tomcat的server.xml中docBase配置的替代） 12345678/** * 静态资源配置 */@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //registry.addResourceHandler(&quot;/resources/**&quot;).addResourceLocations(&quot;/resources/&quot;); registry.addResourceHandler(&quot;/upload/**&quot;).addResourceLocations(&quot;file:/Users/binzhang/Documents/shopImages/upload/&quot;);&#125; 此时发现前端还是访问不到我们的图片，在network中可以看到urlhttp://localhost:8080/upload/item/shop/1.jpg直接拷贝到浏览器也发现找不到该图片这是因为在application.properties中我们配置了前缀 12#加入/o2o前缀server.servlet.context-path=/o2o 所以我们也要将项目的前缀追加到我们访问图片的路径地址中http://localhost:8080/o2o/upload/item/shop/1.jpg这样我们就可以访问到了。在代码中添加前缀的步骤(前端实现)：1.在common.js中加入getContextPath方法 1234567/** * 获取项目的ContextPath以便修正图片路由让其正常显示 * @returns */function getContextPath()&#123; return &quot;/o2o/&quot;;&#125; 2.在需要加载图片页面对应的js中加载图片的地方添加getContextPath前缀就好了 注意主要忘了在对应的html中引入common.js。至此，我们的springboot项目可以正常运行了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定期给数据库以及图片进行备份]]></title>
    <url>%2F2018%2F12%2F24%2F%E5%AE%9A%E6%9C%9F%E7%BB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%A5%E5%8F%8A%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[定期给数据库以及图片进行备份实现服务器每天零点零分对数据库和图片进行自动备份利用linux自带的crontab实现数据库以及图片的定期备份。登录阿里云服务器后创建一个文件夹保存我们的备份文件 1234mkdir backupcd backupmkdir sqlmkdir image 备份数据库信息12cd sqlmysqldump -uroot -pyourpassword o2o &gt; /root/backup/sql/o2o`date +%Y%m%d%H%M%S`.sql 可以看到sql备份文件已经生成了。 备份图片压缩包1tar -zcvf /root/backup/image/image `date +%Y%m%d%H%M%S`.tar.gz /root/shopimages/upload/ 就可以发现图片的压缩包生成在目录root/backup/image下了 新建 backup.sh文件将前面的两行指令编辑进去 vim backup.sh 执行sh backup.sh可以发现 sql和image下都生成了新的备份文件. 通过linux的crontab来设定定时任务实现定期备份查看当前已有的定时任务 1crontab -l 因为现在还没有，所以没有查出来 现在编写定时任务定期执行我们的backup.sh 这里我们使用在线Cron表达式生成器来生成我们的命令（百度：在线cron表达式生成器） 注意这里是不支持秒和年的 只支持从分钟到周这五个 选中分钟 将Cron表达式中的？前面的五个*拷贝出来去contab -e中使用（每分钟执行一次的意思）使用 crontab -e 命令可以设置我们的命令 通过命令 tail -f /var/log/cron 可以看到我们定期备份的cron命令已经执行。 我们就可以发现每分钟都会生成新的备份文件了，当然现实场景中我们并不需要每分钟都备份。 我们去备份每天的凌晨备份，拷贝对应的正则表达式 因为这里秒数我们是没办法准确控制0秒的,所以拷贝从第二个零开始 去crontab -e 中将原来的每分钟的替换掉 这里会报错，将？改为*就好了，后面可以去具体了解crontab。 这样就是每天的零点零分去执行一次了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用阿里云碰到的几个坑]]></title>
    <url>%2F2018%2F12%2F24%2F%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E7%A2%B0%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91%2F</url>
    <content type="text"><![CDATA[第一个坑阿里云系统重置后远程连接失败问题因故将阿里云系统重置后，要将开发环境scp到服务器上时连接失败，ssh远程连接同样失败。可以发现报错信息如下： 以编辑器进入这个文件vi /Users/binzhang/.ssh/known_hosts将红线框部分删除掉。 问题得到解决，原因是在我们第一次远程连接的时候，本机会将远程机器的信息写到/Users/binzhang/.ssh/known_hosts文件中，所以如果远程重装系统了，本机一定要先清理掉。 解决方法原文：https://blog.csdn.net/wd2014610/article/details/79945424 第二个坑修改tomcat server.xml启动报错问题首先我们在root用户目录下新建了一个shopimages文件夹，将shop项目相关的图片都放在了这下面，再通过在server.xml中对路径的补全来访问图片地址，这个时候没有问题 因为要进行eclipse的远程调试，而root并不支持远程调试，我们创建了一个新用户work并在work下部署了新的tomcat，在work下的tomcat下修改为同样的配置后报错。将配置修改后问题解决。应为work用户没有访问root目录的权限导致。 第三个坑本地数据库软件连接不上阿里云上的数据库问题在使用本机的MySQL Workbench连接阿里云上的mysql时报如下错误： 解决方法：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的使用]]></title>
    <url>%2F2018%2F12%2F18%2Fredis%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[java中融入redis缓存技术的使用redis相关的配置文件及工具类等： 12345678pom.xml 导入redis.clients jedis 这里用到的版本号 2.9.0spring-redis.xml 这里能直接使用redis.properties里定义的属性是因为在spring-dao.xml引入了redis.propertiesweb.xml(这里已经通过spring-*.xml都引入了)spring-dao.xml（和jdbc.properties一样将redis.properties引入）JedisPoolWriper.javaJedisUtil.javaCacheService(&amp;impl).java 因为我们的redis.properties里的配置是阿里云上面的，所以在直接运行时会报错. 1could not get a resource from the pool 在我们本地执行命令看是否能连上阿里云上的redis 1redis-cli -h 101.132.138.185 然后打ping报error了，并没有收到意料中的pong，可以看到错误信息 1DENIED Redis is running in protected mode 说明现在redis处于保护模式下 这种模式下是不允许远程连接的，所以我们要改变连接模式登录阿里云去更改redis的设置 redis.conf中将protected-mode由yes改为no 重启redis（先找到进程编号，再关掉进程）将redis.conf传入redis-server启动redis 1src/redis-server redis.conf 再次查看发现redis已经又启动起来了回到本地环境，再次远程访问服务器的redis，输入ping，输出pong，连接成功。 这个时候我们的本地就可以正常使用redis功能了在service层中写好代码，这里我们是以地区类的service实现类来做例子，因为通常地区的变更很少，所以我们可以从缓存中读出来，减少服务器数据库压力。AreaService.java: 12345678910public interface AreaService &#123; public static final String AREALISTKEY = &quot;arealist&quot;; /** * 获取区域列表，优先从缓存读取 * @return */ List&lt;Area&gt; getAreaList();&#125; AreaServiceImpl.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Servicepublic class AreaServiceImpl implements AreaService&#123; @Autowired private AreaDao areaDao; @Autowired private JedisUtil.Keys jedisKeys; @Autowired private JedisUtil.Strings jedisStrings; //为了方便销毁redis的值，我们要将这个key的值放到接口中去 并且在变成不可更改的final值 //private static String AREALISTKEY = &quot;arealist&quot;; private static Logger logger = LoggerFactory.getLogger(AreaServiceImpl.class); @Override @Transactional public List&lt;Area&gt; getAreaList() &#123; String key = AREALISTKEY; List&lt;Area&gt; areaList = null; ObjectMapper mapper = new ObjectMapper(); if(!jedisKeys.exists(key))&#123; //当jedis没有目标信息时 //1.从数据库中取出目标集合 areaList = areaDao.queryArea(); String jsonString; try &#123; //2.将目标集合转化为json字符串 jsonString = mapper.writeValueAsString(areaList); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); logger.error(e.getMessage()); throw new AreaOperationException(e.getMessage()); &#125; //3.将json串存入redis中 jedisStrings.set(key, jsonString); &#125;else&#123; String jsonString = jedisStrings.get(key); JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, Area.class); try &#123; areaList = mapper.readValue(jsonString, javaType); &#125; catch (JsonParseException e) &#123; e.printStackTrace(); logger.error(e.getMessage()); throw new AreaOperationException(e.getMessage()); &#125; catch (JsonMappingException e) &#123; e.printStackTrace(); logger.error(e.getMessage()); throw new AreaOperationException(e.getMessage()); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.error(e.getMessage()); throw new AreaOperationException(e.getMessage()); &#125; &#125; return areaList; &#125; &#125; 这里redis使用成功了，当需要加载地区信息时，首先会先查看redis中是否有地区信息，如果没有去数据库中查找出来并转换为json串存到redis中，下次就可以在redis中读到了 可是如果我们长期从这里读取，当数据库里面的信息更新改变时就读不到了，所以我们要定期更新。 这里我们通过CacheService来清空我们想要清除的redis key的信息。CacheService.java: 12345678910public interface CacheService &#123; /** * 依据key前缀删除匹配该模式下的所有key-value 如传入：shopCategory，则shopcategory_allfirstlevel等所有 * 以shopcategory打头的key-value都会被清空 * @param keyPrefix */ void removeFromCache(String keyPrefix); &#125; CacheServiceImple.java: 1234567891011121314@Servicepublic class CacheServiceImpl implements CacheService&#123; @Autowired private JedisUtil.Keys jedisKeys; @Override public void removeFromCache(String keyPrefix) &#123; Set&lt;String&gt; keySet = jedisKeys.keys(keyPrefix + &quot;*&quot;); for(String key:keySet)&#123; jedisKeys.del(key); &#125; &#125;&#125; 在测试类中测试发现，第一次进入query方法是从redis中读到的，在经过cache的remove方法后，第二次进入query方法就是从数据库中重新读取写入redis缓存中的了. 1234567891011121314151617public class AreaServiceTest extends BaseTest&#123; @Autowired private AreaService areaService; @Autowired private CacheService cacheService; @Test public void testGetAreaList()&#123; //因为之前redis中已经存过所以，这里是从redis中取出来的 List&lt;Area&gt; areaList = areaService.getAreaList(); assertEquals(&quot;杭电&quot;,areaList.get(0).getAreaName()); //删除redis中key为arealist的缓存数据 cacheService.removeFromCache(areaService.AREALISTKEY); //上面已经删除了，所以这里会访问数据库并再次存入redis areaList = areaService.getAreaList(); &#125;&#125; 至此，redis配置结束。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密连接数据库明文密码]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%8A%A0%E5%AF%86%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%8E%E6%96%87%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[数据库密码明文加密我们常规的数据库信息都是写在jdbc.properties里面的 这样直接将数据库账号名和密码放在代码中是有一定风险的，存在被黑客窃取的可能，所以我们可以使用加密过的字符串来替换其中的明文密码。效果如图： 那么这一串加密过的字符串是怎么得到的呢？这里我们使用的是DES加密算法，这里主要用到了两个类,DESUtils和EncryptPropertyPlaceholderConfigurer。 DESUtils.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.imooc.o2o.util;import java.security.Key;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/** * DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法 * @author binzhang * */public class DESUtils &#123; private static Key key; //设置密钥 private static String KEY_STR = &quot;myKey&quot;; private static String CHARSETNAME = &quot;UTF-8&quot;; private static String ALGORITHM = &quot;DES&quot;; static &#123; try &#123; //生成DES算法对象 KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM); //运用SHA1安全策略 SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;); //设置上密钥种子 secureRandom.setSeed(KEY_STR.getBytes()); //初始化基于SHA1的算法对象 generator.init(secureRandom); //生成密钥对象 key = generator.generateKey(); generator = null; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /** * 获取加密后的信息 * @param str * @return */ @SuppressWarnings(&quot;restriction&quot;) public static String getEncryptString(String str) &#123; //基于BASE64编码，接受byte[]并转换成String BASE64Encoder base64encoder = new BASE64Encoder(); try &#123; //按UTF8编码 byte[] bytes = str.getBytes(CHARSETNAME); //获取加密对象 Cipher cipher = Cipher.getInstance(ALGORITHM); //初始化密码信息 cipher.init(Cipher.ENCRYPT_MODE, key); //加密 byte[] doFinal = cipher.doFinal(bytes); //byte[]to encode好的String并返回 return base64encoder.encode(doFinal); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; /** * 获取解密之后的信息 * @param str * @return */ public static String getDecryptString(String str) &#123; //基于BASE64编码，接受byte[]并转换成String BASE64Decoder base64decoder = new BASE64Decoder(); try &#123; //将字符串decode成byte[] byte[] bytes = base64decoder.decodeBuffer(str); //获取解密对象 Cipher cipher = Cipher.getInstance(ALGORITHM); //初始化解密信息 cipher.init(Cipher.DECRYPT_MODE, key); //解密 byte[] doFinal = cipher.doFinal(bytes); //返回解密之后的信息 return new String(doFinal, CHARSETNAME); &#125; catch (Exception e) &#123; // TODO: handle exception throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(getEncryptString(&quot;databasename&quot;)); System.out.println(getEncryptString(&quot;databasepassword&quot;));&#125; EncryptPropertyPlaceholderConfigurer.java 12345678910111213141516171819202122232425262728293031323334353637package com.imooc.o2o.util;import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;public class EncryptPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer &#123; //需要加密的字段数组 private String[] encryptPropNames = &#123; &quot;jdbc.username&quot;, &quot;jdbc.password&quot; &#125;; /** * 对关键的属性进行转换 */ @Override protected String convertProperty(String propertyName, String propertyValue) &#123; if (isEncryptProp(propertyName)) &#123; //对已加密的字段进行解密工作 String decryptValue = DESUtils.getDecryptString(propertyValue); return decryptValue; &#125; else &#123; return propertyValue; &#125; &#125; /** * 该属性是否已加密 * @param propertyName * @return */ private boolean isEncryptProp(String propertyName) &#123; //若等于需要加密的field，则进行加密 for (String encryptpropertyName : encryptPropNames) &#123; if (encryptpropertyName.equals(propertyName)) return true; &#125; return false; &#125;&#125; 简要的总结就是DESUtils给我们提供了将我们的数据库用户名和密码通过我们自己设定的key和charset来生成加密后的字符串，将这个字符串拷贝到jdbc.properties中替换掉我们的明文的密码信息。然后再spring-dao.xml中加载jdbc.properties不再使用以前的 1&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 换成使用EncryptPropertyPlaceholderConfigurer这个工具类来加载jdbc.properties 123456789&lt;bean class=&quot;com.imooc.o2o.util.EncryptPropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:redis.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;fileEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse远程调试]]></title>
    <url>%2F2018%2F12%2F17%2FEclipse%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[项目现在部署在服务器上，我们想要通过本地Eclipse来远程调试在服务器上输入命名 1ps -ef | grep tomcat 可以看到我们tomcat是由root用户启动的,这里需要我们改为其他用户,root启动的进程不支持远程调试,这里我们要改为用普通的账号启动tomcat. 这里要注意,普通账号是没办法运行root账号安装的软件的.所以我们要用普通账号安装一下tomcat. 创建新用户的指令 1adduser work 输入密码 1passwd work shudown掉现在的tomcat程序,在tomcat目录下执行bin/shutdown.sh 切换账号 1su work 切换回这个账号的根目录cd ~,可以看到当前的用户路径/home/work,再次上传本地的tomcat到服务器 1scp apache-tomcat-8.5.35.tar.gz work@101.132.138.185:~ 解压这个tomcat 1tar -xzvf file.tar.gz 再将我们的代码部署到上面因为没有改端口号用过ip:8080/o2o就可以访问到了.可是微信登录只能访问80端口,所以我们要做一个转发操作. 切换回root用户关掉firewalld服务,安装iptables-services服务. 1234su rootsystemctl stop firewalld.servicesystemctl disable firewalld.serviceyum install iptables-services 将对80端口的请求转发到8080 12iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080service iptables save #让上面的指令生效 这个时候已经生效了,但是重启服务器就会失效,执行下面两条指令让它永久生效. 12systemctl restart iptables.servicesystemctl enable iptables.service 修改tomcat配置(work下的)修改bin/catalina.sh vim catalina.sh加入的部分： 这句话的意义是 告诉tomcat你要开启一个端口支持远程调试,同时别忘了将服务器的这两个端口号打开 切换回work 重启tomcat shutdown start 这个时候再 ps -ef | grep tomcat,就可以发现这个进程是work的了,包括我们设置的调试信息也有了 回到我们的eclipse,在启动debug服务器（小昆虫）那里找到 Debug Configuration修改配置如下 Eclipse远程调试总结添加新用户，并赋予root权限 12adduser workpasswd work 上传tomcat软件，上传程序war包 将80端口的请求转发至8080端口（永久生效） 1234567systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service # 禁止firewall开机启动yum install iptables-services #安装iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080service iptables savesystemctl restart iptables.servicesystemctl enable iptables.service 远程调试tomcatvim bin/catalina.sh添加 1CATALINA_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,address=8888,server=y,suspend=n&quot; 开通阿里云控制台安全组策略8888端口在eclipse debug做对应的配置即可]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow基础]]></title>
    <url>%2F2018%2F11%2F05%2Ftensorflow%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一些tensorflow学习过程中需要注意的随笔tensorflow 可以分解为tensor（张量）和flow（流或流动两部分）。 任意维度的数据可以称作“张量”，如一维数组、二维矩阵、N维数据。tensorflow如果直译为中文，那就是“张量流”，它最初想要表达的含义是保持计算节点不变，让数据在不同的计算设备上传输并计算。 因为tensorflow主要用于深度学习方面，在深度学习的计算过程中有前向计算和后向传播的过程，所以深度学习中间的每个节点基本上都要执行前向的数值计算，以及后向的残差传播和参数更新。tensorflow把内部的数据都包装成tensor的类型，并且在tensor中包含了前向计算和反向传播时的残差计算，让所有的计算过程都练了起来。 tensorflow通过一个叫数据流图的方式来组织它的数据和运算。在使用tensorflow实现深度学习算法时，先将所有操作（operation）表达成一张图。张量从算法的开始走到结束完成一次向前运算，而残差从后往前就完成了一次后向传播来更新我们要训练的参数。 会话TensorFlow的计算需要在会话中执行。当创建一个会话时，如果没有传递参数，默认情况下它会启动默认的图来构造图结构，并且会将“图”中定义的op根据定义的情况分发到CPU或者GPU的设备上去。 123456789import tensorflow as tfv1 = tf.constant(1, name="value1")v2 = tf.constant(1, name="value2")add_op = tf.add(v1, v2, name="add_op_name")with tf.Session() as sess: result = sess.run(add_op) print("1 + 1 = %.0f" % result) 采用with语句包装，可以在结束with语句块的时候，自动销毁会话的资源。 为什么TensorFlow非得弄一个会话，并且让这些TensorFlow内部的Tensor必须在会话中才能执行，而不是直接使用Python的对象执行呢？这有点类似我们平时用到的Numpy库。我们经常会使用Numpy包来进行一些复杂的计算，比如矩阵乘法。这些计算的内部实现可能是Numpy采用非Python语言写的，从而使得运行效率更高。TensorFlow也类似。因为深度学习的计算很大部分是矩阵和向量的运算，采用GPU的计算运行速度比CPU会有一个数量级上的差别。如果直接使用Python的对象执行，以为python的变量是在CPU上的，所以数据就会频繁地在GPU和CPU的内存传送，效率会大大降低。这对于本来计算量就很大的训练任务简直无法承受了，所以TensorFlow为了更好地避免这些开销，采用会话中的实际计算是在Python之外独立运行的。 使用placeholder填充方式读取数据placeholder填充方式的用法就像它的名字一样，在构建计算图的时候，在要输入的数据的变量的位置采用占位的方式先保留一个placeholder的张量，表示在构建图的时候并不知道这里实际的值是什么，需要在图执行时填充进来。 如果构建了一个包含placeholder操作的图，当在session中调用run方法时，placeholder占用的变量必须通过feed_dict参数传递进去，否则执行会报错。 123456789101112131415#coding=utf-8import tensorflow as tfv1 = tf.placeholder(tf.float32)v2 = tf.placeholder(tf.float32)v_mul = tf.multiply(v1,v2)with tf.Session() as sess: while True: value1 = input("value1: ") value2 = input("value2: ") mul_result = sess.run(v_mul,feed_dict=&#123;v1:value1,v2:value2&#125;) print(mul_result)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[could not create connection to database问题解决]]></title>
    <url>%2F2018%2F10%2F25%2Fdatabase%2F</url>
    <content type="text"><![CDATA[could not create connection to databasewen问题解决 今天要将项目部署到阿里云服务器上时，先将项目里的数据库配置信息改为了阿里云上面的数据库信息，运行启动后报错 1could not create connection to databasewen 查找后发现本机是mysql5.6版本的，而阿里云上装的是mysql8.于是去pom文件中将数据库版本改掉，问题解决。 1234567&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!-- &lt;version&gt;5.1.37&lt;/version&gt; --&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c#运行python程序]]></title>
    <url>%2F2018%2F10%2F23%2Fc-%E8%BF%90%E8%A1%8Cpython%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近做实验室的水体项目，需要在c#中运行python程序。 开始百度到可以通过IronPython直接在c#中调用py文件，在试了一个简单的helloworld确实可以之后就以为搞定搁置了一段时间，在python程序写好后运行发现了问题，IronPython中并不能导入python的第三方模块如numpy。在google之后发现，IronPython是基于.Net平台的，只能加载CLR Assembly，除了标准库，不能加载一般的C Extension。而numpy这种恰好是编译过的，根本不可能在IronPython上正常使用，至此，IronPython方式作废。 想到的第二种方式是将Python文件打包为exe文件，再在c#中调用exe，这里是在python文件中写好main方法的，这样调用exe就可以直接执行，只要传入参数就好了。 12if __name__ == &apos;__main__&apos;: render(sys.argv[1],sys.argv[2],sys.argv[3],sys.argv[4]) 这里面传入的四个参数是水体渲染需要的四个参数，第一个是文件路径，第二个是左上右下坐标，第三个是样本点坐标，第四个是样本点对应的值。这里本来后三个是数组格式的，但是在c#中传入double类型的二维数组之后出错，估计是因为python中没有指定数据类型的概念导致，所以将c#中的数组转化为拼接的字符串传了进来，在python程序中再将字符串按照对应的参数转化为数组。至此搞定了。 将python程序打包成exe是通过pyinstaller 通过pip安装pyinstaller 1pip install pyinstaller 生成exe 1pyinstaller yourprogram.py 这样生成的是一个文件夹，生成单一可直接执行的最好用 -F的 方式 1pyinstaller -F yourprogram.py]]></content>
      <categories>
        <category>其他语言</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>其他语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云部署]]></title>
    <url>%2F2018%2F10%2F18%2F%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[阿里云部署阿里云服务器1.阿里云初始化与执行环境安装今天买了一年的阿里云服务器 开始安装需要的软件，通过在阿里云网站管理控制台的远程连接或者自己通过ssh命令连接到远程服务器 1sudo ssh root@101.132.138.185 接下来需要安装服务器上需要的一系列软件： 1.1 JDK(这里选择的是JDK1.8)下载地址为http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 选择的是jdk-8u144-linux-x64.rpm 1.2 Tomcat 8下载地址为http://tomcat.apache.org/download-80.cgi#8.0.46 选择的是apache-tomcat-8.0.46.tar.gz 1.3 Mysql(这里选择的是Mysql5.7)repo源，后通过centos自带的yum安装下载的地址为https://dev.mysql.com/downloads/repo/yum/ 这里选择mysql57-community-release-el7-11.noarch.rpm 1.4Redis(可选，最好预先安装上，这里选择的版本为4.0.2)下载地址为https://redis.io/download 这里选择redis-4.0.2.tar.gz 将上面的软件都下载到本地,然后通过scp命令上传到服务器1scp -r /Users/binzhang/Documents/Images//1.jpg root@101.132.138.185:. 此时进到远程服务器可以看到已经上传的软件 安装JDKJava程序需要运行在JRE里边，所以要安装JDK 添加可执行权限 1chmod +x jdk-8u191-linux-x64.rpm 安装RPM软件包 1rpm -ivh jdk-8u191-linux-x64.rpm 查看java的版本信息java -version，若出现版本信息则成功 安装Mysql安装用来配置mysql的yum源的rpm包 1rpm -Uvh mysql80-community-release-el7-1.noarch.rpm 安装mysql 1yum install mysql-community-server 开启mysql服务service mysqld start mysql安装成功后创建的超级用户root@localhost的密码会被存储在/var/log/mysqld.log，可以使用如下命令查看密码grep &#39;temporary&#39; password /var/log/mysqld.log 使用mysql生成的root@localhost用户和密码登录数据库，并修改其密码，具体命令：1mysql -uroot -p 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;newpassword&apos;; 注意这里其实遇到了一个问题，在本地远程连接阿里云数据库新建数据库显示账号没有权限，这里设置全部权限的语句为 123456789use mysql;# 创建新用户并赋权# 参数说明# username：你将创建的用户名 这里是herobin# host：指定该用户在哪个主机上可以登录，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登录，可以使用通配符%# password：该用户的登录密码，密码可以为空，如果为空则该用户可以不需要密码登录服务器CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;grant all privileges on *.* to &apos;herobin&apos;@&apos;%&apos;;flush privileges; 开启远程连接 通过阿里云控制台开放3306端口 在阿里云控制台咱们的实例页面下面选择安全组-&gt;配置规则 进入到规则配置页面之后，咱们可以看到目前只有22端口和3389端口支持远程访问，咱们还需要额外开通80端口（微信公众号用），3306端口(mysql)以及6379端口(redis) 之后便能在我们本地通过调用mysql指令远程登录阿里云服务器上的mysql server中，mysql -uwork -P3306 -h47.104.1.235 –p //本机远程登录mysql指令 注意这里踩了一下坑，在配置好后，我用本地MySQLWorkbench连接服务器数据库显示失败Failed to Connect to MySQL at 101.132.138.185:3306 with user herobinAuthentication plugin ‘caching_sha2_password’ cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found 原因：密码加密方式【caching_sha2_password】，客户端不支持。在数据库服务器上登录并修改登录方式：ALTER USER ‘herobin‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘root’; 连上了哈哈哈哈哈哈。 安装redisredis安装很简单，首先解压redis安装包 tar -zxvf redis-4.0.2.tar.gz 设置redis以支持远程登录 vi redis-4.0.2/redis.conf 将bind 127.0.0.1这句话用井号注释掉，这样就能支持远程连接了 此外，还需要给redis.conf添加配置以支持redis作为守护进程一直跑在后台需要加入daemonize yes 安装redis 去到解压后的目录里 cd redis-4.0.2 make //安装redis 启动redis服务 src/redis-server redis.conf redis连接测试 通过redis-cli连接到redis服务器 src/redis-cli 当输入ping得到pong的回应之后，证明redis配置已经完成 安装tomcat8解压tomcat压缩包 1tar -zxvf apache-tomcat-8.0.46.tar.gz 启动tomcat 1./apache-tomcat-8.0.46/bin/startup.sh 1.在服务器上发布并运行自己的web project修改tomcat默认启动端口，从8080修改为80端口，便于微信登录 1vi apache-tomcat-8.0.46/conf/server.xml 重启tomcat 12./apache-tomcat-8.0.46/bin/shutdown.sh./apache-tomcat-8.0.46/bin/startup.sh 把项目里的mysql配置，redis配置（如果有的话）修改为阿里云服务器对应的配置（即ip，端口，密码等配置修改为服务器里安装好的这些软件的对应的配置） 打出自己项目的war包export -&gt; war file 将export出来的war包上传到服务器tomcat的webapps目录下1scp o2o.war root@101.132.138.185:/root/apache-tomcat-8.5.34/webapps 这里要注意上面的命令是上传一个文件的方式，如果是上传目录（文件夹）会报错not a regular file 这时要加上-r就可以了 1scp -r upload root@101.132.138.185:/root/shopImages 上传成功后，没过几秒tomcat便会在webapps目录下自动从项目war包中解析出项目工程目录来，之后通过ip+请求路径的形式便能访问到自己的项目(因为已经设置成80端口)，这是http访问默认的端口，所以不需要在URL添加端口信息了。 此时输入http://101.132.138.185/o2o/frontend/index已经可以访问页面了 遗留问题：页面图片获取不到 图片问题找到了：我们在前端访问服务器上的图片除了数据库中的图片路径还应该加上我们tomcat在服务器上部署的路径才能访问到目标路径。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找工作的准备]]></title>
    <url>%2F2018%2F10%2F17%2F%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[今天问了下师兄找工作要做哪些准备，简单整理可以分为基础类和专业类两方面的准备： 基础类： 计算机网络 操作系统 数据结构（要刷题） 专业类(java)： 虚拟机(jvm) 要刷3-5遍 jdk底层源码，如ArrayList,HashMap… Spring源码 MyBatis源码 时间已经比较紧迫了，还是要拼一波进大公司的，加油。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用lombok省略set和get方法]]></title>
    <url>%2F2018%2F07%2F22%2Fspringboot%E4%BD%BF%E7%94%A8lombok%E7%9C%81%E7%95%A5set%E5%92%8Cget%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用lombok省略setget方法首先在pom中加入lombok依赖包 pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 第二步要在preferences里的plugins中安装lombok插件 这样就可以用过lombok的@Data注解省略set和get方法了 ProductCategory.java 12345678910111213141516171819202122232425262728293031323334/** * 类目 * Created by binzhang on 18/7/21. */@Entity//用这个注解才能实现动态更新（update_time的更新）@DynamicUpdate@Datapublic class ProductCategory &#123; @Id @GeneratedValue private Integer categoryId; // 类目名字 private String categoryName; // 类目编号 private Integer categoryType; private Date createTime; private Date updateTime; @Override public String toString() &#123; return &quot;ProductCategory&#123;&quot; + &quot;categoryId=&quot; + categoryId + &quot;, categoryName=&apos;&quot; + categoryName + &apos;\&apos;&apos; + &quot;, categoryType=&quot; + categoryType + &quot;, createTime=&quot; + createTime + &quot;, updateTime=&quot; + updateTime + &apos;&#125;&apos;; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成jpa自动创建更新时间]]></title>
    <url>%2F2018%2F07%2F22%2Fspringboot%E9%9B%86%E6%88%90jpa%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[使用springboot+jpa时，直接在dao层集成JpaRepository就可以直接使用接口内部定义好的增删改查方法了。 这里我们可以优化实体类与数据库之间的映射，让每次新建记录的时候自动产生create_time和update_time，每次更新的时候自动更新update_time。 数据库创建语句： 12345678CREATE TABLE `product_category` ( `category_id` int(11) NOT NULL AUTO_INCREMENT, `category_name` varchar(64) NOT NULL COMMENT &apos;类目名字&apos;, `category_type` int(11) NOT NULL COMMENT &apos;类目编号&apos;, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;, `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;修改时间&apos;, PRIMARY KEY (`category_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 对应表ProductCategory.java: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.imooc.entity;import org.hibernate.annotations.DynamicUpdate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import java.util.Date;/** * 类目 * Created by binzhang on 18/7/21. */@Entity//用这个注解才能实现动态更新（update_time的更新）@DynamicUpdatepublic class ProductCategory &#123; @Id @GeneratedValue private Integer categoryId; // 类目名字 private String categoryName; // 类目编号 private Integer categoryType; private Date createTime; private Date updateTime; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getCategoryName() &#123; return categoryName; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125; public Integer getCategoryType() &#123; return categoryType; &#125; public void setCategoryType(Integer categoryType) &#123; this.categoryType = categoryType; &#125; public Date getCreateTime() &#123;return createTime;&#125; public void setCreateTime(Date createTime) &#123;this.createTime = createTime;&#125; public Date getUpdateTime() &#123;return updateTime;&#125; public void setUpdateTime(Date updateTime) &#123;this.updateTime = updateTime;&#125; @Override public String toString() &#123; return &quot;ProductCategory&#123;&quot; + &quot;categoryId=&quot; + categoryId + &quot;, categoryName=&apos;&quot; + categoryName + &apos;\&apos;&apos; + &quot;, categoryType=&quot; + categoryType + &quot;, createTime=&quot; + createTime + &quot;, updateTime=&quot; + updateTime + &apos;&#125;&apos;; &#125;&#125; 这样更新的时候我们就可以不用去管create_time和update_time了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot-logback日志框架的使用]]></title>
    <url>%2F2018%2F07%2F21%2Fspringboot-logback%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一 日志的简单介绍（可直接看第二部分） 什么是日志框架 日志框架的选择 Logback的使用和配置 什么是日志框架 是一套能实现日志输出的工具包 能够描述系统运行状态的所有时间都可以算作日志（用户下线，接口超时，数据库崩溃等等） 日志框架的能力 定制输出目标 定制输出格式 携带上下文信息 运行时选择性输出 灵活的配置 优异的性能 常见的日志框架 JUL JCL Log4j Log4j2 Logback SLF4j jboss-logging 日志门面：JCL SLF4j jboss-logging 日志实现：Log4j Log4j2 JUL SLF4j Log4j Logback为同一个作者，实际上，logback是Log4j 2.0 Log4j2和Log4j并没有直接联系 在springboot中我们选用的是SLF4j+Logback 新建一个简单的测试类： 1234567891011121314151617/** * Created by binzhang on 19/1/21. */@RunWith(SpringRunner.class)@SpringBootTestpublic class LoggerTest &#123; private final Logger logger = LoggerFactory.getLogger(LoggerTest.class); @Test public void test1()&#123; logger.debug(&quot;debug...&quot;); logger.info(&quot;info...&quot;); logger.error(&quot;error...&quot;); &#125;&#125; 运行结果： 为什么只输出了info和error呢？ 因为我们控制台打印的日志的级别默认是info，debug级别小于info故没有输出。 可以去Level类中查看级别（ctrl+o查找类，slf4j下的）源码： Level.java 12345678910111213141516171819202122232425262728/** * * @author ceki * @since 1.7.15 */public enum Level &#123; ERROR(ERROR_INT, &quot;ERROR&quot;), WARN(WARN_INT, &quot;WARN&quot;), INFO(INFO_INT, &quot;INFO&quot;), DEBUG(DEBUG_INT, &quot;DEBUG&quot;), TRACE(TRACE_INT, &quot;TRACE&quot;); private int levelInt; private String levelStr; Level(int i, String s) &#123; levelInt = i; levelStr = s; &#125; public int toInt() &#123; return levelInt; &#125; /** * Returns the string representation of this Level. */ public String toString() &#123; return levelStr; &#125;&#125; 逐层向下可看到级别定义所在类LocationAwareLogger.java: 12345678910111213public interface LocationAwareLogger extends Logger &#123; // these constants should be in EventContants. However, in order to preserve binary backward compatibility // we keep these constants here final public int TRACE_INT = 00; final public int DEBUG_INT = 10; final public int INFO_INT = 20; final public int WARN_INT = 30; final public int ERROR_INT = 40; public void log(Marker marker, String fqcn, int level, String message, Object[] argArray, Throwable t);&#125; 可以知道级别从小到大依次为： TRACE 0 DEBUG 10 INFO 20 WARN 30 ERROR 40 二 logback的使用两种配置方式 application.yml（简便） logback-spring.xml（功能完善，推荐） logback的功能需求 区分info和error日志 每天产生一个日志文件 当我们在yml中配置时： 可以看到输出明显和之前不一样了，说明可以在logging: pattern: console中配置文件的输出格式，这里只配置了时间 - 信息 换行符。 还可以在这里配置其他的如日志生成目录，日志级别等。 但是在yml中功能会有很多制约，所以我们一般使用logback-spring.xml的方式。 在resource下新建和application.yml同级的文件logback-spring.xml。 logback-spring.xml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration&gt; &lt;!--日志格式的配置--&gt; &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt; %d - %msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--配置info级别的滚动的文件输出，每天生成一篇--&gt; &lt;appender name=&quot;fileInfoLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!--设置过滤输出范围 注意 设置为INFO比INFO高的也会打印出来 所以使用后面那种方法--&gt; &lt;!--&lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;--&gt; &lt;!--&lt;level&gt;INFO&lt;/level&gt;--&gt; &lt;!--&lt;/filter&gt;--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略，按照时间来滚动，每天一个日志文件--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt;/Users/binzhang/Documents/log/sell/info.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--配置error级别的滚动的文件输出，每天生成一篇--&gt; &lt;appender name=&quot;fileErrorLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!--设置过滤输出范围--&gt; &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!--滚动策略，按照时间来滚动，每天一个日志文件--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--路径--&gt; &lt;fileNamePattern&gt;/Users/binzhang/Documents/log/sell/error.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot; /&gt; &lt;appender-ref ref=&quot;fileInfoLog&quot; /&gt; &lt;appender-ref ref=&quot;fileErrorLog&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt; 配置好后再次执行LoggerTest测试类，发现两条需求均已满足，在目录下生成了对应的error和info日志文件，且里面内容对应正确。 至此，springboot与logback配置成功。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫于反爬虫]]></title>
    <url>%2F2018%2F05%2F12%2Fscrapy%E7%88%AC%E8%99%AB%E4%BA%8E%E5%8F%8D%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫和反爬虫 爬虫：自动获取网站数据的程序，关键是批量的获取 反爬虫：使用技术手段防止爬虫程序的方法 误伤：反爬技术将普通用户识别为爬虫，如果误伤过高，效果再好也不能用 成本：反爬虫需要的人力和机器成本 拦截：成功拦截爬虫，一般拦截率越高，误伤率越高 反爬虫的目的 初级爬虫：简单粗暴，不管服务器压力，容易弄挂网站 数据保护 失控的爬虫：由于某些情况下，忘记或者无法关闭的爬虫 商业竞争对手 爬虫和反爬虫对抗过程 爬虫和网站攻坚过程 爬虫：分析网络请求，用scrapy写爬虫爬取数据 网站：监控发现某个时间段访问陡增，ip相同，useragent都是python，直接限制访问（不能封ip） 爬虫：User-agent模拟firefox，获取ip代理 网站：发现ip变化，直接要求登录才能访问 爬虫：注册账号，每次请求带cookie或者token 网站：健全账号体系，即A只能访问好友的信息 爬虫：注册多个账号，多个账号联合爬取 网站：请求过于频繁，进一步加剧ip访问频率限制 爬虫：模仿人请求，限制请求速度 网站：弹出验证码，让识别验证码 爬虫：通过各种手段识别验证码 网站：1.增加动态网站，数据通过js动态加载，增加网络分析复杂2.发现大量请求只请求html，不请求image和css以及js 爬虫：通过selenium和phantomjs完全模拟浏览器操作 网站：成本太高，放弃… 随机调用User-agent 1234settings.py user_agent_list = [&quot;&quot;,&quot;&quot;,....] 123456789zhihu.pyfrom settings import user_agent_listimport randomrandom_index = random.randint(0, len(user_agent_list)-1)random_agent = user_agent_list[random_index]headers = &#123;&quot;User-agent&quot;: random_agent,...&#125; 然而这样代码冗余了 从上面流程图可以看到每次访问（4）都会请求MiddleWare，可以在settings中将DOWNLOADER_MIDDLEWARES的注释放开，在里面配置自己的Middleware 我们自定义的middleware写在自动生成的middlewares.py中 更简单的方法，使用插件fake-useragent 12345from fake_useragent import UserAgentua = UserAgent()ua.ieua.firefox #而且每次都是不一样的随机的版本ua.random #不同浏览器不同版本随机切换 123456settings:from fake_useragent import UserAgentDOWNLOADER_MIDDLEWARES = &#123; &apos;ArticleSpider.middlewares.ArticlespiderDownloaderMiddleware&apos;: 543, &apos;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&apos;: None,&#125; 可以设置RANDOM_UA_TYPE来制定浏览器或者randomRANDOM_UA_TYPE = &quot;random&quot; 123456789101112131415161718middleware:class RandomUserAgentMiddleware(object): #随机更换user-agent def __init__(self, crawler): super(RandomUserAgentMiddleware, self).__init__() # self.user_agent_list = crawler.settings.get(&quot;user_agent_list&quot;,[]) self.ua = UserAgent() self.ua_type = crawler.settings.get(&quot;RANDOM_UA_TYPE&quot;, &quot;random&quot;) @classmethod def from_crawler(cls, crawler): return cls(crawler) def process_request(self, request, spider): # request.headers.setdefault(&quot;User-Agent&quot;, self.ua.random) def get_ua(): return getattr(self.ua, self.ua_type) request.headers.setdefault(&quot;User-Agent&quot;, get_ua()) 用代理ip速度会比较慢，可以用自己的ip注意限速爬取 ip代理 可以用西刺http://www.xicidaili.com/ 也是加在上面的process_request中 request.meta[&quot;proxy&quot;] = &quot;http://122.114.31.177:808&quot; 但是一个ip是不够的 我们要设置一个ip代理池 随机获取使用 这里可以通过爬取西刺这个网站 获取到代理ip的信息使用 用脚本的方式写这个爬虫，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import requestsfrom scrapy.selector import Selectorimport MySQLdbconn = MySQLdb.connect(host=&quot;127.0.0.1&quot;, user=&quot;root&quot;, passwd=&quot;1234&quot;, db=&quot;article&quot;, charset=&quot;utf8&quot;)cursor = conn.cursor()def crawl_ips(): #爬取西刺的免费ip代理 headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&quot;&#125; for i in range(10): re = requests.get(&quot;http://www.xicidaili.com/nn/&#123;0&#125;&quot;.format(i), headers=headers) selector = Selector(text=re.text) all_trs = selector.css(&quot;#ip_list tr&quot;) ip_list = [] for tr in all_trs[1:]: speed_str = tr.css(&quot;.bar::attr(title)&quot;).extract()[0] if speed_str: speed = float(speed_str.split(&quot;秒&quot;)[0]) all_texts = tr.css(&quot;td::text&quot;).extract() ip = all_texts[0] port = all_texts[1] proxy_type = all_texts[5] ip_list.append((ip, port, proxy_type, speed)) print(all_texts) for ip_info in ip_list: cursor.execute( &quot;insert into proxy_ip(ip, port, speed, proxy_type) VALUES (&apos;&#123;0&#125;&apos;, &apos;&#123;1&#125;&apos;, &apos;&#123;2&#125;&apos;, &apos;HTTP&apos;)&quot;.format( ip_info[0], ip_info[1], ip_info[3] ) ) conn.commit()class GetIP(object): def delete_ip(self, ip): #从数据库中删除无效的ip delete_sql = &quot;delete from proxy_ip where ip=&apos;&#123;0&#125;&apos;&quot;.format(ip) cursor.execute(delete_sql) conn.commit() return True def judge_ip(self, ip, port): #判断ip是否可用 http_url = &quot;http://www.baidu.com&quot; proxy_url = &quot;http://&#123;0&#125;:&#123;1&#125;&quot;.format(ip, port) try: proxy_dict = &#123; &quot;http&quot;:proxy_url &#125; response = requests.get(http_url,proxies=proxy_dict) except Exception as e: print(&quot;invalid ip and port&quot;) self.delete_ip(ip) return False else: code = response.status_code if code &gt;= 200 and code &lt;=300: print(&quot;effective ip&quot;) return True else: print(&quot;invalid ip and port&quot;) self.delete_ip(ip) return False def get_random_ip(self): #从数据库中随机获取一个可用的ip random_sql= &quot;&quot;&quot; SELECT ip,port FROM proxy_ip ORDER BY RAND() LIMIT 1 &quot;&quot;&quot; result = cursor.execute(random_sql) for ip_info in cursor.fetchall(): ip = ip_info[0] port = ip_info[1] judge_re = self.judge_ip(ip, port) if judge_re: return &quot;http://&#123;0&#125;:&#123;1&#125;&quot;.format(ip, port) else: return self.get_random_ip()# crawl_ips()#注意这里的用法if __name__ == &quot;__main__&quot;: a = GetIP() b = a.get_random_ip() print (b) middleware中编写获取ip代理： 123456from tools.crawl_xici_ip import GetIPclass RandomProxyMiddleware(object): #动态设置ip代理 def process_request(self, request, spider): get_ip = GetIP() request.meta[&quot;proxy&quot;] = get_ip.get_random_ip() scrapy-proxies github上有 可以去上面看 免费的代理ip可能不稳定，如果有需要可以试试收费的scrapy-crawlera github上有的 tor：洋葱网络 洋葱浏览器 经过包装达到隐藏ip效果 验证码识别方法 编码实现（tesseract-ocr）：识别率低 在线打码：高 例：云打码 人工打码：几乎就是人在操作。。。 其他防止被识别的技能： 禁用cookie (request就不会把我们的cookie带过去)（一般要登录的不禁用，不用登陆的禁用）settings中：COOKIES_ENABLED = False启用限速扩展 （前面已经说过了）要先开启再设置值 AUTOTHROTTLE_ENABLED = TRUEDOWNLOAD_DELAY = 10 给不用的spider适用不用的setting值 123456class LagouSpider(CrawlSpider): #这里的会覆盖settings里的 custom_settings = &#123; &quot;COOKIES_ENABLED&quot;: True &#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy爬虫]]></title>
    <url>%2F2018%2F05%2F10%2Fscrapy%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[技术选型 scrapy vs requests + beautifulsoup 1.requests和beautifulsoup都是库，scrapy是框架 2.scrapy框架中可以加入requests和beautifulsoup 3.scrapy基于twisted，性能是最大的优势 4.scrapy方便扩展，提供了很多内置的功能 5.scrapy内置的css和xpath selector非常方便，beautifulsoup最大的缺点就是慢 网页分类 1.静态网页 2.动态网页 3.webservice(restapi) 爬虫作用 1.搜索引擎—百度、google、垂直领域搜索引擎 2.推荐引擎—今日头条 3.机器学习的数据样本 4.数据分析（如金融数据分析）、舆情分析等 正则表达式 1234^[0-9]+abc$^为匹配输入字符串的开始位置[0-9]+匹配多个数字，[0-9]匹配单个数字，+匹配一个或者多个abc$匹配字母abc并以abc结尾，$为匹配输入字符串的结束位置 实例 匹配以数字开头，并以abc结尾的字符串： 123456789var str = &quot;123abc&quot;;var str1 = &quot;12323123abc&quot;;var str2 = &quot;12323123abcabc&quot;;var patt1 = /^[0-9]+abc$/;document.write(str.match(patt1));输出结果123abc12323123abcnull 为什么使用正则表达式 典型的搜索和替换操作要求提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串的模式。例如，可以测试输入字符串，以查看字符串是否出现电话号码模式或者信用卡号码模式。这称为数据验证。*替换文本可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串 可以查找文档内或输入域内特定的文本 1234567891011# _*_ coding: utf-8 _*_import reline = &quot;bobby123&quot;reges_str = &quot;^b.*&quot;if re.match(reges_str,line): print(&quot;yes&quot;)else: print(&quot;no&quot;)# ^b.* :以b开头的后面任意字符任意多个 .任意字符 *任意多个 12345678# _*_ coding: utf-8 _*_import reline = &quot;booooooobby123&quot;regex_str = &quot;.*(b.*b).*&quot;match_obj = re.match(regex_str,line)if match_obj: print(match_obj.group(1)) 输出结果：bb因为是贪婪匹配 从后往前匹配的 booooooobby123 12345678# _*_ coding: utf-8 _*_import reline = &quot;booooooobby123&quot;regex_str = &quot;.*?(b.*b).*&quot;match_obj = re.match(regex_str,line)if match_obj: print(match_obj.group(1)) 输出结果：booooooob 贪婪匹配：在满足匹配时，匹配尽可能长的字符串，默认情况下，采用贪婪匹配 非贪婪匹配：在满足匹配时，匹配尽可能短的字符串，使用?来表示非贪婪匹配 特殊字符 1) ^ $ * ? + {2} {2,} {2,5} | 2) []：字符集合 [^]：负值字符集合，匹配未包含的 [a-z] 3) \s \S \w \W 空格 a-zA-Z0-9_ 4) [\u4E00-\u9FA5] () \d 中文 数字 12345678910111213# _*_ coding: utf-8 _*_import re##提取生日的小demoline = &quot;XXX出生于2001年6月1日&quot;#line = &quot;XXX出生于2001/6/1&quot;#line = &quot;XXX出生于2001-6-1&quot;#line = &quot;XXX出生于2001-06-01&quot;#line = &quot;XXX出生于2001-06&quot;regex_str = &quot;.*出生于(\d&#123;4&#125;[年/-]\d&#123;1,2&#125;([月/-]\d&#123;1,2&#125;|[月/-]$|$))&quot;match_obj = re.match(regex_str,line)if match_obj: print(match_obj.group(1)) 深度优先和广度优先 深度优先过程 1234567def depth_tree(tree_node): if tree_node is not None: print(tree_node._data) if tree_node._left is not None: return depth_tree(tree_node._left) if tree_node._right is not None: return depth_tree(tree_node._right) 广度优先过程1234567891011121314def level_queue(root): &quot;&quot;&quot;利用队列实现树的广度优先遍历&quot;&quot;&quot; if root is None: return my_queue = [] node = root my_queue.append(node) while my_queue: node = my_queue.pop(0) print(node.elem) if node.lchild is not None: my_queue.append(node.lchild) if node.rchild is not None: my_queue.append(node.rchild) 爬虫去重策略 1.将访问过的url保存到数据库中 2.将访问过的url保存到set中，只需要o(1)的代价就可以查询url因为存在内存中，所以对内存要求较高，例如一亿个url占用空间100000000*2byte*50个字符/1024/1024/1024=9G 3.url经过md5等方法哈希后保存到set中 （scrapy用的就是这个） 4.用bitmap方法，将访问过的url通过hash函数映射到某一位 5.bloomfilter方法对bitmap进行改进，多重hash函数降低冲突 字符串编码 1.计算机只能处理数字，文本转换为数字才能处理。计算机中8个bit作为一个字节，所以一个字节能表示最大的数字就是255 2.计算机是美国人发明的，所以一个字节可以表示所有字符了，所以ASCII（一个字节）编码就成为美国人的标准编码 3.但是ASCII处理中文明显是不够的，中文不止255个汉字，所以中国制定了GB2312编码，用两个字节表示一个汉字。GB2312还把ASCII包含进去了，同理，日文，韩文等等上百个国家为了解决这个问题就都发展了一套字节的编码，标准就越来越多，如果出现多种语言混合显示就一定会出现乱码 4.于是unicode出现了，将所有语言统一到一套编码里 看一下ASCII和unicode编码：1）字母A用ASCII编码十进制是65，二进制0100 00012）汉字“中”已近超出了ASCII编码的范围，用unicode编码是20013 二进制是01001110 001011013）A用unicode编码只需要前面补0二进制是00000000 0100 0001 6.乱码问题解决了，但是如果内容全是英文，unicode编码比ASCII需要多一倍的存储空间，同时如果传输需要多一倍的传输。 7.所以出现了可变长的编程“utf-8”，把英文边长一个字节，汉字3个字节。特别生僻的变成4-6字节，如果传输大量的英文，utf8作用就很明显了 安装virtualenv步骤https://www.cnblogs.com/anpengapple/p/6430022.html 指定python版本的virtualenv环境 1mkvirtualenv -p python3 virtualtest1 scrapy爬取伯乐在线 123456789mkvirtualenv article_spiderpip install -i https://pypi.douban.com/simple/ scrapyworkon 查看所有虚拟环境workon article_spider 选取（切换）目标环境scrapy startproject ArticleSpider 新建scrapy项目然后去pcharm里打开这个项目 ArticleSpidercd ArticleSpiderscrapy genspider jobbole blog.jobbole.com 启动爬虫时 要将settings.py中的 ROBOTSTXT_OBEY = False 注释放开 xpath1.xpath简介 ①xpath使用路径表达式在xml和html中进行导航 ②xpath包含标准函数库 ③xpath是一个w3c的标准 xpath节点关系 父节点 子节点 同胞节点 先辈节点 后代节点 2.xpath术语 3.xpath语法 1234567891011121314151617181920212223242526272829303132article 选取所有article元素的所有子节点/articel 选取根节点articlearticle/a 选取所有属于article的子元素的a元素//div 选取所有div子元素（不论出现在文档任何地方）article//div选取所有属于article元素的后代的div元素，不管他出现在article之下的任何位置//@class 选取所有名为class的属性/article/div[1] 选取属于article子元素的第一个div元素/article/div[last()] 选取属于article子元素的最后一个div元素/article/div[last()-1] 选取属于article子元素的倒数第二个div元素//div[@lang] 选取所有拥有lang属性的div元素//div[@lang=&apos;eng&apos;] 选取所有lang属性为eng的div元素/div/* 选取属于div元素的所有子节点//* 选取所有元素//div[@*] 选取所有带属性的title元素/div/a | //div/p 选取所有div元素的a和p元素//span | //ul 选取文档中的span和ul元素article/div/p | //span选取所有属于article元素的div元素的p元素 以及文档中所有的span元素scrapy shell http://blog.jobbole.com/110287命令行对一个url进行调试 进入命令行模式后title = response.xpath(&quot;//div[@class=&apos;entry-header&apos;]/h1/text()&quot;)title#输出 [&lt;Selector xpath=&quot;//div[@class=&apos;entry-header&apos;]/h1/text()&quot; data=&apos;2016 腾讯软件开发面试题（部分）&apos;&gt;]title.extract()[&apos;2016 腾讯软件开发面试题（部分）&apos;]title.extract()[0]&apos;2016 腾讯软件开发面试题（部分）&apos;将日期里面的 . 和空格去掉date = response.xpath(xxxxxxxx.extract()[0].strip().replace(&quot; . &quot;,&quot; &quot;).strip()) css选择器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172* 选择所有节点#container 选择id为container的节点.container 选取所有class包含container的节点li a 选取所有li下的所有a节点ul+p 选取ul后面的第一个p元素div#container&gt;ul 选取id为container的div的第一个ul子元素 ul ~ p 选取与ul相邻的所有p元素a[title] 选取所有有title属性的a元素a[href=&quot;http://jobbole.com&quot;] 选取所有href属性为jobbole.com值得元素a[href*=&quot;jobbole&quot;] 选取所有href属性包含jobbole的a元素a[href^=&quot;http&quot;] 选取所有href属性值以http开头的a元素a[href$=&quot;.jpg&quot;] 选取所有href属性值以.jpg结尾的a元素input[type=radio]:checked 选择选中的radio的元素div:not(#container) 选取所有id非container的div属性li:nth-child(3) 选取第三个li元素tr:nth-child(2n) 第偶数个tr提取文本 ::textresponse.css(&quot;.entry-header h1::text&quot;).extract()scrapy shell blog.jobbole.com/all-posts/response.css(&quot;#archive .floated-thumb .post-thumb a::attr(href)&quot;).extract()Out[1]: [&apos;http://blog.jobbole.com/113771/&apos;, &apos;http://blog.jobbole.com/113768/&apos;, &apos;http://blog.jobbole.com/112048/&apos;, &apos;http://blog.jobbole.com/113760/&apos;, &apos;http://blog.jobbole.com/113740/&apos;, &apos;http://blog.jobbole.com/113631/&apos;, &apos;http://blog.jobbole.com/113737/&apos;, &apos;http://blog.jobbole.com/113735/&apos;, &apos;http://blog.jobbole.com/113707/&apos;, &apos;http://blog.jobbole.com/113728/&apos;, &apos;http://blog.jobbole.com/113722/&apos;, &apos;http://blog.jobbole.com/113726/&apos;, &apos;http://blog.jobbole.com/113719/&apos;, &apos;http://blog.jobbole.com/113716/&apos;, &apos;http://blog.jobbole.com/113710/&apos;, &apos;http://blog.jobbole.com/113713/&apos;, &apos;http://blog.jobbole.com/113705/&apos;, &apos;http://blog.jobbole.com/113699/&apos;, &apos;http://blog.jobbole.com/113696/&apos;, &apos;http://blog.jobbole.com/113692/&apos;]next_urls = response.css(&quot;.next.page-numbers&quot;)next_urls = response.css(&quot;.next .page-numbers&quot;)两个class next和page-numbers中如果没有空格说明是一个模块里的两个class属性 同级的如果有空格 说明是下级关系 &lt;div class=&quot;next page-numbers&quot;&gt;&lt;/div&gt;&lt;div class=&quot;next&quot;&gt;&lt;div class=&quot;page-numbers&quot;&gt;&lt;/div&gt;&lt;/div&gt;&quot;&quot;&quot;1. 获取文章列表页中的文章url并交给scrapy下载后并进行解析2. 获取下一页的url并交给scrapy进行下载， 下载完成后交给parse&quot;&quot;&quot;#解析列表页中的所有文章url并交给scrapy下载后并进行解析if response.status == 404: self.fail_urls.append(response.url) self.crawler.stats.inc_value(&quot;failed_url&quot;)post_nodes = response.css(&quot;#archive .floated-thumb .post-thumb a&quot;)for post_node in post_nodes: image_url = post_node.css(&quot;img::attr(src)&quot;).extract_first(&quot;&quot;) post_url = post_node.css(&quot;::attr(href)&quot;).extract_first(&quot;&quot;) yield Request(url=parse.urljoin(response.url, post_url), meta=&#123;&quot;front_image_url&quot;:image_url&#125;, callback=self.parse_detail)#提取下一页并交给scrapy进行下载next_url = response.css(&quot;.next.page-numbers::attr(href)&quot;).extract_first(&quot;&quot;)if next_url: yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse) scrapy的item类 item只有Filed一个类型 使用item与pipeline保存数据 在item中定义需要保存的内容，然后在pipeline处理item，爬虫流程就成了这样：抓取 –&gt; 按item规则收集需要数据 –&gt; 使用pipeline处理（存储等） 如果我们获取了图片的地址想保存图片怎么办？scrapy提供了图片自动下载机制 文件的打开和关闭：codecsimport codecs self.file = codes.open(&#39;article.json&#39;, &#39;w&#39;, encoding=&quot;utf-8&quot;) #w代表以写的方式打开 scrapy.exporters可以协助pipeline将item导出为各种格式例如导出jsonfrom scrapy.exporters import JsonItemExporter 与mysql的整合 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import MySQLdbclass MysqlPipeline(object):#采用同步的机制写入mysql def __init__(self): self.conn = MySQLdb.connect(&apos;host&apos;, &apos;user&apos;, &apos;password&apos;, &apos;dbname&apos;, charset=&quot;utf8&quot;, use_unicode=True) self.cursor = self.conn.cursor() #执行数据库 def process_item(self, item, spider): insert_sql = &quot;&quot;&quot; insert into jobbole_article(title, url, create_date, fav_nums) VALUES (%s, %s, %s, %s) &quot;&quot;&quot; self.cursor.execute(insert_sql, (item[&quot;title&quot;], item[&quot;url&quot;], item[&quot;create_date&quot;], item[&quot;fav_nums&quot;])) self.conn.commit()execute执行时会执行完再向下进行，造成阻塞可以种连接池来使数据库操作变成异步操作可以将mysql的配置信息写在setting中MYSQL_HOST = &quot;127.0.0.1&quot;MYSQL_DBNAME = &quot;article&quot;MYSQL_USER = &quot;root&quot;MYSQL_PASSWORD = &quot;1234&quot;然后在pipelines中通过@classmethod引入通过from twisted.enterprise import adbapi来调用twisted来异步from twisted.enterprise import adbapi import codecsimport MySQLdbimport MySQLdb.cursorsclass MysqlTwistedPipeline(object): def __init__(self, dbpool): self.dbpool = dbpool @classmethod def from_settings(cls, settings): dbparms = dict( host = settings[&quot;MYSQL_HOST&quot;], db = settings[&quot;MYSQL_DBNAME&quot;], user = settings[&quot;MYSQL_USER&quot;], passwd = settings[&quot;MYSQL_PASSWORD&quot;], charset = &quot;utf8&quot;, cursorclass = MySQLdb.cursors.DictCursor, use_unicode = True, ) dbpool = adbapi.ConnectionPool(&quot;MySQLdb&quot;, **dbparms) return cls(dbpool) def process_item(self, item, spidre): #使用twisted将mysql插入变成异步执行 query = self.dbpool.runInteraction(self.do_insert, item) query.addErrback(self.handle_error)#处理异常 def handle_error(self, failure):4 #处理异步插入的异常 print (failure) def do_insert(self, cursor, item): #执行具体的插入 insert_sql = &quot;&quot;&quot; insert into jobbole_article(title, url, url_object_id, create_date, fav_nums) VALUES (%s, %s, %s, %s, %s) &quot;&quot;&quot; cursor.execute(insert_sql,(item[&quot;title&quot;], item[&quot;url&quot;], item[&quot;url_object_id&quot;], item[&quot;create_date&quot;], item[&quot;fav_nums&quot;]))使用ItemLoader爬取数据from scrapy.loader import ItemLoader#通过item loader加载itemitem_loader = ItemLoader(item=JobbolenArticleItem(), response=response)item_loader.add_css(&quot;title&quot;, &quot;.entry-header h1::text&quot;)item_loader.add_css(&quot;create_date&quot;, &quot;p.entry-meta-hide-on-mobile::text&quot;)item_loader.add_css(&quot;praise_nums&quot;, &quot;.vote-post-up h10::text&quot;)item_loader.add_css(&quot;comment_nums&quot;, &quot;a[href=&apos;#article-comment&apos;] span::text&quot;)item_loader.add_css(&quot;fav_nums&quot;, &quot;.bookmark-btn::text&quot;)item_loader.add_css(&quot;tags&quot;, &quot;p.entry-meta-hide-on-mobile a::text&quot;)item_loader.add_css(&quot;content&quot;, &quot;div.entry&quot;)item_loader.add_value(&quot;url&quot;, response.url)item_loader.add_value(&quot;url_object_id&quot;, get_md5(response.url))item_loader.add_value(&quot;front_image_url&quot;, [front_image_url])article_item = item_loader.load_item()可以通过在 item中编写处理函数import scrapyimport datetimeimport refrom scrapy.loader.processors import MapCompose, TakeFirst, Joinfrom scrapy.loader import ItemLoaderclass ArticlespiderItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() passdef add_jobbole(value): return value+&quot;-bobby&quot;def date_convert(value): try: create_date = datetime.datetime.strptime(value, &quot;%Y/%m/%d&quot;).date() except Exception as e: create_date = datetime.datetime.now().date() return create_datedef get_nums(value): match_re = re.match(&quot;.*?(\d+).*&quot;, value) if match_re: nums = int(match_re.group(1)) else: nums = 0 return numsdef remove_commit_tags(value): #去掉tag中提取的评论 if &quot;评论&quot; in value: return &quot;&quot; else: return valuedef return_value(value): return valueclass ArticleItemLoader(ItemLoader): #自定义itemLoader default_output_processor = TakeFirst()class JobbolenArticleItem(scrapy.Item): title = scrapy.Field() create_date = scrapy.Field( input_processor = MapCompose(date_convert), #output_processor = TakeFirst() #只取第一个 ) url = scrapy.Field() url_object_id = scrapy.Field() front_image_url = scrapy.Field( output_processor = MapCompose(return_value) ) front_image_path = scrapy.Field() praise_nums = scrapy.Field( input_processor = MapCompose(get_nums), ) comment_nums = scrapy.Field( input_processor=MapCompose(get_nums), ) fav_nums = scrapy.Field( input_processor=MapCompose(get_nums) ) tags = scrapy.Field( input_processor=MapCompose(remove_commit_tags), output_processor=Join(&quot;,&quot;) ) content = scrapy.Field()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pip国内镜像源]]></title>
    <url>%2F2018%2F04%2F09%2Fpip%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%2F</url>
    <content type="text"><![CDATA[pip使用国内镜像 提升下载速度和安装成功率 国内源 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用： 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如： 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider 这样就会从清华这边的镜像去安装pyspider库]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析]]></title>
    <url>%2F2018%2F04%2F01%2Fpython%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.数据分析的含义与目标 统计分析方法 提取有用信息 研究、概括、总结 2.Python与数据分析 python：Guido van Rossum 1989圣诞假期 特点：简洁 开发效率高 运算速度慢 胶水特性 数据分析： numpy scipy matplotlib pandas scikit-learn keras…… 3.Python数据分析大家族 numpy：数据结构基础 scipy：强大的科学计算方法（矩阵分析、信号分析、数理分析……） matplotlib：丰富的可视化套件（可以做图表） pandas：基础数据分析套件 scikit-learn：强大的数据分析建模库 keras：人工神经网络 4.Python环境搭建 平台：Windows、Linux、MacOS 科学计算工具：Anaconda 一、numpy 关键词：开源 数据计算扩展 功能：ndarray 多维操作 线性代数 官网：http://www.numpy.org/ numpy是python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。numpy内部解除了python的PIL（全局解释器锁），运行效率极好，是大量机器学习框架的基础库！ https://www.jianshu.com/p/83c8ef18a1e8 二、matplotlib 关键词：绘图库 官网：http://matplotlib.org/ Matplotlib是Python 2D绘图领域的基础套件，它让使用者将数据图形化，并提供多样化的输出格式。 https://www.jianshu.com/p/f2782e741a75 三、scipy 关键词：数值计算库 官网：http://www.scipy.org/ 1.Integral 积分 2.Optimizer 优化器 3.Interpolation 插值 4.Linear 线性计算与矩阵分解 5.Others 四、pandas 关键词：数据分析库 官网：http://pandas.pydata.org/ Pandas是基于Numpy开发出的，专门用于数据分析的开源Python库 1.Series&amp;DataFram 基础数据结构 2.Basic&amp;Select&amp;Set 基本操作 3.Missing Data Processing 缺失值处理 4.Merge&amp;Reshape 表统计与整合 5.Time Series&amp;Graph&amp;Files 时间、绘图、文件操作 五、scikit-learn 关键词：数据挖掘建模 机器学习 官网：http://scikit-learn.org/ 机器学习：因子-&gt;结果 结果：不打标记-&gt;无监督学习（例如：聚类） 打标记-&gt;监督学习有限离散-&gt;分类 连续-&gt;回归 六、keras 关键词：人工神经网络 官网：https://keras.io/]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django入门]]></title>
    <url>%2F2018%2F03%2F11%2Fdjango%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[django初体验Django-python web开发框架目前最流行的Python Web开发框架 Django框架负责处理大部分web开发底层细节，我们可以专注于开发web应用，避免重复制造轮子 为什么使用Django 1.快速开发 用python开发 数据库ORM系统 2.大量内置应用 后台管理系统admin 用户认证系统auth 会话系统sessions 3.安全性高 表单验证 SQL注入 跨站点攻击 4.易于拓展 指定在python3中安装django python3 -m pip install django 安装django pip install django 新建django项目并启动 123django-admin startproject mysitecd mysitepython manage.py runserver 现在服务已经启动 可以去 127.0.0.1:8000查看了 工程目录详解 manage.py 管理项目：包括数据库建立、服务器运行、测试… mysite目录 settings.py 配置文件：应用、中间件、数据库、静态目录各类配置… urls.py URL映射配置文件：决定一个url访问被哪个程序（函数）响应 wsgi.py Python应用程序或框架和Web服务器之间接口 manage.py 可以自己指定端口 python manage.py runserver 0.0.0.0:8080 最常用的几个manage.py的命令1234runserver 启动服务器migrate、makemigrations 数据库相关的shell django中使用应用来分割功能 例如 游戏网站 -&gt; 分为四个应用：游戏新闻、游戏论坛、Blog系统、在线商城 创建应用 1.创建应用blog python manage.py startapp blog 2.添加blog应用 mysite/settings.py -&gt; INSTALLED_APPS 应用目录详解 views.py 相应客户请求返回html页面 models.py 定义数据库中的表 admin.py admin相关 test.py 测试相关 django概述一次web访问的实质 1.客户发送http请求到web服务器 2.web服务器返回html页面给客户 1.URL配置 建立URL和与响应函数之间的关系 2.视图Views 响应客户http请求，进行逻辑处理，返回给用户html页面 3.模型Models 描述我们服务器存储的数据（数据库的表） 4.模板templates 用来生产html页面，返回给用户的html，是由数据（模型）和模板渲染出来的。 django入门与实践什么是DjangoDjango是一个基于Python的高级WEB开发框架 它能够让开发人员进行高效且快速的开发 高度集成（不用自己造轮子），免费并且开源 浏览器浏览网页的基本原理本质是网络通信，即通过网络进行数据传递 浏览器经过通信后获取到该页面的源代码文档（HTML等） 浏览器解析文档后以适当的形式展现给用户 安装Django两种方式1pip install Django==1.10.2 下载源码，进入根目录执行python setup.py install 创建项目打开命令行，进入想要安置项目的目录命令行输入：django-admin startproject myblog若没有报错，则创建项目成功进入到项目中 cd myblog启动项目 python manage.py runserver指定端口 python manage.py runserver 9999 Templates介绍什么是Templates HTML文件 使用了Django模板语言（Django Template Language，DTL） 可以使用第三方模板（如Jinja2） 开发第一个Template步骤 在APP的根目录下创建名为Templates的目录 在该目录下创建HTML文件 在views.py中返回render() DTL初步使用 render()函数中支持一个dict（字典）类型函数 该字典是后台传递到模板的参数，键为参数名 在模板中使用来直接使用注意 Django查找Template Django按照INSTALLED_APPS中的添加顺序查找Templates 不同APP下Templates目录中的同名.html文件会造成冲突 解决Templates冲突方案 在APP的Templates目录下创建以APP名为名称的目录 将html文件放入新创建的目录下 Models介绍Django中的Models是什么？ 通常，一个Model对应数据库的一张数据表 Django中Models以类的形式表现 它包含了一些基本字段以及数据的一些行为 ORM 对象关系映射（Object Relation Mapping） 实现了对象和数据库之间的映射 隐藏了数据访问的细节，不需要编写SQL语句 编写Models 步骤 在应用根目录下创建models.py，并引入models模块（自动生成） 创建类，继承models.Model，该类即是一张数据表 在类中创建字段 字段创建 字段即类里面的属性（变量） attr = models.CharField(max_length=64) http://docs.djangoproject.com/en/1.10/ref/models/fields/ 生成数据表 步骤 命令行进入manage.py同级目录 执行python manage.py makemigretions app名（可选） 再执行python manage.py migrate 查看 Django会自动在app/migrations/目录下生成移植文件 执行python manage.py sqlmigrate 应用名 文件id 查看SQL语句 默认sqlite3的数据库在项目根目录下db.sqlite3 查看并编辑db.sqlite3 使用第三方软件 SQLite Export Personal 轻量级，完全免费 页面呈现数据 后台步骤 views.py中import models article = models.Article.objects.get(pk=1) render(request,page,{‘article’:article}) 前端步骤 模板可直接使用对象以及对象的 . 操作 Admin简介什么是Admin Admin是Django自带的一个功能强大的自动化数据管理界面 被授权的用户可直接在Admin中管理数据库 Django提供了许多针对Admin的定制功能 配置Admin 创建用户 python manage.py createsuperuser 创建超级用户 （zhangbin 752658686@qq.com zhangbin） localhost:8000/admin/ Admin入口 修改settings.py中LANGUAGE_CODE = ‘zh_Hans 配置应用 在应用下admin.py中引入自身的models模块（或里面的模型类） 编辑admin.py：admin.site.register(models.Article) 修改数据 点击Article超链接进入Article列表页面 点击任意一条数据，进入编辑页面修改 编辑页面下方一排按钮可执行相应操作 修改数据默认显示名称（在admin下的） 步骤 在Article类下添加一个方法 根据Python版本选择__str__(self)(python3)或__unicode_(self)(python2.7) return self.title 模板For循环 Django中的超链接超链接目标地址 1234567891011`href`后面是目标地址`Template`中可以用 `&#123;% url &apos;app_name: url_name&apos; param %&#125;`其中`app_name`和`url_name`都在`url`中配置使用`request.POST[&apos;参数名&apos;]`获取表单数据`models.Article.objects.create(title,content)`创建对象涉及`POST`方法提交表单的，前端页面加上`&#123;% csrf_token %&#125;` Templates过滤器什么是过滤器 写在模板中，属于Django模板语言 可以修改模板中的变量，从而显示不同的内容 怎么使用过滤器？ 123&#123;&#123; value | filter &#125;&#125;例子：&#123;&#123; list_nums | length &#125;&#125; 这样显示的就是长度而不是集合了过滤器可叠加：&#123;&#123; value | filter1 | filter2 | ... &#125;&#125; django访问不存在的对象时不会报错 只会传空 更多Django内建过滤器https://docs.djangoproject.com/en/1.10/ref/templates/builtins/#ref-templates-builtins-filters Django Shell什么是Django Shell？ 它是一个Python的交互式命令行程序 它自动引入了我们的项目环境 我们可以使用它与我们的项目进行交互 如何使用Django Shell？123python manage.py shellfrom blog.models import ArticleArticle.objects.all() 有什么用？ 我们可以使用Django shell来进行一些调试工作 测试未知的方法 Admin增强创建admin配置类 1234567classArticleAdmin(admin.ModelAdmin)注册：admin.site.register(Article,ArticleAdmin)显示其他字段list_display = (&apos;title&apos;,&apos;content&apos;)list_displaty同时支持tuple和list(tuple类型只有一个数据，别忘了加逗号)过滤器list_filter = (&apos;pub_time&apos;,) 这样就会有今天 过去七天 过去一个月 这些... 官方文档http://docs.djangoproject.com/en/1.10/ref/contrib/admin/]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面解析Java注解]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90Java%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[为什么学习注解？学习注解有什么好处？学完能做什么？ 能够读懂别人写的代码，特别是框架相关的代码 让编程更加简洁，代码更加清晰 让别人高看一眼… 概念：Java提供了一种原程序中的元素关联任何信息和任何元数据的途径和方法 JDK自带注解 @Override @Deprecated @Suppvisewarnings 常见第三方注解 Spring：@Autowired @Service @Respository Mybatis：@InsertProvider @UpdateProvider @Options 注解的分类 按照运行机制分： 源码注解：注解只在源码中存在，编译成.class就不存在了 编译时注解：注解在源码和.class文件中都存在（如jdk的三种注解） 运行时注解：在运行阶段还起作用，甚至会影响运行逻辑的注解（如@Autowired） 按照来源分： 来自JDK的注解 来自第三方的注解（大部分） 我们自己定义的注解 自定义注解 使用@interface关键字定义注解 成员以无参无异常方式声明 可以用default为成员指定一个默认值 成员类型是受限的，合法的类型包括原始类型及String，Class，Annotation，Enumeration 如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=） 注解类可以没有成员，没有成员的注解称为标识注解 元注解：（注解的注解） @Targer：注解的作用域 @Retention：生命周期 @Inherited：辨识性的元注解，标识允许子类（子注解）继承 @Documented：生成javadoc时会包含注解 解析注解： 概念：通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑 @Produces 表示类或者方法返回的MIME数据类型。 （1）@Produces(“text/plain”) 文本类型 （2）@Produces(“text/html”) Html类型 （3）@Produces({“application/xml”}) Xml类型 （4）@Produces({ “application/json”}) Json类型]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring事务管理]]></title>
    <url>%2F2018%2F02%2F02%2Fspring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是事务：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败.（银行转账） 事务的特性：原子性 一致性 隔离性 持久性 原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性：一致性指事务前后数据的完整性必须保持一致 隔离性：隔离性指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离 持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响 Spring事务管理高层抽象主要包括3个接口 PlatformTransactionManager：事务管理器 TransactionDefinition：事务定义信息（隔离、传播、超时、只读） TransactionStatus：事务具体运行状态 Spring为不同的持久化框架提供了不同PlatformTransactionManager接口实现 DataSourceTransactionManager：使用Spring JDBC或iBatis进行持久化数据时使用 HibernateTransactionManager：使用Hibernate3.0版本进行持久化数据时使用 Spring支持两种方式事务管理 编程式的事务管理:在实际应用中很少使用,通过TransactionTemplate手动管理事务 通过XML配置声明式事务:开发中推荐使用（代码侵入性最小） Spring的声明式事务是通过AOP实现的 编程式的事务管理：配置文件编写： 12345678&lt;!-- 配置事务管理器 --&gt;&lt;bean id = &quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionmanager&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置事务管理的模板：Spring为了简化事务管理的代码而提供的类 --&gt;&lt;bean id = &quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name = &quot;transactionManager&quot; ref = &quot;transactionManager&quot;/&gt;&lt;/bean&gt; 代码文件编写： 12345678910public void transfer(final String out, final String in, final Double money)&#123; transactionTemplate.execute(new TransactionCallbackWithoutResult)&#123; @override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus)&#123; accountDao.outMoney(out, money); int i = i/0;//用于异常时检测事务完整性 accountDao.inMoney(in, money); &#125; &#125;&#125; 声明式的事务管理：声明式事务管理方式一：TransactionProxyFactoryBean （不常用） 123456789101112131415161718192021222324&lt;!-- 配置事务管理器： --&gt;&lt;bean id = &quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionmanager&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 配置业务层的代理： --&gt;&lt;bean id = &quot;acountServiceProxy&quot; class = &quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; &lt;!-- 配置目标对象 --&gt; &lt;property name = &quot;target&quot; ref = &quot;accountService&quot;/&gt; &lt;!-- 注入事务管理器 --&gt; &lt;property name = &quot;transactionManager&quot; ref = &quot;transactionManager&quot;/&gt; &lt;!-- 注入事务属性 --&gt; &lt;property name = &quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;!-- prop的格式： * PROPAGATION ： 事务的传播行为 * ISOLATION ： 事务的隔离级别 * readOnly ： 只读（不可以进行修改，插入，删除） * -Exception ： 发生哪些异常回滚事务 * +Exception： 发生哪些异常不回滚 --&gt; &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,redaOnly,...&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 声明式事务管理方式二：基于AspectJ使用xml方式 基于tx/aop 123456789101112&lt;bean id = &quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionmanager&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;tx:advice id = &quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* cn.service.*Service.*(..))&quot; id=&quot;serviceMethod&quot;/&gt; &lt;aop:advisor pointcut-ref=&quot;serviceMethod&quot; advice-ref=&quot;txAdvice&quot;/&gt;&lt;/aop:config&gt; 声明式事务管理方式三：基于注解的事务管理 配置文件编写： 1234567&lt;!-- 配置事务管理器 --&gt;&lt;bean id = &quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionmanager&quot;&gt; &lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!-- 开启注解事务 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;使用的时候在需要事务的地方（通常是service层）加注解@Transactional]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring基础]]></title>
    <url>%2F2018%2F01%2F29%2Fspring%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Spring：轻量级的控制反转（IOC）和面向切面（AOP）的容器框架. -从大小与开销两方面而言Spring都是轻量的 -通过控制反转（IOC）的技术达到松耦合的目的 -提供了面向切面的编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 -包含并管理应用对象的配置和生命周期，这个意义上是一种容器 -将简单的组件配置、组合成为复杂的应用，这个意义上是框架 IOC：控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护 DI（依赖注入）是其一种实现方式 目的：创建对象并且组装对象之间的关系 控制被反转后，获得依赖对象的过程由自身管理变成了由IOC容器主动注入。 注入方式： 设值注入 （set） 构造注入 bean的作用域： singleton：单例，指一个Bean容器中只存在一份 prototype：每次请求（每次使用）创建新的实例，destory方式不生效 request：每次http请求创建一个实例且仅在当前request内有效 session：同上，每次http请求创建，当前session内有效 global session：基于portlet的web中有效，如果是在web中，同session bean的自动装配（Autowiring） No：不做任何操作 byname：根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配 byType：如果容器中存在一个与指定属性类型相同的bean，那么将于该属性自动装配；如果存在过个该类型bean，那么抛出异常，并指出不能使用byType方式进行自动装配；如果没有找到相匹配的bean，则什么事都不发生 Constructor：与byType方式类似，不同之处在于它应用于构造器参数。如果容器中没有找到与构造器参数类型一致的bean，那么抛出异常 注解： @configuration是一个通用注解，可用于任何bean @Repository，@Service，@Controller是更有针对性的注解 @Repository通常用于注解Dao类，即持久层 @Service通常用于注解Service类，即服务层 @Controller通常用于Controller类，即控制层（MVC） 通常情况下自动查找的Spring组件，其scope是singleton，可以设置： 123@scope(&quot;prototype&quot;)@Repositorypublic class stuDao imp......... @Required注解适用于bean属性的setter方法（不常用） 这个注解仅仅表示，受影响的bean属性必须在配置时被填充，通过在bean定义或通过自动装配一个明确的属性值 @Autowired：“传统”的setter方法。这种自动注入，既可以用在setter方法上，也可以用在成员变量和构造器上。用在成员变量的话那么就不需要定义setter方法了。 默认情况下，如果因找不到合适的bean将会导致autowired失败抛出异常，可以通过下面的方式避免 1234567private class UserService&#123; private UserDao userDao; @Autowired(required=false) public void setUserDao(UserDao userDao)&#123; this.userDao = userDao; &#125;&#125; 在使用Spring框架中@Autowired标签时默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。Spring 允许我们通过 @Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了，可以通过下面的方法解决异常。 @Qualifier(“XXX”) 中的 XX是 Bean 的名称，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。@Autowired 可以对成员变量、方法以及构造函数进行注释，而 @Qualifier 的标注对象是成员变量、方法入参、构造函数入参 基于java的容器注解@Bean标识一个用于配置和初始化一个由SpringIoC容器管理的新对象的方法，类似于XML配置文件的&lt;bean/&gt; 可以在Spring的@Component注解的类中使用@Bean注解任何方法（仅仅是可以） 上一点中，通常使用的是@Configuration. @Bean中可以有可选项name，initMethod，destoryMethod等 1234567@Configurationpublic class StoreConfig&#123; @Bean(name = &quot;store&quot;,initMethod = &quot;&quot;,destoryMethod = &quot;&quot;) public Store stringStore()&#123; return new StringStore(); &#125;&#125; 在applicationContext.xml中配置数据库文件： 1234567891011121314&lt;!-- 引入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置C3P0连接池: --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt;@Resource(name = &quot;&quot;)public void setStudent(Student student)&#123; this.student = student;&#125; 如果没有显式的指定@Resource的name，默认的名称是从属性名或者setter方法得出. AOP：Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 主要的功能是： 日志记录 性能统计 安全控制 事务处理 异常处理等等 AOP实现方式 预编译：AspectJ 运行期动态代理（JDK动态代理、CGLib动态代理）：SpringAOP、JbossAOP AOP几个相关概念： 切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象 连接点（Joinpoint）：程序执行过程中的某个特定的点 通知（Advice）：在切面的某个特定的连接点上执行的动作 切入点（Pointcut）：匹配连接点的断言，在AOP中通知和一个切入点表达式关联 引入（Introduction）：在不修改类代码的前提下，为类添加新的方法和属性 目标对象（Target Object）：被一个或者多个切面所通知的对象 AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能） 织入（Weaving）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象，分为：编译时织入、类加载时织入、执行时织入 Advice的类型： 前置通知（Before Advice）：在某连接点（join point）之前执行的通知，但不能阻止连接点前的执行（除非他抛出一个异常） 返回后通知（After returning advice）：在某连接点（join point）正常完成后执行的通知 抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知 后通知（After（finally）advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常返回） 环绕通知（Around Advice）：包围一个连接点（join point）的通知 123456&lt;aop:config&gt; &lt;aop:aspect id=&quot;testAspectAOP&quot; ref=&quot;testAspect&quot;&gt; &lt;aop:pointcut id=&quot;testService&quot; expression=&quot;execution(* com.service..(..))&quot; id=&quot;p1&quot;/&gt; &lt;aop:before method=&quot;before&quot; point-ref=&quot;p1&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Spring的AOP实现纯java实现，无需特殊的编译过程，不需要控制类加载器层次 目前只支持方法执行连接点（通知Spring Bean的方法执行） 不是为了提供最完整的AOP实现；而是侧重于提供一种AOP实现和Spring IoC容器之间的整合，用于帮助解决企业应用中的常见问题 Schema——based AOPSpring所有的切面和通知器都必须放在一个&lt;aop:config&gt;内（可以配置包含多个&lt;aop:config&gt;元素），每一个&lt;aop:config&gt;可以包含pointcut，advisor和aspect元素（他们必须按照这个顺序进行声明） &lt;aop:config&gt;风格的配置大量使用了Spring的自动代理机制 配置切面aspect 1234567&lt;bean id=&quot;testAspect&quot; class=&quot;com.imooc.aop.schema.advice.TestAspect&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;aop:aspect id=&quot;testAspectAOP&quot; ref=&quot;testAspect&quot;&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 切入点（pointcut） 12345678910execution(public * *(..))：切入点为执行所有public方法时execution(* set*(..))：切入点为执行所有set开始的方法时execution(* com.service.AccountService.*(..))：切入点为执行AccountService类中的所有方法时execution(* com.service..(..))：切入点为执行com.service包下的所有方法时execution(* com.service...(..))：切入点为执行com.service包及其子包下的所有方法时&lt;aop:config&gt; &lt;aop:aspect id=&quot;testAspectAOP&quot; ref=&quot;testAspect&quot;&gt; &lt;aop:pointcut id=&quot;testService&quot; expression=&quot;execution(* com.service..(..))&quot; id=&quot;p1&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Introductions简介允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代替这些对象 由&lt;aop:aspect&gt;中的&lt;aop:declare-parents&gt;元素声明该元素用于声明所匹配的类型拥有一个新的parent advisor就像一个小的自包含的方面，只有一个advice 切面自身通过一个bean表示，而且必须实现某个advice接口，同时，advisor也可以很好的利用AspectJ的切入点表达式]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程之内存可见性]]></title>
    <url>%2F2018%2F01%2F04%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[可见性可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量 Java内存模型（JMM）Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。 所有的变量都存储在主内存中。 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本。（主内存中该变量的一份拷贝） 两条规定 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 要实现共享变量的可见性，必须保证两点： 线程修改后的共享变量值能够及时从工作内存刷新到主内存中。 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中 Java语言层次支持的可见性实现方式：12 synchronized volatile synchronized能够实现： 原子性（同步） 可见性 JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中。 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁和解锁需要是同一把锁） 线程解锁前对共享变量的修改在下次加锁时对其他线程可见 重排序重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化 1.编译器优化的重排序（编译器优化） 2.指令级并行重排序（处理器优化） 3.内存系统的重排序（处理器优化） as-if-serial：无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义） 可见性分析导致共享变量在线程间不可见的原因： synchronized解决方案 1.线程的交叉执行 ——&gt; 原子性 2.重排序结合线程交叉执行 ——&gt; 原子性 3.共享变量更新后的值没有在工作内存与主内存间及时更新 ——&gt; 可见性 volatile实现可见性volatile如何实现内存可见性： 深入来说：通过加入内存屏障和禁止重排序优化来实现的。 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令。 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令。 volatile如何实现内存可见性：通俗的讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。 线程写volatile变量的过程： 1.改变线程工作内存中volatile变量副本的值。 2.将改变后的副本的值从工作内存刷新到主内存。 线程读volatile变量的过程： 1.从主内存中读取volatile变量的最新值到线程的工作内存中。 2.从工作内存中读取volatile变量的副本。 volatile不能保证volatile变量复合操作的原子性 在多进程（线程）的操作系统中不能被其它进程（线程）打断的操作就叫原子操作，文件的原子操作是指操作文件时的不能被打断的操作。原子操作是不可分割的，在执行过程中不会被任何其它任务或事件中断。 回滚就是回到事务开始之前的状态 我们把这种要么一起成功（A帐户成功减少1000，同时B帐户成功增加1000），要么一起失败（A帐户回到原来状态，B帐户也回到原来状态）的操作叫原子性操作。 如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。这种特性就叫原子性]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql存储过程]]></title>
    <url>%2F2017%2F12%2F13%2Fmysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[存储过程存储过程是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理。 存储过程的优点 增强SQL语句的功能和灵活性 实现较快的执行速度 减少网络流量 IN：表示该参数的值必须在调用存储过程时指定 OUT：表示该参数的值可以被存储过程改变，并且可以返回。 INOUT：表示该参数的调用时指定，并且可以被改变和返回。 存储引擎MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就成为存储引擎。 每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。 并发控制当多个连接对记录进行修改时保证数据的一致性和完整性。 事物 外键：是保证数据一致性的策略。 索引：是对数据表中一列或多列的值进行排序的一种结构。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令行]]></title>
    <url>%2F2017%2F12%2F05%2Flinux%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[查询目录中内容：ls 123456ls [选项] [文件或目录] -a 显示所有的文件，包括隐藏文件 -l 显示详细信息 ls -l 等同于 ll -d 查看目录属性 -h 人性化显示文件大小 -i 显示inode -rw-r–r– 123- （最前面的-）文件类型（-文件 d 目录 l 软链接文件） rw- r-- r-- u所有者 g所属组 o其他人 普通用户切换到root 1su root 创建文件夹 mkdir 创建级联的 mkdir -p 切换所在目录：cd(change directory) cd/cd ~ 进入当前用户的家目录 cd - 进入上次目录 cd .. 进入上一级目录 cd . 进入当前目录 cd / 根目录下 pwd 当前所处的目录,显示整个路径名 rmdir： remove empty directories删除空目录 （用的少） rm：删除 rm -rf （r：目录 f：强制） 复制命令：cp 1234-r 复制目录 -p连带文件属性复制-d 若源文件是链接文件，则复制链接属性 -a 相当于 -pdr 复制的文件和原文件将完全一样 包括创建时间等 剪切或改名：mv / 根目录 /bin 存放必要的命令 /boot 存放内核以及启动所需的文件等 /dev 存放设备文件 /etc 存放系统的配置文件 /home 用户文件的主目录，用户数据存放在其主目录中 /lib 存放必要的运行库 /mnt 存放临时的映射文件系统，我们常把软驱和光驱挂装在这里的floppy和cdrom子目录下。 /proc 存放存储进程和系统信息 /root 超级用户的主目录 /sbin 存放系统管理程序 /tmp 存放临时文件的目录 /usr 包含了一般不需要修改的应用程序，命令程序文件、程序库、手册和其它文档。 /var 包含系统产生的经常变化的文件 链接命令：ln 123ln -s [原文件] [目标文件] （link）功能描述：生成链接文件 选项：-s 创建软链接 硬链接特征： 1.拥有相同的i节点和存储block块，可以看做是同一个文件 2.可通过i节点识别 3.不能跨分区 4.不能针对目录使用 软链接特征： 1.类似Windows快捷方式 2.软链接拥有自己的I节点和Block块，但是数据块中只保存原文件的文件名和I节点号，并没有实际的文件数据 3.Irwxrwxrwx I软链接 软链接文件权限都为rwxrwxrwx 4.修改任意文件，另一个都改变 5.删除原文件，软链接不能使用 原文件删除软链接失效，不影响硬链接的使用 文件搜索命令：locate（快） find（慢） locate 文件名 在后台数据库中按文件名搜索 find [搜索范围] [搜索条件] find / -name install.log /(全路径) -name（条件） grep：搜索字符串命令 grep [选项] 字符串 文件名 -i（忽略大小写）-v（排除指定字符串） whereis : 搜索命令的命令 搜索命令所在路径及帮助文档所在位置 选项：-b （只查找可执行文件） -m：（只查找帮助文件） 通配符 * ? [] find命令和grep命令的区别 find命令：在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配 grep命令：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配，正则表达式是包含匹配 帮助命令man man（manual的缩写）命令：获取指定命令的帮助 例：man ls 查看命令拥有哪个级别的帮助：man -if 相当于 whatis 查看和命令相关的所有帮助：man -k 相当于 apropos linux中常用的压缩格式：.zip .gz .bz2 .tar.gz .tar.bz2 .zip格式压缩 123zip 压缩文件名 源文件zip -r 压缩文件名 源文件（压缩目录）unzip 解压缩 .gz 格式压缩 12345gzip 源文件 ： 压缩为.gz格式的压缩文件，源文件会消失gzip -c 源文件 &gt; 压缩文件 ： 压缩为.gz 格式，源文件保留 例：gzip -c cangls &gt; cangls.gzgzip -r 目录：压缩目录下所有的子文件，但是不能压缩目录gzip -d 压缩文件 ： 解压缩gunzip 压缩文件 ：解压缩文件（解压缩目录也要加 -r） .bz2格式解压缩 12345bzip2 -d 压缩文件bunzip2 压缩文件：解压缩 -k 保留压缩文件.tar.gz .tar.bz2 : 先打包再压缩打包命令：tar -cvf 打包文件名 源文件选项：-c：打包 -v：显示过程 -f：指定打包后的文件名 例：tar -cvf longzls.tar longzls 解打包： tar -xvf 打包文件名 x：解打包 12345678.tar.gz 压缩格式其实.tar.gz格式是先打包为.tar格式，再压缩为.gz格式tar -zcvf 压缩包名.tar.gz 源文件 -z：压缩为.tar.gz格式tar -zxvf 压缩包名.tar.gz -c 解压缩路径 -x：解压缩.tar.gz格式 -c：指定解压缩路径例：tar -zcvf /temp/country.tar.gz japan china tar -ztvf test.tar.gz：只查看不解压 shutdown [选项] [时间] 123选项：-c：取消前一个关机命令 -h：关机 -r：重启 其他关机命令：halt poweroff init 0 其他重启命令：reboot init 6]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础知识整理]]></title>
    <url>%2F2017%2F12%2F02%2Fmysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[约束：按功能划分： NOT NULL, RPIMARY KEY, UNIQUE KEY, DEFAULT，FOREIGN KEY 按数据列的数目划分： 表级约束&amp;列级约束 外键约束： 外键约束的要求： 1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表 2.数据表的存储引擎只能为InnoDB 3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度可以不同。 4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。 外键约束的参照操作： 1.CASCADE:从父表删除或更新且自动删除或更新子表中匹配的行 2.SET NULL:从父表删除或更新行，并设置子表中的外键列为NULL.如果使用该选项，必须保证子表列没有指定NOT NULL. 3.RESTRICT:拒绝对父表的删除或更新操作。 4.NO ACTION:标准SQL的关键字，在MySQL中与RESTRICT相同。 表级约束与列级约束 对一个数据列建立的约束，称为列级约束。 对多个数据列建立的约束，称为表级约束。 列级约束既可以在列声明时声明，也可以在列定以后声明。 表级约束只能在列定义后声明。 修改数据表添加单列 1ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST | AFTER col_name] 添加多列 1ALTER TABLE tbl_name ADD[COLUMN] (col_name column_defination,........) 删除列 12ALTER TABLE tbl_name DROP [COLUMN] col_nameALTER TABLE user DROP password，DROP username 添加唯一约束 1ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY] [index_name] [index_type] (index_col_name,.....) index_name : 索引名字 （显示数据表中索引名字：SHOW INDEXS FROM tbl_name） 添加外键约束 1ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name,....) reference_definition 1例：ALTER TABLE user2 ADD FOREIGN KEY (pid) REFERENCE provinces (id) 删除主键约束 1ALTER TABLE tbl_name DROP PRIMARY KEY 删除唯一约束 123ALTER TABLE tbl_name DROP &#123;INDEX | KEY&#125; index_name例：ALTER TABLE user DROP INDEX username(注意是删除username上的唯一约束，而不是删除掉这个字段) 删除外键约束 1ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol 修改列定义 12ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]例：ALTER TABLE user MODIFY id SMALLINT UNSIGNED NOT NULL FIRST 修改列名称 1ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name] 数据表更名方法一：12ALTER TABLE tbl_name RENAME [TO | AS] new_tbl_name 例：ALTER TABLE user2 RENAME user3 方法二：1RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_name2] ..... 插入记录 INSERT 12INSERT [INTO] tbl_name [(col_name)] &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,.......),&#123;......&#125;,......例：INSERT users VALUES (NULL，&quot;tom&quot;，&quot;456&quot;，25，1) 1INSERT [INTO] tbl_name SET col_name = &#123;expr | DEFAULT&#125;,...... 说明：与第一种方式的区别在于，此方法可以使用子查询（SubQuery） 1INSERT [INTO] tbl_name [(col_name,.....)] SELECT ..... 说明：此方法可以将查询结果插入到指定数据表 更新记录（单表更新）UPDATE 12UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = &#123;expr | DEFAULT&#125; [, col_name2 = &#123;expr2 | DEFAULT&#125;]..... [WHERE where_condition] 若不加where条件 ， 表示修改所有的表中记录 DELETE 删除记录（单表删除） 1DELETE FROM tbl_name [WHERE where_condition] SELECT 查找记录 1SELECT select_expr [, select_expr ... ][FROM table_references][WHERE where_condition][GROUP BY &#123;col_name | position&#125; [ASC | DESC], ..... ][HAVING where_condition][ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC],..... [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125; ] 查询表达式 每一个表达式表示想要的一列，必须有至少一个多个列之间以英文逗号分隔星号（*）表示所有列。tbl_name.* 可以表示命名表的所有列。 查询表达式可以使用 [ AS ] alias_name 为其赋予别名。 别名可用于GROUP BY，ORDER BY 或 HAVING 字句。 12例：SELECT username, id FROM usersSELECT users.username, users.id FROM users(使用多表连接时使用) WHERE 条件表达式对记录进行过滤，如果没有指定WHERE字句，则显示所有记录。 在WHERE表达式中，可以使用MySQL支持的函数或运算符。 GROUP BY查询结果分组 123[GROUP BY &#123;col_name | position&#125; [ASC | DESC （升序降序） ],...... ] HAVING 对分组条件进行指定例：SELECT sex FROM users GROUP BY sex;SELECT sex, age FROM users GROUP BY sex HAVING age &gt; 35 ; ORDER BY对查询结果进行排序 12[ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC],...... ]按id降序排列：SELECT * FROM users ORDER BY id DESC; LIMIT限制查询结果返回的数量 123[LIMIT &#123;[offset,] row_count | row_count OFFSET offset &#125;] 例：SELECT * FROM users LIMIT 2; （返回前两条记录）SELECT * FROM users LIMIT 2,2; （返回第三四条记录） 子查询 子查询（Subquery）是指出现在其他SQL语句内的SELECT子句。 123例如：SELECT * FROM t1 WHERE col1 = ( SELECT col2 FROM t2 );其中SELECT * FROM t1 , 称为Outer Query / Outer StatementSELECT col2 FROM t2 , 称为SubQuery 子查询指嵌套在查询内部，且必须始终出现在圆括号内。 子查询可以包含多个关键字或条件，如DISTINCT, GROUP BY , ORDER BY, LIMIT, 函数等。 子查询的外层查询可以是：SELECT , INSERT , UPDATE , SET 或 DO。 子查询可以返回标量、一行、一列或子查询。 子查询条件关键字：ANY SOME ALL 使用[ NOT ] IN 的子查询 使用[ NOT ] EXISTS 的子查询 INSERT …. SELECT 将查询结果写入到数据表. 1INSERT [INTO] tbl_name [(col_name,...)] SELECT ... 多表更新 1UPDATE table_references SET col_name1 = &#123;expr | DEFAULT&#125;[, col_name = &#123;expr | DEFAULT&#125;]...[WHERE where_condition] CREATE … SELECT 创建数据表同时将查询结果写入到数据表 1CREATE TABLE [IF NOT EXISTS] tbl_name [(create_definition,....)]select_statement 连接 MySQL在SELECT语句，多表更新，多表删除语句中支持JOIN操作。 连接条件 使用ON关键字来设定连接条件，也可以使用WHERE来代替。 通常使用ON关键字来设定连接条件。 使用WHERE关键字进行结果集记录的过滤。 1、内连接：在MySQL中JOIN,INNER JOIN,CROSS JOIN是等价的 2、外连接：LEFT JOIN左外连接；RIGHT JOIN右外连接 3、连接条件：使用ON设定连接条件，也可以用WHERE代替(ON：设定连接条件;WHERE：进行结果集记录的过滤) 4：内连接是返回左表及右表符合连接条件的记录 5、例如：SELECT * FROM tabA JOIN tabB ON tabA.name = tabB.name;表示返回都含有的name值对应的字段 外连接 1A LEFT JOIN B join_condition 数据表B的结果集依赖数据表A 数据表A的结果集根据左连接条件依赖所有数据表（B表除外） 左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下） 如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。 如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE字句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行。 自身连接 同一个数据表对其自身进行连接。 1例：SELECT s.type_id , s.type_name , p.type_id FROM tdb_goods AS s LEFT JOIN tdb_goods AS p; 多表删除 123DELETE tbl_name [.*] [, tbl_name[.*]]... FROM table_references[WHERE where_condition]DELETE t1 FROM tdb_goods AS t1 LEFT JOIN (SELECT goods_id, goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;=2 ) AS t2 ONt1.goods_name = t2.goods_name WHERE t1.goods_id &gt; t2.goods_id; 子查询: 出现在sql语句中的select子句，而子查询必须要出现在小括号()内，他的外层可以是select语句，insert语句，update语句，delete语句，而且在子查询中可以包含多个关键词:group by ，order by ，limit以及相关函数。引发子查询的情况有比较运算符 ，in(NOT)in运算符,exist(NOT EXIST)引发的子查询. 连接: 连接分为外连接和内连接，内连接主要显示的是左表和右表当中都符合连接条件的记录。外链接有分为左外连接和右外连接，左外连接显示的是左表中的全部记录和右表符合条件的记录，右外连接和左外连接相反，mysql中的select，多表更新和删除都可以用到内连接，左，右连接。 函数 查询api吧。。。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea常用快捷键]]></title>
    <url>%2F2017%2F11%2F24%2FIdea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IntelliJ Idea 常用快捷键列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+”+/-”，当前方法展开、折叠Ctrl+Shift+”+/-”，全部展开、折叠【调试部分、编译】Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器【重构】Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联【查找】Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery基础]]></title>
    <url>%2F2017%2F11%2F10%2Fjquery%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[在jQuery中 $() 方法等价于 jQuery() 方法，前者比较常用，是后者的简写。一般只有在$() 与其他语言冲突时才会使用jQuery() 方法。 #id 选择器 jquery能使用CSS选择器来操作网页中的标签元素。如果你想要通过一个id号去查找一个元素，就可以使用如下格式的选择器： 12$(&quot;#my_id&quot;)其中#my_id表示根据id选择器获取页面中指定的标签元素，且返回唯一一个元素。 element 选择器 12$(“element”)其中element就是元素的名称 例如：$(&quot;div&quot;) .class 选择器 12$(“.class”)其中.class参数表示元素的CSS类别(类选择器)名称。 * 选择器 $(“*”)选择器中的参数就一个“”，既没有“#”号，也没有“.”号。 由于该选择器的特殊性，它常与其他元素组合使用，表示获取其他元素中的全部子元素。`$(“form “).attr(“disabled”, “true”)`; sele1,sele2,seleN选择器 $(“sele1,sele2,seleN”)其中参数sele1、sele2到seleN为有效选择器，每个选择器之间用“，”号隔开，它们可以是之前提及的各种类型选择器，如$(“#id”)、$(“.class”)、$(“selector”)选择器等。$(&quot;.red,.green&quot;).html(&quot;hi,我们的样子很美哦!&quot;); ance desc选择器 1$(&quot;ance desc&quot;) 其中ance desc是使用空格隔开的两个参数。ance参数（ancestor祖先的简写）表示父元素；desc参数（descendant后代的简写）表示后代元素，即包括子元素、孙元素等等。两个参数都可以通过选择器来获取。比如家族姓氏“div”，家族几代人里，都有名字里带“span”的，就可以用这个ance desc选择器把这几个人给定位出来。 parent &gt; child选择器 与上一节介绍的ance desc选择器相比，parent &gt; child选择器的范围要小些，它所选择的目标是子集元素，相当于一个家庭中的子辈们，但不包括孙辈，它的调用格式如下： 12$(“parent &gt; child”)child参数获取的元素都是parent选择器的子元素，它们之间通过“&gt;”符号来表示一种层次关系。 prev + next选择器 俗话说“远亲不如近邻”，而通过prev + next选择器就可以查找与“prev”元素紧邻的下一个“next”元素，格式如下： 1$(“prev + next”) 其中参数prev为任何有效的选择器，参数“next”为另外一个有效选择器，它们之间的“+”表示一种上下的层次关系，也就是说，“prev”元素最紧邻的下一个元素由“next”选择器返回的并且只返回唯的一个元素。 prev ~ siblings选择器 与上一节中介绍的prev + next层次选择器相同，prev ~ siblings选择器也是查找prev 元素之后的相邻元素，但前者只获取第一个相邻的元素，而后者则获取prev 元素后面全部相邻的元素，它的调用格式如下： 1$(“prev ~ siblings”) 其中参数prev与siblings两者之间通过“~”符号形成一种层次相邻的关系，表明siblings选择器获取的元素都是prev元素之后的同辈元素。 :first过滤选择器 123456789101112$(“li:first”) $(&quot;li:last&quot;) &lt;ol&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;/ol&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li:last&quot;).css(&quot;background-color&quot;, &quot;red&quot;); &lt;/script&gt; :eq(index)过滤选择器 如果想从一组标签元素数组中，灵活选择任意的一个标签元素，我们可以使用 1:eq(index) 其中参数index表示索引号（即：一个整数），它从0开始，如果index的值为3，表示选择的是第4个元素 :contains(text)过滤选择器 有时候我们可能希望按照文本内容来查找一个或多个元素，那么使用:contains(text)选择器会更加方便， 它的功能是选择包含指定字符串的全部元素，它通常与其他元素结合使用，获取包含text字符串内容的全部元素对象。其中参数text表示页面中的文字。 :has(selector)过滤选择器 还可以使用包含的元素名称来过滤，:has(selector)过滤选择器的功能是获取选择器中包含指定元素名称的全部元素，其中selector参数就是包含的元素名称，是被包含元素。 例如：获取指定包含某个元素名的全部元素，并改变它们显示文字的颜色，如下图所示： :hidden过滤选择器 :hidden过滤选择器的功能是获取全部不可见的元素，这些不可见的元素中包括type属性值为hidden的元素。 例如，调用:hidden选择器获取不可见的&lt;p&gt;元素，并将该元素的内容显示在&lt;div&gt;元素中，如下图所示： :visible过滤选择器 与上一节的:hidden过滤选择器相反，:visible过滤选择器获取的是全部可见的元素，也就是说，只要不将元素的display属性值设置为none，那么，都可以通过该选择器获取。 [attribute=value]属性选择器 属性作为DOM元素的一个重要特征，也可以用于选择器中，从本节开始将介绍通过元素属性获取元素的选择器，[attribute=value]属性选择器的功能是获取与属性名和属性值完全相同的全部元素，其中[]是专用于属性选择器的括号符，参数attribute表示属性名称，value参数表示属性值。 例如，使用[attribute=value]属性选择器，获取指定属性名和对应值的全部&lt;li&gt;元素，并设置它们显示的文字颜色，如图所示： [attribute!=value]属性选择器 $(&quot;li[title!=&#39;我最爱&#39;]&quot;) &lt;— 上面改成 [attribute*=value]属性选择器 介绍一个功能更为强大的属性选择器[attribute*=value]，它可以获取属性值中包含指定内容的全部元素，其中[]是专用于属性选择器的括号符，参数attribute表示属性名称，value参数表示对应的属性值。 例如，使用[attribute*=value]属性选择器，获取属性值中包含某一指定内容的全部&lt;li&gt;元素，并设置它们显示的文字颜色，如下图所示： :first-child子元素过滤选择器 通过上面章节的学习，我们知道使用:first过滤选择器可以获取指定父元素中的首个子元素，但该选择器返回的只有一个元素，并不是一个集合，而使用:first-child子元素过滤选择器则可以获取每个父元素中返回的首个子元素，它是一个集合，常用多个集合数据的选择处理。 如下图，如果想把页面中每个ul中的第一个li获取到，并改变其颜色。则可以使用: first-child :input表单选择器 如何获取表单全部元素？:input表单选择器可以实现，它的功能是返回全部的表单元素，不仅包括所有&lt;input&gt;标记的表单元素，而且还包括&lt;textarea&gt;、&lt;select&gt; 和 &lt;button&gt;标记的表单元素，因此，它选择的表单元素是最广的。 1$(&quot;#frmTest :input&quot;).addClass(&quot;bg_blue&quot;); :text表单文本选择器 :text表单文本选择器可以获取表单中全部单行的文本输入框元素，单行的文本输入框就像一个不换行的字条工具，使用非常广泛。 通过:text表单选择器只获取单行的文本输入框元素，对于&lt;textarea&gt;区域文本、按钮元素无效. :password表单密码选择器 :radio单选按钮选择器 :checkbox复选框选择器 :submit提交按钮选择器 :image图像域选择器 当一个&lt;input&gt;元素的type属性值设为image时，该元素就是一个图像域，使用:image选择器可以快速获取该类全部元素。 :button表单按钮选择器 :checked选中状态选择器 有一些元素存在选中状态，如复选框、单选按钮元素，选中时checked属性值为checked，调用:checked可以获取处于选中状态的全部元素 :selected选中状态选择器 与:checked选择器相比，:selected选择器只能获取&lt;select&gt;下拉列表框中全部处于选中状态的&lt;option&gt;选项元素。 使用attr()方法控制元素的属性 attr()方法的作用是设置或者返回元素的属性，其中attr(属性名)格式是获取元素属性名的值，attr(属性名，属性值)格式则是设置元素属性名的值。 12345678 &lt;a href=&quot;http://127.0.0.1&quot; id=&quot;a1&quot;&gt;点我就变&lt;/a&gt; &lt;div&gt;我改变后的地址是：&lt;span id=&quot;tip&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#a1&quot;).attr(&quot;href&quot; , &quot;www.imooc.com&quot;); //赋值 var $url = $(&quot;#a1&quot;).attr(&quot;href&quot;); //取值 $(&quot;#tip&quot;).html($url); &lt;/script&gt; 操作元素的内容 使用html()和text()方法操作元素的内容，当两个方法的参数为空时，表示获取该元素的内容，而如果方法中包含参数，则表示将参数值设置为元素内容。 操作元素的样式 通过addClass()和css()方法可以方便地操作元素中的样式，前者括号中的参数为增加元素的样式名称，后者直接将样式的属性内容写在括号中。 1$(&quot;#content&quot;).css(&#123;&quot;background-color&quot;:&quot;red&quot;,&quot;color&quot;:&quot;white&quot;&#125;); 移除属性和样式 使用removeAttr(name)和removeClass(class)分别可以实现移除元素的属性和样式的功能，前者方法中参数表示移除属性名，后者方法中参数则表示移除的样式名 使用append()方法向元素内追加内容 append(content)方法的功能是向指定的元素中追加内容，被追加的content参数，可以是字符、HTML元素标记，还可以是一个返回字符串内容的函数。 1234567891011 &lt;body&gt; &lt;h3&gt;append()方法追加内容&lt;/h3&gt; &lt;script type=&quot;text/javascript&quot;&gt; function rethtml() &#123; var $html = &quot;&lt;div id=&apos;test&apos; title=&apos;hi&apos;&gt;我是调用函数创建的&lt;/div&gt;&quot; return $html; &#125; $(&quot;body&quot;).append(rethtml()); &lt;/script&gt; &lt;/body&gt; 使用appendTo()方法向被选元素内插入内容 appendTo()方法也可以向指定的元素内插入内容，它的使用格式是： 12345678910111213$(content).appendTo(selector)参数content表示需要插入的内容，参数selector表示被选的元素，即把content内容插入selector元素内，默认是在尾部。 &lt;body&gt; &lt;h3&gt;appendTo()方法插入内容&lt;/h3&gt; &lt;div&gt; &lt;span class=&quot;green&quot;&gt;小乌龟&lt;/span&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $html = &quot;&lt;span class=&apos;red&apos;&gt;小青蛙&lt;/span&gt;&quot; $($html).appendTo(&quot;div&quot;); &lt;/script&gt; &lt;/body&gt; 使用before()和after()在元素前后插入内容 使用before()和after()方法可以在元素的前后插入内容，它们分别表示在整个元素的前面和后面插入指定的元素或内容，调用格式分别为：$(selector).before(content)和$(selector).after(content)其中参数content表示插入的内容，该内容可以是元素或HTML字符串。 使用clone()方法复制元素 调用clone()方法可以生成一个被选元素的副本，即复制了一个被选元素，包含它的节点、文本和属性，它的调用格式为： 12345678910$(selector).clone()其中参数selector可以是一个元素或HTML内容。 &lt;body&gt; &lt;h3&gt;使用clone()方法复制元素&lt;/h3&gt; &lt;span class=&quot;red&quot; title=&quot;hi&quot;&gt;我是美猴王&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;body&quot;).append($(&quot;.red&quot;).clone()); &lt;/script&gt; &lt;/body&gt; 替换内容 replaceWith()和replaceAll()方法都可以用于替换元素或元素中的内容，但它们调用时，内容和被替换元素所在的位置不同，分别为如下所示： 1234567891011$(selector).replaceWith(content)和$(content).replaceAll(selector)参数selector为被替换的元素，content为替换的内容。 &lt;body&gt; &lt;h3&gt;使用replaceAll()方法替换元素内容&lt;/h3&gt; &lt;span class=&quot;green&quot; title=&quot;hi&quot;&gt;我是屌丝&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $html = &quot;&lt;span class=&apos;red&apos; title=&apos;hi&apos;&gt;我是土豪&lt;/span&gt;&quot;; $($html).replaceAll($(&quot;.green&quot;)); &lt;/script&gt; &lt;/body&gt; 使用wrap()和wrapInner()方法包裹元素和内容 12345678 &lt;body&gt; &lt;h3&gt;使用wrapInner()方法包裹元素&lt;/h3&gt; &lt;span class=&quot;red&quot; title=&apos;hi&apos;&gt;我的身体有点歪&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.red&quot;).wrapInner(&quot;&lt;i&gt;&lt;/i&gt;&quot;); &lt;/script&gt; &lt;/body&gt; 使用each()方法遍历元素 使用each()方法可以遍历指定的元素集合，在遍历时，通过回调函数返回遍历元素的序列号，它的调用格式为： 1234567891011121314151617$(selector).each(function(index))参数function为遍历时的回调函数，index为遍历元素的序列号，它从0开始。 &lt;body&gt; &lt;h3&gt;使用each()方法遍历元素&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;香蕉&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;桃子&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;葡萄&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;荔枝&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;span&quot;).each(function(index)&#123; if(index==2)&#123; $(this).addClass(&quot;red&quot;); &#125; &#125;) &lt;/script&gt; &lt;/body&gt; 使用remove()和empty()方法删除元素 remove()方法删除所选元素本身和子元素，该方法可以通过添加过滤参数指定需要删除的某些元素，而empty()方法则只删除所选元素的子元素。 123456789101112 &lt;body&gt; &lt;h3&gt;使用empty()方法删除元素&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;香蕉&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;桃子&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;葡萄&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;荔枝&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; //$(&quot;span&quot;).remove(&quot;.green&quot;); $(&quot;span&quot;).empty(); &lt;/script&gt; &lt;/body&gt; 页面加载时触发ready()事件 ready()事件类似于onLoad()事件，但前者只要页面的DOM结构加载后便触发，而后者必须在页面全部元素加载成功才触发，ready()可以写多个，按顺序执行。此外，下列写法是相等的： 1$(document).ready(function()&#123;&#125;)等价于$(function()&#123;&#125;); 使用bind()方法绑定元素的事件 bind()方法绑定元素的事件非常方便，绑定前，需要知道被绑定的元素名，绑定的事件名称，事件中执行的函数内容就可以，它的绑定格式如下： 12$(selector).bind(event,[data] function)参数event为事件名称，多个事件名称用空格隔开，function为事件执行的函数。 使用hover()方法切换事件 hover()方法的功能是当鼠标移到所选元素上时，执行方法中的第一个函数，鼠标移出时，执行方法中的第二个函数，实现事件的切实效果，调用格式如下： 123456789101112131415161718$(selector).hover(over，out);over参数为移到所选元素上触发的函数，out参数为移出元素时触发的函数。 &lt;body&gt; &lt;h3&gt;hover()方法切换事件&lt;/h3&gt; &lt;div&gt;别走！你就是土豪&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;div&quot;).hover( function () &#123; $(this).addClass(&quot;orange&quot;); &#125;, function () &#123; $(this).removeClass(&quot;orange&quot;) &#125;) &#125;); &lt;/script&gt; &lt;/body&gt; 使用toggle()方法绑定多个函数 toggle()方法可以在元素的click事件中绑定两个或两个以上的函数，同时，它还可以实现元素的隐藏与显示的切换，绑定多个函数的调用格式如下： 1$(selector).toggle(fun1(),fun2(),funN(),...) 其中，fun1，fun2就是多个函数的名称例如，使用toggle()方法，当每次点击&lt;div&gt;元素时，显示不同内容，如下图所示： 用作隐藏和显示的切换用法： 12345678910111213&lt;body&gt; &lt;h3&gt;toggle()方法绑定多个函数&lt;/h3&gt; &lt;input id=&quot;btntest&quot; type=&quot;button&quot; value=&quot;点一下我&quot; /&gt; &lt;div&gt;我是动态显示的&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#btntest&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;div&quot;).toggle(); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt; 使用unbind()方法移除元素绑定的事件 unbind()方法可以移除元素已绑定的事件，它的调用格式如下： 1$(selector).unbind(event,fun) 其中参数event表示需要移除的事件名称，多个事件名用空格隔开，fun参数为事件执行时调用的函数名称。例如，点击按钮时，使用unbind()方法移除&lt;div&gt;元素中已绑定的dblclick事件，如下图所示： 使用one()方法绑定元素的一次性事件]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap基础]]></title>
    <url>%2F2017%2F11%2F08%2Fbootstrap%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本的HTML模板 bootstrap模板为使IE6、7、8版本（IE9以下版本）浏览器兼容html5新增的标签，引入下面代码文件即可。 1&lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt; 同理为使IE6、7、8版本浏览器兼容css3样式，引入下面代码： 1&lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; 按钮（嵌套分组） 很多时候，我们常把下拉菜单和普通的按钮组排列在一起，实现类似于导航菜单的效果。如下所示： 使用的时候，只需要把当初制作下拉菜单的“dropdown”的容器换成“btn-group”，并且和普通的按钮放在同一级。如下所示： 123456789101112131415&lt;div class=&quot;btn-group&quot;&gt;&lt;button class=&quot;btnbtn-default&quot; type=&quot;button&quot;&gt;首页&lt;/button&gt;&lt;button class=&quot;btnbtn-default&quot; type=&quot;button&quot;&gt;产品展示&lt;/button&gt;&lt;button class=&quot;btnbtn-default&quot; type=&quot;button&quot;&gt;案例分析&lt;/button&gt;&lt;button class=&quot;btnbtn-default&quot; type=&quot;button&quot;&gt;联系我们&lt;/button&gt;&lt;div class=&quot;btn-group&quot;&gt; &lt;button class=&quot;btnbtn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; type=&quot;button&quot;&gt;关于我们&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;##&quot;&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;##&quot;&gt;企业文化&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;##&quot;&gt;组织结构&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;##&quot;&gt;客服服务&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/div&gt; 按钮（等分按钮） 等分按钮的效果在移动端上特别的实用。整个按钮组宽度是容器的100%，而按钮组里面的每个按钮平分整个容器宽度。例如，如果你按钮组里面有五个按钮，那么每个按钮是20%的宽度，如果有四个按钮，那么每个按钮是25%宽度，以此类推。 等分按钮也常被称为是自适应分组按钮，其实现方法也非常的简单，只需要在按钮组“btn-group”上追加一个“btn-group-justified”类名，如下所示： 12345678&lt;div class=&quot;btn-wrap&quot;&gt; &lt;div class=&quot;btn-group btn-group-justified&quot;&gt; &lt;a class=&quot;btnbtn-default&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;a class=&quot;btnbtn-default&quot; href=&quot;#&quot;&gt;产品展示&lt;/a&gt; &lt;a class=&quot;btnbtn-default&quot; href=&quot;#&quot;&gt;案例分析&lt;/a&gt; &lt;a class=&quot;btnbtn-default&quot; href=&quot;#&quot;&gt;联系我们&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 运行效果如下： 实现原理非常简单，把“btn-group-justified”模拟成表格（display:table），而且把里面的按钮模拟成表格单元格（display:table-cell）。具体样式代码如下： 12345678910111213141516/*源码请查看bootstrap.css文件第3277行～第3291行*/.btn-group-justified &#123; display: table; width: 100%; table-layout: fixed; border-collapse: separate;&#125;.btn-group-justified &gt; .btn,.btn-group-justified &gt; .btn-group &#123; display: table-cell; float: none; width: 1%;&#125;.btn-group-justified &gt; .btn-group .btn &#123; width: 100%;&#125; 特别声明：在制作等分按钮组时，请尽量使用&lt;a&gt;标签元素来制作按钮，因为使用&lt;button&gt;标签元素时，使用display:table在部分浏览器下支持并不友好。 固定导航条 很多情况之一，设计师希望导航条固定在浏览器顶部或底部，这种固定式导航条的应用在移动端开发中更为常见。Bootstrap框架提供了两种固定导航条的方式： .navbar-fixed-top：导航条固定在浏览器窗口顶部 .navbar-fixed-bottom：导航条固定在浏览器窗口底部 使用方法很简单，只需要在制作导航条最外部容器navbar上追加对应的类名即可： 1234567&lt;div class=&quot;navbar navbar-default navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; …&lt;/div&gt;&lt;div class=&quot;content&quot;&gt;我是内容&lt;/div&gt;&lt;div class=&quot;navbar navbar-default navbar-fixed-bottom&quot; role=&quot;navigation&quot;&gt; …&lt;/div&gt; 实现原理：实现原理很简单，就是在navbar-fixed-top和navbar-fixed-bottom使用了position：fixed属性，并且设置navbar-fixed-top的top值为0,而navbar-fixed-bottom的bottom值为0。 分页导航（带页码的分页导航）分页导航几乎在哪个网站都可见。好的分页导航能给用户带来更好的用户体验。在Bootstrap框架中提供了两种分页导航： 带页码的分页导航 带翻页的分页导航 带页码的分页导航 带页码的分页导航，可能是最常见的一种分页导航，特别是在列表页内容超多的时候，会给用户提供分页的导航方式。在Bootstrap框架为开发者提供不同的版本： LESS版本：对应的源文件pagination.less Sass版本：对应的源文件_pagination.scss 编译后版本：对应bootstrap.css文件第4130行～第4222行 使用方法： 平时很多同学喜欢用div&gt;a和div&gt;span结构来制作带页码的分页导航。不过，在Bootstrap框架中使用的是ul&gt;li&gt;a这样的结构，在ul标签上加入pagination方法： 123456789&lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;laquo;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 运行效果： 实现原理： 从效果中可以看出，当前状态页码会高亮显示，而且不能点击。而最后一页是禁用状态，也不能点击。实现样式： 123456789101112131415161718192021222324/*bootstrap.css文件第4170行~第4192行*/.pagination&gt; .active &gt; a,.pagination&gt; .active &gt; span,.pagination&gt; .active &gt;a:hover,.pagination&gt; .active &gt;span:hover,.pagination&gt; .active &gt;a:focus,.pagination&gt; .active &gt;span:focus &#123;z-index: 2;color: #fff;cursor: default;background-color: #428bca;border-color: #428bca;&#125;.pagination&gt; .disabled &gt; span,.pagination&gt; .disabled &gt;span:hover,.pagination&gt; .disabled &gt;span:focus,.pagination&gt; .disabled &gt; a,.pagination&gt; .disabled &gt;a:hover,.pagination&gt; .disabled &gt;a:focus &#123;color: #999;cursor: not-allowed;background-color: #fff;border-color: #ddd;&#125; 注意：要禁用当前状态和禁用状态不能点击，我们还要依靠js来实现，或者将这两状态下的a标签换成span标签。 大小设置： 在Bootstrap框架中，也可以通过几个不同的情况来设置其大小。类似于按钮一样： 通过“pagination-lg”让分页导航变大； 通过“pagination-sm”让分页导航变小： 123456789&lt;ul class=&quot;pagination pagination-lg&quot;&gt; …&lt;/ul&gt;&lt;ul class=&quot;pagination&quot;&gt; …&lt;/ul&gt;&lt;ul class=&quot;pagination pagination-sm&quot;&gt; …&lt;/ul&gt; 大小设置实现原理： 其实就是通增加相应的padding大小、font-size大小和圆角大小，源码查看bootstrap.css文件第4193行～第4222行. 导入JavaScript插件 Bootstrap除了包含丰富的Web组件之外，如前面介绍的下拉菜单、按钮组、导航、分页等。他还包括一些JavaScript的插件。 Bootstrap的JavaScript插件可以单独导入到页面中，也可以一次性导入到页面中。因为在Bootstrap中的JavaScript插件都是依赖于jQuery库，所以不论是单独导入还一次性导入之前必须先导入jQuery库。 一次性导入： Bootstrap提供了一个单一的文件，这个文件包含了Bootstrap的所有JavaScript插件，即bootstrap.js（压缩版本：bootstrap.min.js）。 具体使用如下: 1234&lt;!—导入jQuery版本库，因为Bootstrap的JavaScript插件依赖于jQuery --&gt;&lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt;&lt;!—- 一次性导入所有Bootstrap的JavaScript插件（压缩版本） --&gt;&lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 特别声明：jQuery版本库也可以加载你本地的jQuery版本。 单独导入： 为方便单独导入特效文件，Bootstrap V3.2中提供了12种JavaScript插件，他们分别是： 动画过渡（Transitions）:对应的插件文件“transition.js” 模态弹窗（Modal）:对应的插件文件“modal.js” 下拉菜单（Dropdown）：对应的插件文件“dropdown.js” 滚动侦测（Scrollspy）：对应的插件文件“scrollspy.js” 选项卡（Tab）：对应的插件文件“tab.js” 提示框（Tooltips）：对应的插件文件“tooltop.js” 弹出框（Popover）：对应的插件文件“popover.js” 警告框（Alert）：对应的插件文件“alert.js” 按钮（Buttons）：对应的插件文件“button.js” 折叠/手风琴（Collapse）：对应的插件文件“collapse.js” 图片轮播Carousel：对应的插件文件“carousel.js” 自动定位浮标Affix：对应的插件文件“affix.js” 上述单独插件的下载可到github去下载 https://github.com/twbs/bootstrap]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2017%2F11%2F06%2FCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有： 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 常用的内联元素有： 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 常用的内联块状元素有： 1&lt;img&gt;、&lt;input&gt; 什么是块级元素？ 在html中&lt;div&gt;、 &lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;就是块级元素。设置display:block就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。 1a&#123;display:block;&#125; 块级元素特点： 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 元素分类–内联元素 在html中，&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码display:inline将元素设置为内联元素。如下代码就是将块状元素div转换为内联元素，从而使 div 元素具有内联元素特点。 1234div&#123; display:inline;&#125;&lt;div&gt;我要变成内联元素&lt;/div&gt; 内联元素特点： 1、和其他元素都在一行上； 2、元素的高度、宽度及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 元素分类–内联块状元素 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码display:inline-block就是将元素设置为内联块状元素。 (css2.1新增)，&lt;img&gt;、&lt;input&gt;标签就是这种内联块状标签。 inline-block 元素特点： 1、和其他元素都在一行上； 2、元素的高度、宽度、行高以及顶和底边距都可设置。 css布局模型 清楚了CSS 盒模型的基本概念、 盒模型类型， 我们就可以深入探讨网页布局的基本模型了。布局模型与盒模型一样都是 CSS 最基本、 最核心的概念。 但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS 布局样式或 CSS 布局模板。如果说布局模型是本，那么 CSS 布局模板就是末了，是外在的表现形式。 CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。 在网页中，元素有三种布局模型： 1、流动模型（Flow） 2、浮动模型 (Float) 3、层模型（Layer） 流动模型（一）先来说一说流动模型，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型具有2个比较典型的特征： 第一点，块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 流动模型（二） 第二点，在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 浮动模型 块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动，如 div、p、table、img 等元素都可以被定义为浮动。如下代码可以实现两个 div 元素一行显示。 12345678div&#123; width:200px; height:200px; border:2px red solid; float:left;&#125;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;div2&quot;&gt;&lt;/div&gt; 效果图 当然你也可以同时设置两个元素右浮动也可以实现一行显示。 123456div&#123; width:200px; height:200px; border:2px red solid; float:right;&#125; 效果图 又有小伙伴问了，设置两个元素一左一右可以实现一行显示吗？当然可以： 1234567div&#123; width:200px; height:200px; border:2px red solid;&#125;#div1&#123;float:left;&#125;#div2&#123;float:right;&#125; 效果图 什么是层模型？ 什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我们来学习一下html中的层布局。 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。 层模型有三种形式： 1、绝对定位(position: absolute) 2、相对定位(position: relative) 3、固定定位(position: fixed) 层模型–绝对定位 如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 如下面代码可以实现div元素相对于浏览器窗口向右移动100px，向下移动50px。 123456789div&#123; width:200px; height:200px; border:2px red solid; position:absolute; left:100px; top:50px;&#125;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 效果如下： 层模型–相对定位 如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 如下代码实现相对于以前位置向下移动50px，向右移动100px; 12345678910#div1&#123; width:200px; height:200px; border:2px red solid; position:relative; left:100px; top:50px;&#125;&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt; 效果图： 层模型–固定定位 fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 12345678#div1&#123; width:200px; height:200px; border:2px red solid; position:fixed; left:100px; top:50px;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2017%2F10%2F26%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[###python list 1L = [&apos;adna&apos;,87,true] 可以是不同类型的 索引从0开始 可以倒叙调用 L[-1]最后一个元素 添加 append是将新元素添加到末尾 insert接受两个参数 第一个参数是索引，第二个是待添加的新元素 12L = [&apos;adam&apos;,&apos;Lisa&apos;,&apos;Bart&apos;]L.insert(0,&apos;Paul&apos;) 这时L = [‘Paul’,’adam’,’Lisa’,’Bart’] pop删除最后一个元素 pop可以加索引参数指定删除第几个 pop(2)删除第三个元素 替换元素 直接覆盖 L[2] = &#39;Paul&#39;就将原来的替换掉了 python tuple（元组）与list区别：tuple一旦创建就不能修改 而且不是[ ]而是( ) t = (&#39;Adam&#39;,&#39;Lisa&#39;,&#39;Bart&#39;) 元组创建后只可以通过索引调用不能修改 append insert pop这些方法都不能用单元素元组要在后面加，多元素可加可不加t = (1,) 可变的tuple123456t = (&apos;a&apos;,&apos;b&apos;,[&apos;A&apos;,&apos;B&apos;])L = t(2)L[0] = &apos;X&apos;L[1] = &apos;Y&apos;print t(&apos;a&apos;,&apos;b&apos;,[&apos;X&apos;,&apos;Y&apos;]) if-else这里的非不适用！而是用not例如判断未成年人可以这样写： 12if not age &gt;= 18:print &apos;teenager&apos; 多种选择结构的时候if elif else 12345678if age &gt;= 18: print &apos;adult&apos;elif age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 3: print &apos;kid&apos;else: print &apos;baby&apos; for的用法123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]for name in L: print name 在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环 ###python dictkey-value形式的 12345d = &#123;&apos;Adam&apos;:95,&apos;Lisa&apos;:85,&apos;Bart&apos;:59&#125; 花括号{}表示这是一个dict，然后按照key:value写出来即可。 len(d) 这里等于3 访问要用d[key]的形式 key不存在时会报错：KeyError 要避免KeyError发生，有两个方法： 一是先判断一下key是否存在，用in操作符： 12if &apos;Paul&apos; in d:print d[&apos;Paul&apos;] 如果’Paul’不存在，if语句判断为Falue，自然不会执行pring语句，从而避免了错误 二是使用dict本身提供的一个get方法，在Key不存在的时候，返回None 1234print d.get(&apos;Bart&apos;)59print d.get(&apos;Paul&apos;)None dict的特点dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。 不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，内存占用小，但是查找速度慢。 由于dict是按key查找，所以，在一个dict钟，key不能重复！！！ dict的第二个特点就是存储的key-value序对是没有顺序的，内部无序，每次打印顺序都可能不同 dict的第三个特点是作为key的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为key。但是list是可变的，就不能作为key 更新dictdict是可变的，也就是说，我们可以随时往dict中添加新的key-value。比如已有dict： 12345d = &#123;&apos;Adam&apos;：95,&apos;Lisa&apos;：85,&apos;Bart&apos;：59&#125; 要把新同学’Paul’的成绩72加进去，用赋值语句： 1d[&apos;Paul&apos;] = 72 这样里面就有四个元素了 如果key已经存在，则赋值会用新的value替换掉原来的value 遍历dict12for key in d:print key + &apos;:&apos; + str(d[key]) python setdict的作用是建立一组key和一组value的映射关系，dict的key是不能重复的. 有的时候，我们只想要dict的key，不关心key对应的value吗，目的就是保证整个集合的元素不会重复，这时，set就派上用场了。 set持有一系列元素，这一点和list很想，但是set的元素没有重复，而且是无序的，这点和dict的key很像。 创建set的方式是调用set()并传入一个list，list的元素将作为set的元素： 12s = set([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;])print s #set([&apos;A&apos;,&apos;B&apos;,&apos;C&apos;]) 请注意，上述打印的形式类似list，但它不是list，set内部存储的元素是无序的. set不能包含重复的元素，当传入包含重复元素的list时，set会自动去掉重复的元素. 访问set由于set存储的是无序集合，所以我们没法通过索引来访问 访问set中的某个元素实际上及时判断一个元素时候在set中 &#39;A&#39; in s #True set的特点set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快 set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。 最后，set存储的元素也是没有顺序的 所以set能应用在哪些地方呢 例如我们用set列出所有的星期 星期一到星期日 然后验证用户输入的是不是一个有效的日期等等. 遍历set12for name in s:print name 更新set由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事： 一是把新的元素添加到set中，二是把已有元素从set中删除 添加 add()如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了 删除set中的元素时，用set的remove()方法 如果删除的元素不存在set中，remove()会报错 所以用add()可以直接添加，而remove()前需要判断 python函数返回多值12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 这样我们就可以同时获得返回值： 123x, y = move(100, 100, 60, math.pi / 6) print x, y输出：151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 12r = move(100, 100, 60, math.pi / 6)print r #(151.96152422706632, 70.0) 用print打印返回结果，原来返回值是一个tuple！ 但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 python之递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数 Python之定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： 12def fn(*args): print args 可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数： 12345678fn()()fn(&apos;a&apos;)(&apos;a&apos;,)fn(&apos;a&apos;, &apos;b&apos;)(&apos;a&apos;, &apos;b&apos;)fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 定义可变参数的目的也是为了简化调用。 对list进行切片L[0:3]取前三个元素 如果第一个索引是0 可以省略 切片可以指定第三个参数 第三个参数表示每N个取一个 L[::2]表示每两个元素取出一个来 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple 切片也支持倒序 L[-4:-1:2] 字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 123456&apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&apos;ABCDEFG&apos;[-3:]&apos;EFG&apos;&apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 什么是迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。 在Python中，迭代是通过 for … in 来完成的 索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。 对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 enumerate() 函数： 12345678L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul 迭代dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 1234d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.values() # [85, 95, 59]for v in d.values(): print v #85 95 59 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。 首先，我们看看 dict 对象的 items() 方法返回的值： 123d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value： 123456for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： 12range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： 12345L = []for x in range(1, 11): L.append(x * x) L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12[x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 12[x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选： 12[x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 多层表达式for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。 对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： 12[m + n for m in &apos;ABC&apos; for n in &apos;123&apos;][&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;] 翻译成循环代码就像下面这样： 1234L = []for m in &apos;ABC&apos;: for n in &apos;123&apos;: L.append(m + n)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver数据库大小写不敏感问题]]></title>
    <url>%2F2017%2F10%2F22%2Fsqlserver%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[c#调用sqlserver数据库发现大小写不敏感，到数据库中查询发现是数据库中大小写就不敏感 解决：是数据库排序规则设置错误。 设置参考值 12345678910111213141516_CI_AI 不区分大小写、不区分重音、不区分化名类型、不区分宽度 _CI_AI_WS 不区分大小写、不区分重音、不区分化名类型、区分宽度 _CI_AI_KS 不区分大小写、不区分重音、区分化名类型、不区分宽度 _CI_AI_KS_WS 不区分大小写、不区分重音、区分化名类型、区分宽度 _CI_AS 不区分大小写、区分重音、不区分化名类型、不区分宽度 _CI_AS_WS 不区分大小写、区分重音、 不区分化名类型、区分宽度 _CI_AS_KS 不区分大小写、区分重音、区分化名类型、不区分宽度 _CI_AS_KS_WS 不区分大小写、区分重音、区分化名类型、区分宽度 _CS_AI 区分大小写、不区分重音、 不区分化名类型、不区分宽度 _CS_AI_WS 区分大小写、不区分重音、不区分化名类型、区分宽度 _CS_AI_KS 区分大小写、不区分重音、区分化名类型、不区分宽度 _CS_AI_KS_WS 区分大小写、不区分重音、区分化名类型、区分宽度 _CS_AS 区分大小写、区分重音、不区分化名类型、不区分宽度 _CS_AS_WS 区分大小写、区分重音、不区分化名类型、区分宽度 _CS_AS_KS 区分大小写、区分重音、区分化名类型、不区分宽度 _CS_AS_KS_WS 区分大小写、区分重音、区分化名类型、区分宽度 这里我们要用Chinese_PRC_CS_AS]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOA介绍]]></title>
    <url>%2F2017%2F10%2F19%2FSOA%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一、SOA是什么SOA的全称是Service-Oriented Architecture，面向服务架构。是一种架构，不是一种具体的开发技术。 要真正理解什么是SOA需要从软件开发的技术发展史谈起。 真正的软件开发从开始到现在经历了四个阶段，也可以说成是四代： 1、汇编语言开发 2、面向过程的软件 3、面向对象的组件开发 4、面向服务的架构开发，也是今天要谈论的SOA架构 SOA与前面三代的软件开发技术对比，不同点是SOA超越了软件开发语言本身。是一种面向服务的架构，与软件开发语言无关。 但就软件开发本身来说，SOA是一种技术，又超越了所有具体的技术。 二、SOA的技术革命SOA既然能成为第四代软件开发技术，究竟带来什么革命。 首先，SOA是一种开发思想。是一种松耦合的框架。可以让软件超越开发语言。 其次，SOA的开发需要SOA体系的支撑，就像J2EE应用一样，离不开应用服务器。SOA也一样，也有一个类似J2EE服务器的东西支持着整个SOA体系架构—-ESB（Enterprise Service Bus），企业服务总线。通过这个总线，将多个系统连接起来。 其次，SOA是基于消息请求响应的一个系统，对请求类型有高度的兼容性。与一个Web应用容器相比，web应用容器只能处理HTTP请求，而 SOA的ESB可以接受HTTP、FTP、WebService、JMS…等请求。这就使得SOA架构具有高度的兼容性，可以将不同的平台集成到一 起，从而相互协调工作。 三、SOA火起来的真正原因 1、软件开发技术的不断提高。 2、硬件性能的提升，价格下降，投出SOA所消耗的成本为企业所能忍受。 3、SOA受到了IMB、Oracle、Sun、Microsoft等大公司的热力追捧，被捧红了，实际上，一直以来都是这些公司在引领软件应用的潮流。 4、SOA技术革命每年有上千亿美元的市场价值。软件要升级，这些服务提供商才可以买出更多的中间件服务器，卖出更多的硬件，赚取更多利润。 5、很多企业的软件应用系统已经满足不了信息高度集成化的要求，为了提高企业的核心竞争力，企业不惜重金，上SOA。 6、SOA的招牌很响亮，超越了一切，兼容了一切。它不摒弃旧系统，而是将很多旧系统继承起来，就可以实现。—–实际上，我个人认为这是一个骗局。 四、SOA最有前景的舞台 1、基于SOA是的思想和技术，SOA最适合最擅长的就是系统集成。而系统集成的关键就是提取公共的有价值的服务。各个系统通过暴露服务，经过ESB这条总线连接后，就将几个系统集成起来了。这在新一代软件开发中也许会得到应用。 2、SOA的架构注定SOA在中小企业内部没有多大价值。中小企业的摊子还不够大。 3、SOA系统集成难点在于抽取公共的服务。对于老的系统来说，抽取服务就是抽筋。很难很难，意味着要修改软件，要适合SOA的胃口。因此，对一些不同语言开发的系统来说，使用SOA进行系统实际上是扯淡。 五、SOA发展现状对SOA口号叫的最响的是IBM，出书最多的也是IBM，成功的案例还没看到。所有的大公司都在忽悠，希望拿到第一笔大单。 SOA以来ESB，ESB本身也是一种中间件，或者说是一个增强了的企业应用服务器。目前开源的有几个，也没见过成功的案例。估计SOA技术从起步到成熟还有很长一段路要走。ESB的实现还需要一个发展过程。 相反与SOA有紧密联系WebService技术已经深入人心。现在用的比较多。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git coding的使用]]></title>
    <url>%2F2017%2F10%2F17%2Fgit%20coding%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[coding上传项目步骤 step1:在coding上面创建一个项目myboke step2：使用git init创建.git文件夹和.gitigonre文件，帮组本地与远程的链接 step3：使用git pull &lt;项目地址&gt;同步项目上面的文件 step4: git add * 添加项目下面的所有文件 step5: git commit -m ‘备注’ 将文件添加在cache中并添加备注 step6:git remote add &lt;名字（随意）&gt; shh地址git remote add origin http://coding..... step7:git push step8：最后在coding网站中查看是否上传成功 创建分支 1git branch dev 切换分支 1git checkout dev 上传代码到分支 1234git add .git commit -m &apos; &apos;git remote add origin 远程仓库地址git push -u origin dev]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flag]]></title>
    <url>%2F2017%2F10%2F16%2Fflag%2F</url>
    <content type="text"><![CDATA[经过两天的折腾，总算搭好了自己的博客网站。 姑且用来记录生活和学习吧。 先立下几条flag: 好好学习，天天向上 和大想好好的 不要老是不开心，不喜欢的人和事远离就好，不融入，不评判 综上。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
