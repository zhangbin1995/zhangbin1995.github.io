---
title: java多线程之内存可见性
date: 2018-01-04 11:33:46
tags:
	- java
categories:
	- java
---

### 可见性

**可见性：**一个线程对共享变量值的修改，能够及时地被其他线程看到。

**共享变量：**如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量

### Java内存模型（JMM）

Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。

所有的变量都存储在主内存中。

每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本。（主内存中该变量的一份拷贝）

![](/uploads/180104java1/1.png)

### 两条规定

> * 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。

> * 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

![](/uploads/180104java1/2.png)

要实现共享变量的可见性，必须保证两点：

> * 线程修改后的共享变量值能够及时从工作内存刷新到主内存中。
> * 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中

### Java语言层次支持的可见性实现方式：

```
    synchronized
    volatile
```

**synchronized能够实现：**

原子性（同步）

可见性

JMM关于synchronized的两条规定：
> * 线程解锁前，必须把共享变量的最新值刷新到主内存中。
> * 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
            （注意：加锁和解锁需要是同一把锁）

线程解锁前对共享变量的修改在下次加锁时对其他线程可见

![](/uploads/180104java1/3.png)           

### 重排序
**重排序：**代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化

> * 1.编译器优化的重排序（编译器优化）
> * 2.指令级并行重排序（处理器优化）
> * 3.内存系统的重排序（处理器优化）

as-if-serial：无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义）

![](/uploads/180104java1/4.png)

### 可见性分析
导致共享变量在线程间不可见的原因：      synchronized解决方案
> * 1.线程的交叉执行       ——>   原子性
> * 2.重排序结合线程交叉执行       ——>   原子性
> * 3.共享变量更新后的值没有在工作内存与主内存间及时更新    ——>   可见性



### volatile实现可见性
volatile如何实现内存可见性：
> * 深入来说：通过加入内存屏障和禁止重排序优化来实现的。
> * 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令。
> * 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令。

### volatile如何实现内存可见性：
通俗的讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。

#### 线程写volatile变量的过程：
> * 1.改变线程工作内存中volatile变量副本的值。
> * 2.将改变后的副本的值从工作内存刷新到主内存。

#### 线程读volatile变量的过程：
> * 1.从主内存中读取volatile变量的最新值到线程的工作内存中。
> * 2.从工作内存中读取volatile变量的副本。

volatile不能保证volatile变量复合操作的原子性

![](/uploads/180104java1/5.png)

![](/uploads/180104java1/6.png)

在多进程（线程）的操作系统中不能被其它进程（线程）打断的操作就叫原子操作，文件的原子操作是指操作文件时的不能被打断的操作。原子操作是不可分割的，在执行过程中不会被任何其它任务或事件中断。

回滚就是回到事务开始之前的状态

我们把这种要么一起成功（A帐户成功减少1000，同时B帐户成功增加1000），要么一起失败（A帐户回到原来状态，B帐户也回到原来状态）的操作叫原子性操作。

如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。这种特性就叫原子性

![](/uploads/180104java1/7.png)

![](/uploads/180104java1/8.png)

![](/uploads/180104java1/9.png)

![](/uploads/180104java1/10.png)


