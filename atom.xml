<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeroBin&#39;s Blog</title>
  
  <subtitle>向阳而生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.herobin.top/"/>
  <updated>2019-03-03T06:49:47.946Z</updated>
  <id>http://www.herobin.top/</id>
  
  <author>
    <name>HeroBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper下载与安装</title>
    <link href="http://www.herobin.top/2019/03/03/zookeeper%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://www.herobin.top/2019/03/03/zookeeper下载与安装/</id>
    <published>2019-03-03T06:47:13.000Z</published>
    <updated>2019-03-03T06:49:47.946Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>在zookeeper官网：<a href="http://zookeeper.apache.org" target="_blank" rel="noopener">zookeeper.apache.org</a> 中点击download进入下载页面</p><p><img src="/uploads/190303java2/1.png" alt=""></p><p>点击进入下载，这里我们下载的版本是3.4.10</p><p>下载完成后，拷贝到我们想要放到的路径进行解压，注意路径不要有中文。</p><p>注意zookeeper的安装是要建立在jdk的安装上的，不过安装zookeeper的应该也都有jdk了。。。</p><p>首先我们要去conf文件夹中修改一个配置文件<code>zoo_sample.cfg</code>改名为<code>zoo.cfg</code></p><p>去bin文件夹下可以看到我们启动执行文件<code>zkServer.sh</code>(windows则为<code>zkServer.cmd</code>)<br>执行该文件<code>./zkServer.sh start</code>，如下图执行成功。</p><p><img src="/uploads/190303java2/2.png" alt=""></p><p>ZooKeeper下载与安装完毕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在zookeeper官网：&lt;a href=&quot;http://zookeeper.apache.org&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="zookeeper" scheme="http://www.herobin.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>springboot集成dubbo环境搭建</title>
    <link href="http://www.herobin.top/2019/03/03/springboot%E9%9B%86%E6%88%90dubbo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.herobin.top/2019/03/03/springboot集成dubbo环境搭建/</id>
    <published>2019-03-03T04:31:12.000Z</published>
    <updated>2019-03-03T04:34:03.386Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>新建project</p><p><img src="/uploads/190303java1/1.png" alt=""></p><p>next取好项目名，一路next即可。<br>新建两个module，provider和consumer同样是springboot项目创建步骤同上。<br>将两个模块分别启动，均启动成功，说明springboot没有问题，接下来集成dubbo。<br>SpringBoot版本Dubbo集成中文地址：<a href="https://github.com/alibaba/dubbo-spring-boot-starter/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/alibaba/dubbo-spring-boot-starter/blob/master/README_zh.md</a></p><p>将dubbo的依赖引入到两个模块的pom中</p><p><img src="/uploads/190303java1/2.png" alt=""></p><p>在application.properties中添加dubbo的相关配置信息</p><p><img src="/uploads/190303java1/3.png" alt=""></p><p>接下来在ProviderApplication的上添加@EnableDubboConfiguration，表示要开启dubbo功能. (dubbo provider服务可以使用或者不使用web容器)</p><p><img src="/uploads/190303java1/4.png" alt=""></p><p>编写服务提供者的接口和实现类<br>编写你的dubbo服务，只需要添加要发布的服务实现上添加@Service（import com.alibaba.dubbo.config.annotation.Service）注解，其中interfaceClass是要发布服务的接口</p><p><img src="/uploads/190303java1/5.png" alt=""></p><p>启动服务者的Spring Boot应用，观察控制台，可以看到dubbo启动相关信息.<br>至此，provider的dubbo配置成功。</p><p>接下来配置consumer的dubbo配置<br>添加依赖</p><p><img src="/uploads/190303java1/6.png" alt=""></p><p>在application.properties中添加dubbo的相关配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=dubbo-spring-boot-starter</span><br></pre></td></tr></table></figure></p><p>这里这个name是可以自己命名的。</p><p>开启ConsumnerApplication启动类的<code>@EnableDubboConfiguration</code>注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableDubboConfiguration</span><br></pre></td></tr></table></figure></p><p>在consumer中编写服务实用类，记得要将provider中的接口DemeService拷贝过来</p><p><img src="/uploads/190303java1/7.png" alt=""></p><p>编写ConsumerApplication类并执行</p><p><img src="/uploads/190303java1/8.png" alt=""></p><p>获得目标输出，springboot集成dubbo环境搭建成功。</p><p>代码github地址：<a href="https://github.com/zhangbin1995/springbootdubbo.git" target="_blank" rel="noopener">https://github.com/zhangbin1995/springbootdubbo.git</a></p><p>当然上面只是简单的springboot+dubbo的环境集成，这样是有瑕疵的。</p><p>我们的上面示例里消费者是直连提供者的，这种方式只可以在测试环境中使用，因为直连提供者限制了分布式的易扩展性，如果提供者部署在多节点，而我们在消费者中是直连写死的状态，那就只会访问一个节点，也违背了我们的分布式的初衷。</p><p>所以通常我们的消费者和提供者是要通过注册中心来注册调用的关于注册中心，后面会继续介绍，本篇博文介绍的springboot+dubbo的集成到此结束。</p><p><img src="/uploads/190303java1/9.png" alt=""></p><p><img src="/uploads/190303java1/10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新建project&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/190303java1/1.png&quot; alt=&quot;&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>spring集成dubbo开发环境搭建</title>
    <link href="http://www.herobin.top/2019/03/02/spring%E9%9B%86%E6%88%90dubbo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.herobin.top/2019/03/02/spring集成dubbo开发环境搭建/</id>
    <published>2019-03-02T08:21:15.000Z</published>
    <updated>2019-03-02T08:25:16.629Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>首先新建maven项目选择quickstart为项目原型。</p><p><img src="/uploads/190302java1/1.png" alt=""></p><p>点击项目添加两个module分别命名provider和consumer，原型同样选择quickstart分别作为服务提供者和消费者。（注意新建后暂时没有src文件夹，要等maven配置全部加载完才有，如果过慢，记得检查是否配置好idea的maven配置是否改为aliyun仓库）。<br>这里我们用不到测试用例，可以将test文件删掉。</p><p>添加放置资源文件的resources文件夹，并在project structrue中添加进Resources中。</p><p><img src="/uploads/190302java1/2.png" alt=""></p><p>将需要的jar包依赖拷贝到父工程的pom中，这样各个模块就都可以使用了，注意在实际开发中，应该是各个模块分别引入该模块要用到的jar包，再在各模块的resources中新建applicationContext.xml即spring配置文件。</p><p><img src="/uploads/190302java1/3.png" alt=""></p><p>这样简单的spring环境就搭好了，接下来我们要集成dubbo环境。<br>可以参考dubbo用户手册：<a href="https://dubbo.gitbooks.io/dubbo-user-book/content/quick-start.html" target="_blank" rel="noopener">https://dubbo.gitbooks.io/dubbo-user-book/content/quick-start.html</a></p><p><img src="/uploads/190302java1/4.png" alt=""></p><p>在provider中新建一个服务接口DemoService和它的实现类。<br>用Spring配置声明暴露服务。</p><p><img src="/uploads/190302java1/5.png" alt=""></p><p>编写服务启动类App.java</p><p><img src="/uploads/190302java1/6.png" alt=""></p><p>至此，我们的provider模块就写好了，将它启动起来。<br>编辑consumer里的applicationContext.xml文件通过spring配置引用远程服务。</p><p><img src="/uploads/190302java1/7.png" alt=""></p><p>这样就已经可以访问到provider接口提供的服务了。<br>编写App类加载consumer的spring配置文件并进行测试。</p><p><img src="/uploads/190302java1/8.png" alt=""></p><p>启动消费者服务，输入zhangbin，得到服务提供者接口的返回值，由此，spring与dubbo集成环境配置成功。</p><p>项目代码已放到github：<a href="https://github.com/zhangbin1995/springdubbo.git" target="_blank" rel="noopener">https://github.com/zhangbin1995/springdubbo.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先新建maven项目选择quickstart为项目原型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/190302ja
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="spring" scheme="http://www.herobin.top/tags/spring/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>第一个docker化的java应用</title>
    <link href="http://www.herobin.top/2019/02/23/%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E5%8C%96%E7%9A%84java%E5%BA%94%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/02/23/第一个docker化的java应用/</id>
    <published>2019-02-23T02:30:24.000Z</published>
    <updated>2019-03-02T08:44:07.147Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h1 id="制作镜像Dockerfile"><a href="#制作镜像Dockerfile" class="headerlink" title="制作镜像Dockerfile"></a>制作镜像Dockerfile</h1><p>这里制作镜像主要分为三步</p><blockquote><p>Dockerfile<br>docker build<br>Jpress：<a href="http://jpress.io/" target="_blank" rel="noopener">http://jpress.io/</a> (开源java web应用 博客平台)</p></blockquote><h2 id="下载tomcat镜像"><a href="#下载tomcat镜像" class="headerlink" title="下载tomcat镜像"></a>下载tomcat镜像</h2><p>首先我们的镜像是要依托tomcat运行的，所以先到网易云的镜像中心下载tomcat的镜像<br><code>docker pull hub.c.163.com/library/tomcat:latest</code><br>在tomcat镜像的介绍中可以看到使用方法，如找到启动方法，查看tomcat路径等。</p><p><img src="/uploads/190222java3/1.png" alt=""></p><h2 id="新建编辑Dockerfile"><a href="#新建编辑Dockerfile" class="headerlink" title="新建编辑Dockerfile"></a>新建编辑Dockerfile</h2><p><code>vi Dockerfile</code> </p><p><img src="/uploads/190222java3/2.png" alt=""></p><h2 id="通过docker-build生成镜像"><a href="#通过docker-build生成镜像" class="headerlink" title="通过docker build生成镜像"></a>通过docker build生成镜像</h2><p><img src="/uploads/190222java3/3.png" alt=""></p><p>这里<code>-t jpress:latest</code>是指定了镜像名字和标签，注意后面有个 . 用于查找当前目录下的构建文件，即Dockerfile<br>用<code>docker images</code>查看，发现有了jpress。</p><p><img src="/uploads/190222java3/4.png" alt=""></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>在tomcat的镜像中心我们可以看到运行指令，执行：<br><code>docker run -d -p 8888:8080 jpress</code><br>启动镜像，发现可以访问我们的jpress程序了。</p><p><img src="/uploads/190222java3/5.png" alt=""></p><p>这里要正常使用jpress需要配置好数据库信息。<br>我们也可以在docker中安装运行一个mysql数据库。<br>去镜像中心下载mysql镜像：<br><code>docker pull hub.c.163.com/library/mysql:latest</code><br>同样可以在介绍中看到使用方式。</p><p><img src="/uploads/190222java3/6.png" alt=""></p><p>下载完后新建一个名为jpress的数据库并将mysql运行起来：<br> <code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest</code><br>回到网站将信息配置好。</p><p><img src="/uploads/190222java3/7.png" alt=""></p><p>注意这里点击下一步的时候失败了，使用docker ps命令发现mysql镜像并没有执行，再次执行run发现启动报错。</p><p><img src="/uploads/190222java3/8.png" alt=""></p><p>因为本机有mysql服务正在使用，3306端口是占用状态的，将3306改为3307即可。<br>再下一页配置好网站信息，jpress网站即搭建成功可以正常使用了。</p><p><img src="/uploads/190222java3/9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;制作镜像Dockerfile&quot;&gt;&lt;a href=&quot;#制作镜像Dockerfile&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="服务器" scheme="http://www.herobin.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>docker运行nginx镜像</title>
    <link href="http://www.herobin.top/2019/02/22/docker%E8%BF%90%E8%A1%8Cnginx%E9%95%9C%E5%83%8F/"/>
    <id>http://www.herobin.top/2019/02/22/docker运行nginx镜像/</id>
    <published>2019-02-22T08:09:17.000Z</published>
    <updated>2019-03-02T08:38:45.258Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="mac下安装docker">TOC</a></p><p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h1 id="下载并运行nginx镜像"><a href="#下载并运行nginx镜像" class="headerlink" title="下载并运行nginx镜像"></a>下载并运行nginx镜像</h1><p>在网易云的镜像中心找到nginx的镜像<br><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163yun.com/hub#/m/home/</a></p><p>复制nginx的下载地址：hub.c.163.com/library/nginx:latest<br>使用<code>docker pull hub.c.163.com/library/nginx:latest</code><br>下载nginx镜像到本地</p><p>这时再使用<code>docker images</code>可以查看到本地已有的nignx镜像</p><p>使用<code>docker run hub.c.163.com/library/nginx</code><br>发现没有任何输出，新建窗口输入<code>docker ps</code>可以查看本机当前运行的所有容器。</p><p><img src="/uploads/190222java2/1.png" alt=""></p><p>这时只要通过<code>ctrl+c</code>既可以停止程序，所以我们通常推荐在后台运行镜像 通过加 <code>-d</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d hub.c.163.com/library/nginx</span><br></pre></td></tr></table></figure></p><p>运行后可以通过docker exec命令进入指定镜像：</p><p><img src="/uploads/190222java2/3.png" alt=""></p><p>可以看到</p><blockquote><ol><li>docker run nginx镜像成功后返回一串此镜像运行的唯一标识id。</li><li>通过docker exec –help查看 docker exec命令帮助。</li><li>通过docker exec -it 603 bash来进入已运行的nginx镜像  这里只输入了604因为已经可以唯一标识确定，若不能再多输。</li><li>可通过exit命令退出镜像。</li><li>可以使用docker stop 603命令来结束nginx镜像的运行。</li></ol></blockquote><h1 id="网络访问nginx"><a href="#网络访问nginx" class="headerlink" title="网络访问nginx"></a>网络访问nginx</h1><p>运行了docker中的nginx后要怎样才能在网络（浏览器）中访问到nginx呢？</p><h2 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a>docker网络类型</h2><blockquote><ul><li><ol><li>bridge模式（桥接，默认类型，实现网络独立性）：docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</li></ol></li><li><ol start="2"><li>host模式：容器不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</li></ol></li><li><ol start="3"><li>none模式：Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。docker将不会和外界的任何网络进行通讯。</li></ol></li><li><ol start="4"><li>container模式：新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</li></ol></li></ul></blockquote><h2 id="进行访问"><a href="#进行访问" class="headerlink" title="进行访问"></a>进行访问</h2><blockquote><p>docker启动 -p 的使用： docker run -d -p 主机端口:容器端口 容器的名称<br>docker启动  -P 的使用（所有的监听端口都会和主机建立一个映射）： docker run -d -P 容器名称<br>停止docker：docker stop 容器Id</p></blockquote><p><strong>-p 的使用</strong> (注意这里是小写的p，下面是大写的P)</p><p><img src="/uploads/190222java2/4.png" alt=""></p><p><img src="/uploads/190222java2/5.png" alt=""></p><p><strong>-P 的使用</strong></p><p><img src="/uploads/190222java2/6.png" alt=""></p><p><img src="/uploads/190222java2/7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;mac下安装docker&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;下载并运行nginx镜像&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="服务器" scheme="http://www.herobin.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="docker" scheme="http://www.herobin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>centos下安装docker</title>
    <link href="http://www.herobin.top/2019/02/22/centos%E4%B8%8B%E5%AE%89%E8%A3%85docker/"/>
    <id>http://www.herobin.top/2019/02/22/centos下安装docker/</id>
    <published>2019-02-22T06:08:05.000Z</published>
    <updated>2019-02-22T06:09:06.810Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h2 id="1-检查内核版本"><a href="#1-检查内核版本" class="headerlink" title="1. 检查内核版本"></a>1. 检查内核版本</h2><p><code>uname -r</code><br>返回的值大于3.10即可。</p><h2 id="2-使用sudo或root权限的用户登录终端。"><a href="#2-使用sudo或root权限的用户登录终端。" class="headerlink" title="2. 使用sudo或root权限的用户登录终端。"></a>2. 使用sudo或root权限的用户登录终端。</h2><h2 id="3-卸载旧版本（如果安装过旧版本的话）"><a href="#3-卸载旧版本（如果安装过旧版本的话）" class="headerlink" title="3. 卸载旧版本（如果安装过旧版本的话）"></a>3. 卸载旧版本（如果安装过旧版本的话）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove docker \</span><br><span class="line">docker-common \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure><h2 id="4-安装需要的软件包"><a href="#4-安装需要的软件包" class="headerlink" title="4. 安装需要的软件包"></a>4. 安装需要的软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#yum-util提供yum-config-manager功能</span><br><span class="line">#另外两个是devicemapper驱动依赖的</span><br><span class="line">$ yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><h2 id="5-设置yum源"><a href="#5-设置yum源" class="headerlink" title="5. 设置yum源"></a>5. 设置yum源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="6-安装docker"><a href="#6-安装docker" class="headerlink" title="6. 安装docker"></a>6. 安装docker</h2><h3 id="6-1-安装最新版本"><a href="#6-1-安装最新版本" class="headerlink" title="6.1. 安装最新版本"></a>6.1. 安装最新版本</h3><p><code>yum install -y docker-ce</code></p><h3 id="6-2-安装指定版本"><a href="#6-2-安装指定版本" class="headerlink" title="6.2. 安装指定版本"></a>6.2. 安装指定版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查询版本列表</span><br><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">已安装的软件包</span><br><span class="line">可安装的软件包</span><br><span class="line"> * updates: mirrors.163.com</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * extras: mirrors.163.com</span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">...</span><br><span class="line">#指定版本安装(这里的例子是安装上面列表中的第二个)</span><br><span class="line">$ yum install -y docker-ce-17.09.0.ce</span><br></pre></td></tr></table></figure><h2 id="7-启动docker"><a href="#7-启动docker" class="headerlink" title="7. 启动docker"></a>7. 启动docker</h2><p><code>systemctl start docker.service</code></p><h2 id="8-验证安装是否成功（有client和service两部分表示docker安装启动都成功了）"><a href="#8-验证安装是否成功（有client和service两部分表示docker安装启动都成功了）" class="headerlink" title="8.验证安装是否成功（有client和service两部分表示docker安装启动都成功了）"></a>8.验证安装是否成功（有client和service两部分表示docker安装启动都成功了）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.09.0-ce</span><br><span class="line"> API version:  1.32</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   afdb6d4</span><br><span class="line"> Built:        Tue Sep 26 22:41:23 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.09.0-ce</span><br><span class="line"> API version:  1.32 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   afdb6d4</span><br><span class="line"> Built:        Tue Sep 26 22:42:49 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><p>原文链接：<br><a href="https://www.imooc.com/article/16448" target="_blank" rel="noopener">https://www.imooc.com/article/16448</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-检查内核版本&quot;&gt;&lt;a href=&quot;#1-检查内核版本&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="服务器" scheme="http://www.herobin.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>mac下安装docker</title>
    <link href="http://www.herobin.top/2019/02/22/mac%E4%B8%8B%E5%AE%89%E8%A3%85docker/"/>
    <id>http://www.herobin.top/2019/02/22/mac下安装docker/</id>
    <published>2019-02-22T05:50:12.000Z</published>
    <updated>2019-03-02T08:27:39.151Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="mac下安装docker">TOC</a></p><p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h1 id="mac下安装docker"><a href="#mac下安装docker" class="headerlink" title="mac下安装docker"></a>mac下安装docker</h1><h2 id="下载并安装docker"><a href="#下载并安装docker" class="headerlink" title="下载并安装docker"></a>下载并安装docker</h2><p>mac版的docker可以直接去docker官网下载桌面版，傻瓜式安装后运行docker，会发现在桌面的右上角出现了docker的图标</p><p><img src="/uploads/190222java1/1.png" alt=""></p><h2 id="验证docker"><a href="#验证docker" class="headerlink" title="验证docker"></a>验证docker</h2><p>打开终端输入命令：docker version</p><p><img src="/uploads/190222java1/2.png" alt=""></p><p>正常出现版本信息即安装成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;mac下安装docker&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;mac下安装docker&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="docker" scheme="http://www.herobin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>对null字段的两种处理</title>
    <link href="http://www.herobin.top/2019/02/14/%E5%AF%B9null%E5%AD%97%E6%AE%B5%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86/"/>
    <id>http://www.herobin.top/2019/02/14/对null字段的两种处理/</id>
    <published>2019-02-14T00:46:36.000Z</published>
    <updated>2019-02-14T00:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在查询订单列表时，有的订单详情为空返回值为null，不利于前端展示，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025663184309586&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: null</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025830175838897&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: null</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面<strong>orderDetailList</strong>的值为<strong>null</strong>。</p><p>这里我们可以给orderDTO添加注释<strong>JsonInclude</strong>来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonInclude(JsonInclude.Include.NON_NULL)</span><br></pre></td></tr></table></figure><p>这样为空的属性就不会返回给前端了，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025663184309586&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025830175838897&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在<strong>application.yml</strong>中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: herobin</span><br><span class="line">    password: Zhangbin1995@</span><br><span class="line">    url: jdbc:mysql://101.132.138.185:3306/sell?characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    hibernate.ddl-auto: update</span><br><span class="line">  # 配置所有的类只返回非空属性 </span><br><span class="line">  jackson:</span><br><span class="line">    default-property-inclusion: non_null</span><br><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /sell</span><br></pre></td></tr></table></figure><p>可是有的时候我们想要返回orderDetailList，还是值不为空，而是一个方括号。</p><p>可以在orderDTO中给orderDetailList赋初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025663184309586&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025830175838897&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，String类型和int类型也都可以通过赋初值的方法避免null问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在查询订单列表时，有的订单详情为空返回值为null，不利于前端展示，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>PageRequest过时替换</title>
    <link href="http://www.herobin.top/2019/02/13/PageRequest%E8%BF%87%E6%97%B6%E6%9B%BF%E6%8D%A2/"/>
    <id>http://www.herobin.top/2019/02/13/PageRequest过时替换/</id>
    <published>2019-02-13T04:25:35.000Z</published>
    <updated>2019-02-13T04:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用SpringbootJPA的PageRequest时提示已过时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageRequest request = new PageRequest(page, size);</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>用PageRequest.of(page, size)替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageRequest request = PageRequest.of(page, size);</span><br></pre></td></tr></table></figure><p>顺便列出一个分页的查询方法代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//订单列表</span><br><span class="line">   @GetMapping(&quot;/list&quot;)</span><br><span class="line">   public ResultVO&lt;List&lt;OrderDTO&gt;&gt; list(@RequestParam(&quot;openid&quot;) String openid,</span><br><span class="line">                                        @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) Integer page,</span><br><span class="line">                                        @RequestParam(value = &quot;size&quot;, defaultValue = &quot;10&quot;) Integer size)&#123;</span><br><span class="line">       if(StringUtils.isEmpty(openid))&#123;</span><br><span class="line">           log.error(&quot;[查询订单列表] openid为空&quot;);</span><br><span class="line">           throw new SellException(ResultEnum.PARAM_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //PageRequest已经过时 用PageRequest.of替换</span><br><span class="line">       //PageRequest request = new PageRequest(page, size);</span><br><span class="line">       PageRequest request = PageRequest.of(page, size);</span><br><span class="line">       Page&lt;OrderDTO&gt; orderDTOPage = orderService.findList(openid, request);</span><br><span class="line"></span><br><span class="line">       return ResultVOUtil.success(orderDTOPage.getContent());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>orderDTOPage中会有三个最主要的方法：</p><ul><li>getContent: 获得该页的记录集合</li><li>getTotalElements: 获得总记录条数</li><li>getTotalPages： 获得总页数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用SpringbootJPA的PageRequest时提示已过时&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot中Jpa的使用</title>
    <link href="http://www.herobin.top/2019/02/01/Springboot%E4%B8%ADJpa%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/02/01/Springboot中Jpa的使用/</id>
    <published>2019-02-01T10:57:47.000Z</published>
    <updated>2019-02-01T12:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot中可以通过使用Jpa实现dao层的简单配置，使用jpa后可以省略复杂的sql语句编写，自带简单的增删改查功能。</p><h2 id="application-yml的配置"><a href="#application-yml的配置" class="headerlink" title="application.yml的配置"></a>application.yml的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: herobin</span><br><span class="line">    password: Zhangbin1995@</span><br><span class="line">    url: jdbc:mysql://101.132.138.185:3306/sell?characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    hibernate.ddl-auto: update</span><br></pre></td></tr></table></figure><h2 id="dao类的编写"><a href="#dao类的编写" class="headerlink" title="dao类的编写"></a>dao类的编写</h2><p>dao接口直接集成JpaRepository接口即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.dao;</span><br><span class="line"></span><br><span class="line">import com.imooc.entity.ProductCategory;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/21.</span><br><span class="line"> */</span><br><span class="line">public interface ProductCategoryDao extends JpaRepository&lt;ProductCategory, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; categoryTypeList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dao层测试方法"><a href="#dao层测试方法" class="headerlink" title="dao层测试方法"></a>dao层测试方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.dao;</span><br><span class="line"></span><br><span class="line">import com.imooc.entity.ProductCategory;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Ignore;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/21.</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProductCategoryDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductCategoryDao pcDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Ignore</span><br><span class="line">    public void findOneTest()&#123;</span><br><span class="line"></span><br><span class="line">        ProductCategory productCategory = pcDao.findById(1).get();</span><br><span class="line">        System.out.println(productCategory.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findAllTest()&#123;</span><br><span class="line">        List&lt;ProductCategory&gt; pcList = pcDao.findAll();</span><br><span class="line">        for (ProductCategory pc : pcList)&#123;</span><br><span class="line">            System.out.println(pc.getCategoryName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void saveTest()&#123;</span><br><span class="line">        ProductInfo productInfo = new ProductInfo();</span><br><span class="line">        productInfo.setProductId(&quot;123456&quot;);</span><br><span class="line">        productInfo.setProductName(&quot;皮蛋粥&quot;);</span><br><span class="line">        productInfo.setProductPrice(new BigDecimal(3.2));</span><br><span class="line">        productInfo.setProductStock(100);</span><br><span class="line">        productInfo.setProductDescription(&quot;很好喝的粥&quot;);</span><br><span class="line">        productInfo.setProductIcon(&quot;xxx.png&quot;);</span><br><span class="line">        productInfo.setProductStatus(0);</span><br><span class="line">        productInfo.setCategoryType(2);</span><br><span class="line"></span><br><span class="line">        ProductInfo result = productInfoDao.save(productInfo);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findByCategoryTypeInTest()&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(2,3,4);</span><br><span class="line">        List&lt;ProductCategory&gt; result = pcDao.findByCategoryTypeIn(list);</span><br><span class="line">        Assert.assertNotEquals(0,result.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里测试了 单个查找的<code>findById()</code>方法和<code>findAll()</code>方法，注意这里的<code>findById()</code>方法返回的是<code>Optional&lt;T&gt;</code>,可以进到<code>JpaRepository</code>的<code>CrudRepository</code>里看到.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">package org.springframework.data.repository;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@NoRepositoryBean</span><br><span class="line">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; S save(S var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    Optional&lt;T&gt; findById(ID var1);</span><br><span class="line"></span><br><span class="line">    boolean existsById(ID var1);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1);</span><br><span class="line"></span><br><span class="line">    long count();</span><br><span class="line"></span><br><span class="line">    void deleteById(ID var1);</span><br><span class="line"></span><br><span class="line">    void delete(T var1);</span><br><span class="line"></span><br><span class="line">    void deleteAll(Iterable&lt;? extends T&gt; var1);</span><br><span class="line"></span><br><span class="line">    void deleteAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在findById()后我们还要用get()方法才能得到我们想要查询的对象。</p><p>查看get方法的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NoSuchElementException(&quot;No value present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当查询结果为空时会抛出异常，所以在我们的代码中不要忘记做判断抛出异常。</p><h2 id="分页方法的使用"><a href="#分页方法的使用" class="headerlink" title="分页方法的使用"></a>分页方法的使用</h2><p>使用分页方法要将返回类型定义为PageAble。</p><p>dao方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/2/1.</span><br><span class="line"> */</span><br><span class="line">public interface OrderMasterDao extends JpaRepository&lt;OrderMaster,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;OrderMaster&gt; findByBuyerOpenid(String buyerOpenId, Pageable pageable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void findByBuyerOpenId() throws Exception &#123;</span><br><span class="line">    /** PageRequest实现了PageAble接口 */</span><br><span class="line">    PageRequest pageRequest = new PageRequest(0,1);</span><br><span class="line">    Page&lt;OrderMaster&gt; request = orderMasterDao.findByBuyerOpenid(&quot;123321&quot;,pageRequest);</span><br><span class="line">    //这个是总条数 不是分页返回的条数</span><br><span class="line">    System.out.println(request.getTotalElements());</span><br><span class="line">    System.out.println(request.getContent().get(0).getBuyerName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;springboot中可以通过使用Jpa实现dao层的简单配置，使用jpa后可以省略复杂的sql语句编写，自带简单的增删改查功能。&lt;/p&gt;
&lt;h2 id=&quot;application-yml的配置&quot;&gt;&lt;a href=&quot;#application-yml的配置&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-乐观锁与悲观锁</title>
    <link href="http://www.herobin.top/2019/01/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://www.herobin.top/2019/01/21/Java多线程-乐观锁与悲观锁/</id>
    <published>2019-01-21T05:20:00.000Z</published>
    <updated>2019-01-21T05:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h1><p><strong>悲观锁</strong></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><p><strong>乐观锁</strong></p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h1 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h1><blockquote><p>乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote><h3 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子</strong>： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><blockquote><ul><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ul></blockquote><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h3 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h3><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><blockquote><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></blockquote><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p><h1 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h1><blockquote><p>ABA 问题是乐观锁一个常见的问题</p></blockquote><h3 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h3><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题</strong>。</p><p>JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就提供了此种能力，其中的 <code>compareAndSet</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h3><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h3 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p><h1 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h1><blockquote><ul><li>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），</li><li>synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</li></ul></blockquote><blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol></blockquote><p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，<strong>基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁与乐观锁&quot;&gt;&lt;/a&gt;悲观锁与乐观锁&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总是假设最坏的情况，每次去拿数据的时候都认为
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程池与Executor框架</title>
    <link href="http://www.herobin.top/2019/01/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8EExecutor%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.herobin.top/2019/01/21/Java多线程-线程池与Executor框架/</id>
    <published>2019-01-21T01:35:22.000Z</published>
    <updated>2019-01-21T03:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-使用线程池的好处"><a href="#一-使用线程池的好处" class="headerlink" title="一 使用线程池的好处"></a>一 使用线程池的好处</h1><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>使用线程池的好处（《Java并发编程的艺术》）：</p><blockquote><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul></blockquote><h1 id="二-Executor框架"><a href="#二-Executor框架" class="headerlink" title="二 Executor框架"></a>二 Executor框架</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>Executor 框架是Java5之后引进的，在Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>补充：this逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><h2 id="2-2-Executor-框架结构-主要由三大部分组成"><a href="#2-2-Executor-框架结构-主要由三大部分组成" class="headerlink" title="2.2 Executor 框架结构(主要由三大部分组成)"></a>2.2 Executor 框架结构(主要由三大部分组成)</h2><h3 id="1-任务。"><a href="#1-任务。" class="headerlink" title="1 任务。"></a>1 任务。</h3><p>执行任务需要实现的<strong>Runnable接口</strong>或<strong>Callable接口</strong>。<br><strong>Runnable接口</strong>或<strong>Callable接口</strong>实现类都可以被<strong>ThreadPoolExecutor</strong>或<strong>ScheduledThreadPoolExecutor</strong>执行。</p><p><strong>两者的区别：</strong></p><blockquote><p>Runnable接口不会返回结果但是Callable接口可以返回结果。后面介绍Executors类的一些方法的时候会介绍到两者的相互转换。</p></blockquote><h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2 任务的执行"></a>2 任务的执行</h3><p>如下图所示，包括任务执行机制的<strong>核心接口Executor</strong> ，以及继承自Executor 接口的<strong>ExecutorService接口</strong>。<strong>ScheduledThreadPoolExecutor</strong>和<strong>ThreadPoolExecutor</strong>这两个关键类实现了<strong>ExecutorService接口</strong>。</p><blockquote><p>注意： 通过查看ScheduledThreadPoolExecutor源代码我们发现ScheduledThreadPoolExecutor实际上是继承了ThreadPoolExecutor并实现了ScheduledExecutorService ，而ScheduledExecutorService又实现了ExecutorService，正如我们下面给出的类关系图显示的一样。</p></blockquote><p>ThreadPoolExecutor类描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor类描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//ScheduledExecutorService实现了ExecutorService接口</span><br><span class="line">public class ScheduledThreadPoolExecutor</span><br><span class="line">        extends ThreadPoolExecutor</span><br><span class="line">        implements ScheduledExecutorService</span><br></pre></td></tr></table></figure><p><img src="/uploads/190121java1/1.png" alt=""></p><h3 id="3-异步计算的结果"><a href="#3-异步计算的结果" class="headerlink" title="3 异步计算的结果"></a>3 异步计算的结果</h3><p><strong>Future接口</strong>以及Future接口的实现类<strong>FutureTask类</strong>。</p><p>当我们把<strong>Runnable接口</strong>或<strong>Callable接口</strong>的实现类提交（调用submit方法）给<strong>ThreadPoolExecutor</strong>或<strong>ScheduledThreadPoolExecutor</strong>时，会返回一个<strong>FutureTask对象</strong>。</p><p>我们以<strong>AbstractExecutorService接口</strong>中的一个submit方法为例子来看看源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的newTaskFor方法返回了一个FutureTask对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Executor框架的使用示意图"><a href="#2-3-Executor框架的使用示意图" class="headerlink" title="2.3 Executor框架的使用示意图"></a>2.3 Executor框架的使用示意图</h2><p><img src="/uploads/190121java1/2.png" alt=""></p><h3 id="1-主线程首先要创建实现Runnable或者Callable接口的任务对象。"><a href="#1-主线程首先要创建实现Runnable或者Callable接口的任务对象。" class="headerlink" title="1. 主线程首先要创建实现Runnable或者Callable接口的任务对象。"></a>1. 主线程首先要创建实现Runnable或者Callable接口的任务对象。</h3><p>备注： 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。</p><h3 id="2-然后可以把创建完成的Runnable对象直接交给ExecutorService执行"><a href="#2-然后可以把创建完成的Runnable对象直接交给ExecutorService执行" class="headerlink" title="2. 然后可以把创建完成的Runnable对象直接交给ExecutorService执行"></a>2. 然后可以把创建完成的Runnable对象直接交给ExecutorService执行</h3><p>（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callable task））。</p><p>执行execute()方法和submit()方法的区别是什么呢？</p><blockquote><ul><li>1) execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>2) submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul></blockquote><h3 id="3-如果执行ExecutorService-submit（…），ExecutorService将返回一个实现Future接口的对象"><a href="#3-如果执行ExecutorService-submit（…），ExecutorService将返回一个实现Future接口的对象" class="headerlink" title="3. 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象"></a>3. 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象</h3><p>（我们刚刚也提到过了执行execute()方法和submit()方法的区别，到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</p><h3 id="4-最后，主线程可以执行FutureTask-get-方法来等待任务执行完成。主线程也可以执行FutureTask-cancel（boolean-mayInterruptIfRunning）来取消此任务的执行。"><a href="#4-最后，主线程可以执行FutureTask-get-方法来等待任务执行完成。主线程也可以执行FutureTask-cancel（boolean-mayInterruptIfRunning）来取消此任务的执行。" class="headerlink" title="4. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。"></a>4. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</h3><h1 id="三-ThreadPoolExecutor详解"><a href="#三-ThreadPoolExecutor详解" class="headerlink" title="三 ThreadPoolExecutor详解"></a>三 ThreadPoolExecutor详解</h1><p>线程池实现类ThreadPoolExecutor是Executor框架最核心的类，先来看一下这个类中比较重要的四个属性。</p><h2 id="3-1-ThreadPoolExecutor类的四个比较重要的属性"><a href="#3-1-ThreadPoolExecutor类的四个比较重要的属性" class="headerlink" title="3.1 ThreadPoolExecutor类的四个比较重要的属性"></a>3.1 ThreadPoolExecutor类的四个比较重要的属性</h2><p><img src="/uploads/190121java1/3.png" alt=""></p><h2 id="3-2-ThreadPoolExecutor类中提供的四个构造方法"><a href="#3-2-ThreadPoolExecutor类中提供的四个构造方法" class="headerlink" title="3.2 ThreadPoolExecutor类中提供的四个构造方法"></a>3.2 ThreadPoolExecutor类中提供的四个构造方法</h2><p>我们看最长的那个，其余三个都是在这个构造方法的基础上产生（给定某些默认参数的构造方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line"></span><br><span class="line"> * @param keepAliveTime 当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，</span><br><span class="line"> *核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</span><br><span class="line"> * @param unit  keepAliveTime参数的时间单位</span><br><span class="line"> * @param workQueue 等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</span><br><span class="line"> * </span><br><span class="line"> * @param threadFactory 执行者创建新线程时使用的工厂</span><br><span class="line"> * @param handler RejectedExecutionHandler类型的变量，表示线程池的饱和策略。</span><br><span class="line"> * 如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。</span><br><span class="line"> * 线程池提供了4种策略：</span><br><span class="line">    1.AbortPolicy：直接抛出异常，这是默认策略；</span><br><span class="line">    2.CallerRunsPolicy：用调用者所在的线程来执行任务；</span><br><span class="line">    3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</span><br><span class="line">    4.DiscardPolicy：直接丢弃任务；</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-如何创建ThreadPoolExecutor"><a href="#3-3-如何创建ThreadPoolExecutor" class="headerlink" title="3.3 如何创建ThreadPoolExecutor"></a>3.3 如何创建ThreadPoolExecutor</h2><p>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</p><p>为什么呢？</p><blockquote><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><blockquote><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul></blockquote><p><strong>方式一：通过构造方法实现</strong></p><p><img src="/uploads/190121java1/4.png" alt=""></p><p><strong>方式二：通过Executor 框架的工具类Executors来实现</strong></p><p>我们可以创建三种类型的ThreadPoolExecutor：</p><blockquote><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul></blockquote><p>对应Executors工具类中的方法如图所示：</p><p><img src="/uploads/190121java1/5.png" alt=""></p><h2 id="3-4-FixedThreadPool详解"><a href="#3-4-FixedThreadPool详解" class="headerlink" title="3.4 FixedThreadPool详解"></a>3.4 FixedThreadPool详解</h2><p>FixedThreadPool被称为可重用固定线程数的线程池。通过Executors类中的相关源代码来看一下相关实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">   * 创建一个可重用固定数量线程的线程池</span><br><span class="line">*在任何时候至多有n个线程处于活动状态</span><br><span class="line">*如果在所有线程处于活动状态时提交其他任务，则它们将在队列中等待，</span><br><span class="line">*直到线程可用。 如果任何线程在关闭之前的执行期间由于失败而终止，</span><br><span class="line">*如果需要执行后续任务，则一个新的线程将取代它。池中的线程将一直存在</span><br><span class="line">*知道调用shutdown方法</span><br><span class="line">   * @param nThreads 线程池中的线程数</span><br><span class="line">   * @param threadFactory 创建新线程时使用的factory</span><br><span class="line">   * @return 新创建的线程池</span><br><span class="line">   * @throws NullPointerException 如果threadFactory为null</span><br><span class="line">   * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125;</span><br><span class="line">   */</span><br><span class="line">  public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外还有一个FixedThreadPool的实现方法，和上面的类似，所以这里不多做阐述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的FixedThreadPool的corePoolSize和maximumPoolSize都被设置为nThreads。</p><p><strong>FixedThreadPool的execute()方法运行示意图（该图片来源：《Java并发编程的艺术》）：</strong></p><p><img src="/uploads/190121java1/6.png" alt=""></p><p>上图说明：</p><blockquote><ul><li><ol><li>如果当前运行的线程数小于corePoolSize，则创建新的线程来执行任务；</li></ol></li><li><ol start="2"><li>当前运行的线程数等于corePoolSize后，将任务加入LinkedBlockingQueue；</li></ol></li><li><ol start="3"><li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行；</li></ol></li></ul></blockquote><p><strong>FixedThreadPool使用无界队列 LinkedBlockingQueue（队列的容量为Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响：</strong></p><blockquote><ul><li><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize；</li></ol></li><li><ol start="2"><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数；</li></ol></li><li><ol start="3"><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数；</li></ol></li><li><ol start="4"><li>运行中的FixedThreadPool（未执行shutdown()或shutdownNow()方法）不会拒绝任务</li></ol></li></ul></blockquote><h2 id="3-5-SingleThreadExecutor详解"><a href="#3-5-SingleThreadExecutor详解" class="headerlink" title="3.5 SingleThreadExecutor详解"></a>3.5 SingleThreadExecutor详解</h2><p>SingleThreadExecutor是使用单个worker线程的Executor。下面看看SingleThreadExecutor的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">   *创建使用单个worker线程运行无界队列的Executor</span><br><span class="line">*并使用提供的ThreadFactory在需要时创建新线程</span><br><span class="line">   *</span><br><span class="line">   * @param threadFactory 创建新线程时使用的factory</span><br><span class="line">   *</span><br><span class="line">   * @return 新创建的单线程Executor</span><br><span class="line">   * @throws NullPointerException 如果ThreadFactory为空</span><br><span class="line">   */</span><br><span class="line">  public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new FinalizableDelegatedExecutorService</span><br><span class="line">          (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">     return new FinalizableDelegatedExecutorService</span><br><span class="line">         (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的SingleThreadExecutor的corePoolSize和maximumPoolSize都被设置为1.其他参数和FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Intger.MAX_VALUE）。SingleThreadExecutor使用无界队列作为线程池的工作队列会对线程池带来的影响与FixedThreadPool相同。</p><p>SingleThreadExecutor的运行示意图（该图片来源：《Java并发编程的艺术》）：</p><p><img src="/uploads/190121java1/7.png" alt=""></p><p>上图说明;</p><blockquote><ul><li><ol><li>如果当前运行的线程数少于corePoolSize，则创建一个新的线程执行任务；</li></ol></li><li><ol start="2"><li>当前线程池中有一个运行的线程后，将任务加入LinkedBlockingQueue;</li></ol></li><li><ol start="3"><li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行；</li></ol></li></ul></blockquote><h2 id="3-6-CachedThreadPool详解"><a href="#3-6-CachedThreadPool详解" class="headerlink" title="3.6 CachedThreadPool详解"></a>3.6 CachedThreadPool详解</h2><p>CachedThreadPool是一个会根据需要创建新线程的线程池。下面通过源码来看看 CachedThreadPool的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它，</span><br><span class="line">*并在需要时使用提供的ThreadFactory创建新线程。</span><br><span class="line">   * @param threadFactory 创建新线程使用的factory</span><br><span class="line">   * @return 新创建的线程池</span><br><span class="line">   * @throws NullPointerException 如果threadFactory为空</span><br><span class="line">   */</span><br><span class="line">  public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                    60L, TimeUnit.SECONDS,</span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool的corePoolSize被设置为空（0），maximumPoolSize被设置为Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新的线程。极端情况下，这样会导致耗尽cpu和内存资源。</p><p>CachedThreadPool的execute()方法的执行示意图（该图片来源：《Java并发编程的艺术》）：</p><p><img src="/uploads/190121java1/8.png" alt=""></p><p>上图说明：</p><blockquote><ul><li><ol><li>首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有闲线程正在执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤2；</li></ol></li><li><ol start="2"><li>当初始maximumPool为空，或者maximumPool中没有空闲线程时，将没有线程执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤1将失败，此时CachedThreadPool会创建新线程执行任务，execute方法执行完成；</li></ol></li></ul></blockquote><h2 id="3-7-ThreadPoolExecutor使用示例"><a href="#3-7-ThreadPoolExecutor使用示例" class="headerlink" title="3.7 ThreadPoolExecutor使用示例"></a>3.7 ThreadPoolExecutor使用示例</h2><h3 id="3-7-1-示例代码"><a href="#3-7-1-示例代码" class="headerlink" title="3.7.1 示例代码"></a>3.7.1 示例代码</h3><p>首先创建一个Runnable接口的实现类（当然也可以是Callable接口，我们上面也说了两者的区别是：Runnable接口不会返回结果但是Callable接口可以返回结果。后面介绍Executors类的一些方法的时候会介绍到两者的相互转换。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span><br><span class="line"> */</span><br><span class="line">public class WorkerThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String command;</span><br><span class="line"></span><br><span class="line">    public WorkerThread(String s) &#123;</span><br><span class="line">        this.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; Start. Time = &quot; + new Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; End. Time = &quot; + new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processCommand() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以FixedThreadPool为例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个FixedThreadPool对象</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br><span class="line">            Runnable worker = new WorkerThread(&quot;&quot; + i);</span><br><span class="line">            //执行Runnable</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        //终止线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        while (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-5 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-5 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h3 id="3-7-2-shutdown（）VS-shutdownNow（）"><a href="#3-7-2-shutdown（）VS-shutdownNow（）" class="headerlink" title="3.7.2 shutdown（）VS shutdownNow（）"></a>3.7.2 shutdown（）VS shutdownNow（）</h3><p>shutdown（）方法表明关闭已在Executor上调用，因此不会再向DelayedPool添加任何其他任务（由ScheduledThreadPoolExecutor类在内部使用）。 但是，已经在队列中提交的任务将被允许完成。<br>另一方面，shutdownNow（）方法试图终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的List。</p><h3 id="3-7-3-isTerminated-Vs-isShutdown"><a href="#3-7-3-isTerminated-Vs-isShutdown" class="headerlink" title="3.7.3 isTerminated() Vs isShutdown()"></a>3.7.3 isTerminated() Vs isShutdown()</h3><p>isShutdown（）表示执行程序正在关闭，但并非所有任务都已完成执行。<br>另一方面，isShutdown（）表示所有线程都已完成执行。</p><h1 id="四-ScheduledThreadPoolExecutor详解"><a href="#四-ScheduledThreadPoolExecutor详解" class="headerlink" title="四 ScheduledThreadPoolExecutor详解"></a>四 ScheduledThreadPoolExecutor详解</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>ScheduledThreadPoolExecutor主要用来在给定的延迟后运行任务，或者定期执行任务。</p><p>ScheduledThreadPoolExecutor使用的任务队列DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask的time变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask的squenceNumber变量小的先执行)。</p><p>ScheduledThreadPoolExecutor和Timer的比较：</p><blockquote><ul><li>Timer对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；</li><li>Timer只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor可以配置任意数量的线程。 此外，如果你想（通过提供ThreadFactory），你可以完全控制创建的线程;</li><li>在TimerTask中抛出的运行时异常会杀死一个线程，从而导致Timer死机:-( …即计划任务将不再运行。ScheduledThreadExecutor不仅捕获运行时异常，还允许您在需要时处理它们（通过重写afterExecute方法 ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。</li></ul></blockquote><p>综上，在JDK1.5之后，你没有理由再使用Timer进行任务调度了。</p><blockquote><p>备注： Quartz是一个由java编写的任务调度库，由OpenSymphony组织开源出来。在实际项目开发中使用Quartz的还是居多，比较推荐使用Quartz。因为Quartz理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。</p></blockquote><h2 id="4-2-ScheduledThreadPoolExecutor运行机制"><a href="#4-2-ScheduledThreadPoolExecutor运行机制" class="headerlink" title="4.2 ScheduledThreadPoolExecutor运行机制"></a>4.2 ScheduledThreadPoolExecutor运行机制</h2><p><img src="/uploads/190121java1/9.png" alt=""></p><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p><blockquote><ol><li>当调用ScheduledThreadPoolExecutor的 scheduleAtFixedRate() 方法或者scheduleWirhFixedDelay() 方法时，会向ScheduledThreadPoolExecutor的 DelayQueue 添加一个实现了 RunnableScheduledFutur 接口的 ScheduledFutureTask 。</li><li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li></ol></blockquote><p>ScheduledThreadPoolExecutor为了实现周期性的执行任务，对ThreadPoolExecutor做了如下修改：</p><blockquote><ul><li>使用 DelayQueue 作为任务队列；</li><li>获取任务的方不同</li><li>执行周期任务后，增加了额外的处理</li></ul></blockquote><h2 id="4-3-ScheduledThreadPoolExecutor执行周期任务的步骤"><a href="#4-3-ScheduledThreadPoolExecutor执行周期任务的步骤" class="headerlink" title="4.3 ScheduledThreadPoolExecutor执行周期任务的步骤"></a>4.3 ScheduledThreadPoolExecutor执行周期任务的步骤</h2><p><img src="/uploads/190121java1/10.png" alt=""></p><blockquote><ol><li>线程1从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前系统的时间；</li><li>线程1执行这个ScheduledFutureTask；</li><li>线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间；</li><li>线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add())。</li></ol></blockquote><h2 id="4-4-ScheduledThreadPoolExecutor使用示例"><a href="#4-4-ScheduledThreadPoolExecutor使用示例" class="headerlink" title="4.4 ScheduledThreadPoolExecutor使用示例"></a>4.4 ScheduledThreadPoolExecutor使用示例</h2><blockquote><ol><li>创建一个简单的实现Runnable接口的类（我们上面的例子已经实现过）</li><li>测试程序使用ScheduledExecutorService和ScheduledThreadPoolExecutor实现的java调度。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用ScheduledExecutorService和ScheduledThreadPoolExecutor实现的java调度程序示例程序。</span><br><span class="line"> */</span><br><span class="line">public class ScheduledThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建一个ScheduledThreadPoolExecutor对象</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</span><br><span class="line">        //计划在某段时间后运行</span><br><span class="line">        System.out.println(&quot;Current Time = &quot;+new Date());</span><br><span class="line">        for(int i=0; i&lt;3; i++)&#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;);</span><br><span class="line">            //创建并执行在给定延迟后启用的单次操作。 </span><br><span class="line">            scheduledThreadPool.schedule(worker, 10, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //添加一些延迟让调度程序产生一些线程</span><br><span class="line">        Thread.sleep(30000);</span><br><span class="line">        System.out.println(&quot;Current Time = &quot;+new Date());</span><br><span class="line">        //关闭线程池</span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        while(!scheduledThreadPool.isTerminated())&#123;</span><br><span class="line">            //等待所有任务完成</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Current Time = Wed May 30 17:11:16 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:11:27 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:11:28 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:11:29 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:11:32 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:11:33 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:11:34 CST 2018</span><br><span class="line">Current Time = Wed May 30 17:11:49 CST 2018</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h3 id="4-4-1-ScheduledExecutorService-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit-方法"><a href="#4-4-1-ScheduledExecutorService-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit-方法" class="headerlink" title="4.4.1 ScheduledExecutorService scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)方法"></a>4.4.1 ScheduledExecutorService scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)方法</h3><p>我们可以使用ScheduledExecutorService scheduleAtFixedRate方法来安排任务在初始延迟后运行，然后在给定的时间段内运行。</p><p>时间段是从池中第一个线程的开始，因此如果您将period指定为1秒并且线程运行5秒，那么只要第一个工作线程完成执行，下一个线程就会开始执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;);</span><br><span class="line">// schedule task to execute at fixed rate</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(worker, 0, 10,</span><br><span class="line">TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Current Time = Wed May 30 17:47:09 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:10 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:47:11 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:47:12 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:15 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:47:16 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:47:17 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:20 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:47:21 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:47:22 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:25 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:47:26 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:47:27 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:30 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:47:31 CST 2018</span><br><span class="line">pool-1-thread-5 Start. Time = Wed May 30 17:47:32 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:35 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:47:36 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Wed May 30 17:47:37 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:40 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:47:41 CST 2018</span><br><span class="line">Current Time = Wed May 30 17:47:42 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:45 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:47:46 CST 2018</span><br><span class="line">Finished all threads</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="4-4-2-ScheduledExecutorService-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit-方法"><a href="#4-4-2-ScheduledExecutorService-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit-方法" class="headerlink" title="4.4.2 ScheduledExecutorService scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)方法"></a>4.4.2 ScheduledExecutorService scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)方法</h3><p>ScheduledExecutorService scheduleWithFixedDelay方法可用于以初始延迟启动周期性执行，然后以给定延迟执行。 延迟时间是线程完成执行的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;);</span><br><span class="line">scheduledThreadPool.scheduleWithFixedDelay(worker, 0, 1,</span><br><span class="line">TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Current Time = Wed May 30 17:58:09 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:10 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:11 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:58:12 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:15 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:16 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:16 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:58:17 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:17 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:18 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:21 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:22 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:22 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:23 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:23 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:24 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:27 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:28 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:28 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:29 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:29 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:30 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:33 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:34 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:34 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:35 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:35 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:36 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:39 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:40 CST 2018</span><br><span class="line">pool-1-thread-5 Start. Time = Wed May 30 17:58:40 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:41 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:41 CST 2018</span><br><span class="line">Current Time = Wed May 30 17:58:42 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Wed May 30 17:58:45 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:46 CST 2018</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h3 id="4-4-3-scheduleWithFixedDelay-vs-scheduleAtFixedRate"><a href="#4-4-3-scheduleWithFixedDelay-vs-scheduleAtFixedRate" class="headerlink" title="4.4.3 scheduleWithFixedDelay() vs scheduleAtFixedRate()"></a>4.4.3 scheduleWithFixedDelay() vs scheduleAtFixedRate()</h3><p>scheduleAtFixedRate（…）将延迟视为两个任务开始之间的差异（即定期调用）<br>scheduleWithFixedDelay（…）将延迟视为一个任务结束与下一个任务开始之间的差异</p><blockquote><ul><li><strong>scheduleAtFixedRate()</strong>: 创建并执行在给定的初始延迟之后，随后以给定的时间段首先启用的周期性动作; 那就是执行将在initialDelay之后开始，然后initialDelay+period ，然后是initialDelay + 2 * period ，等等。 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行人终止。 如果任务执行时间比其周期长，则后续执行可能会迟到，但不会同时执行。</li><li><strong>scheduleWithFixedDelay()</strong> : 创建并执行在给定的初始延迟之后首先启用的定期动作，随后在一个执行的终止和下一个执行的开始之间给定的延迟。 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行终止。</li></ul></blockquote><h1 id="五-各种线程池的适用场景介绍"><a href="#五-各种线程池的适用场景介绍" class="headerlink" title="五 各种线程池的适用场景介绍"></a>五 各种线程池的适用场景介绍</h1><blockquote><p><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</p></blockquote><blockquote><p><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。</p></blockquote><blockquote><p><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</p></blockquote><blockquote><p><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景，</p></blockquote><blockquote><p><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</p></blockquote><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h1><p>本节只是简单的介绍了一下使用线程池的好处，然后花了大量篇幅介绍Executor 框架。详细介绍了Executor 框架中ThreadPoolExecutor和ScheduledThreadPoolExecutor，并且通过实例详细讲解了ScheduledThreadPoolExecutor的使用。对于FutureTask 只是粗略带过，因为篇幅问题，并没有深究它的原理，后面的文章会进行补充。这一篇文章只是大概带大家过一下线程池的基本概览，深入讲解的地方不是很多，后续会通过源码深入研究其中比较重要的一些知识点。</p><p>原博链接：<a href="https://blog.csdn.net/qq_34337272/article/details/79959271" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/79959271</a> （侵权删）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-使用线程池的好处&quot;&gt;&lt;a href=&quot;#一-使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;一 使用线程池的好处&quot;&gt;&lt;/a&gt;一 使用线程池的好处&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;提供了一种限制和管理资源（包括执行一
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-Lock锁的使用</title>
    <link href="http://www.herobin.top/2019/01/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Lock%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/01/19/Java多线程-Lock锁的使用/</id>
    <published>2019-01-19T05:46:15.000Z</published>
    <updated>2019-01-19T06:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock锁的使用"><a href="#Lock锁的使用" class="headerlink" title="Lock锁的使用"></a>Lock锁的使用</h1><h2 id="一-Lock接口"><a href="#一-Lock接口" class="headerlink" title="一 Lock接口"></a>一 Lock接口</h2><h3 id="1-1-Lock接口简介"><a href="#1-1-Lock接口简介" class="headerlink" title="1.1 Lock接口简介"></a>1.1 Lock接口简介</h3><font color="red">锁是用于通过多个线程控制对共享资源的访问的工具</font>。通常，锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，一些锁可能允许并发访问共享资源，如ReadWriteLock的读写锁。<br><br><font color="red">在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的。JDK1.5之后并发包中新增了Lock接口以及相关实现类来实现锁功能。</font><p>虽然synchronized方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。例如，用于遍历并发访问的数据结构的一些算法需要使用“手动”或“链锁定”：您获取节点A的锁定，然后获取节点B，然后释放A并获取C，然后释放B并获得D等。在这种场景中synchronized关键字就不那么容易实现了，使用Lock接口容易很多。</p><p><strong>Lock接口的实现类： </strong></p><p>ReentrantLock ， ReentrantReadWriteLock.ReadLock ， ReentrantReadWriteLock.WriteLock</p><h3 id="1-2-Lock的简单使用"><a href="#1-2-Lock的简单使用" class="headerlink" title="1.2 Lock的简单使用"></a>1.2 Lock的简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock=new ReentrantLock()；</span><br><span class="line">lock.lock();</span><br><span class="line"> try&#123;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><font color="red">因为Lock是接口所以使用时要结合它的实现类，另外在finall语句块中释放锁的目的是保证获取到锁之后，最终能够被释放。</font><p>注意： 最好不要把获取锁的过程写在try语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放。</p><h3 id="1-3-Lock接口的特性和常见方法"><a href="#1-3-Lock接口的特性和常见方法" class="headerlink" title="1.3 Lock接口的特性和常见方法"></a>1.3 Lock接口的特性和常见方法</h3><p>Lock接口提供的synchronized关键字不具备的主要特性：</p><blockquote><ul><li><strong>尝试非阻塞地获取锁</strong>    当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li><li><strong>能被中断地获取锁</strong>    获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li><li><strong>超时获取锁</strong>    在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回</li></ul></blockquote><p>Lock接口基本的方法：</p><blockquote><ul><li><strong>void lock()</strong>    获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。</li><li><strong>void lockInterruptibly()</strong>    获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是在锁的获取中可以中断当前线程（相应中断）。</li><li><strong>Condition newCondition()</strong>    获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</li><li><strong>boolean tryLock()</strong> 只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为true；如果锁不可用，则此方法将立即返回值为false 。</li><li><strong>boolean tryLock(long time, TimeUnit unit)</strong>    超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false.</li><li><strong>void unlock()</strong>    释放锁。</li></ul></blockquote><h2 id="二-Lock接口的实现类：ReentrantLock"><a href="#二-Lock接口的实现类：ReentrantLock" class="headerlink" title="二 Lock接口的实现类：ReentrantLock"></a>二 Lock接口的实现类：ReentrantLock</h2><p><strong>ReentrantLock</strong>和<strong>synchronized关键字</strong>一样可以用来实现线程之间的同步互斥，但是在功能是比synchronized关键字更强大而且更灵活。</p><p><strong>ReentrantLock类常见方法：</strong></p><p>构造方法：</p><p><strong>ReentrantLock()</strong>    创建一个 ReentrantLock的实例。<br><strong>ReentrantLock(boolean fair)</strong>    创建一个特定锁类型（公平锁/非公平锁）的ReentrantLock的实例</p><p>ReentrantLock类常见方法(Lock接口已有方法这里没加上)：</p><blockquote><ul><li>int getHoldCount()    查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li><li>protected Thread getOwner()    返回当前拥有此锁的线程，如果不拥有，则返回 null</li><li>protected Collection getQueuedThreads()    返回包含可能正在等待获取此锁的线程的集合</li><li>int getQueueLength()    返回等待获取此锁的线程数的估计。</li><li>protected Collection getWaitingThreads(Condition condition)    返回包含可能在与此锁相关联的给定条件下等待的线程的集合。</li><li>int getWaitQueueLength(Condition condition)    返回与此锁相关联的给定条件等待的线程数的估计。</li><li>boolean hasQueuedThread(Thread thread)    查询给定线程是否等待获取此锁。</li><li>boolean hasQueuedThreads()    查询是否有线程正在等待获取此锁。</li><li>boolean hasWaiters(Condition condition)    查询任何线程是否等待与此锁相关联的给定条件</li><li>boolean isFair()    如果此锁的公平设置为true，则返回 true 。</li><li>boolean isHeldByCurrentThread()    查询此锁是否由当前线程持有。</li><li>boolean isLocked()    查询此锁是否由任何线程持有。</li></ul></blockquote><h3 id="2-1-第一个ReentrantLock程序"><a href="#2-1-第一个ReentrantLock程序" class="headerlink" title="2.1 第一个ReentrantLock程序"></a>2.1 第一个ReentrantLock程序</h3><p>ReentrantLockTest.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyService service = new MyService();</span><br><span class="line"></span><br><span class="line">        MyThread a1 = new MyThread(service);</span><br><span class="line">        MyThread a2 = new MyThread(service);</span><br><span class="line">        MyThread a3 = new MyThread(service);</span><br><span class="line">        MyThread a4 = new MyThread(service);</span><br><span class="line">        MyThread a5 = new MyThread(service);</span><br><span class="line"></span><br><span class="line">        a1.start();</span><br><span class="line">        a2.start();</span><br><span class="line">        a3.start();</span><br><span class="line">        a4.start();</span><br><span class="line">        a5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyService &#123;</span><br><span class="line"></span><br><span class="line">        private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        public void testMethod() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName() + (&quot; &quot; + (i + 1)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyService service;</span><br><span class="line"></span><br><span class="line">        public MyThread(MyService service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadName=Thread-0 1</span><br><span class="line">ThreadName=Thread-0 2</span><br><span class="line">ThreadName=Thread-0 3</span><br><span class="line">ThreadName=Thread-0 4</span><br><span class="line">ThreadName=Thread-0 5</span><br><span class="line">ThreadName=Thread-1 1</span><br><span class="line">ThreadName=Thread-1 2</span><br><span class="line">ThreadName=Thread-1 3</span><br><span class="line">ThreadName=Thread-1 4</span><br><span class="line">ThreadName=Thread-1 5</span><br><span class="line">ThreadName=Thread-2 1</span><br><span class="line">ThreadName=Thread-2 2</span><br><span class="line">ThreadName=Thread-2 3</span><br><span class="line">ThreadName=Thread-2 4</span><br><span class="line">ThreadName=Thread-2 5</span><br><span class="line">ThreadName=Thread-3 1</span><br><span class="line">ThreadName=Thread-3 2</span><br><span class="line">ThreadName=Thread-3 3</span><br><span class="line">ThreadName=Thread-3 4</span><br><span class="line">ThreadName=Thread-3 5</span><br><span class="line">ThreadName=Thread-4 1</span><br><span class="line">ThreadName=Thread-4 2</span><br><span class="line">ThreadName=Thread-4 3</span><br><span class="line">ThreadName=Thread-4 4</span><br><span class="line">ThreadName=Thread-4 5</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，<font color="red">当一个线程运行完毕后才把锁释放，其他线程才能执行，其他线程的执行顺序是不确定的</font>。</p><h3 id="2-2-Condition接口简介"><a href="#2-2-Condition接口简介" class="headerlink" title="2.2 Condition接口简介"></a>2.2 Condition接口简介</h3><p>我们通过之前的学习知道了：<strong>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法</strong>。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在<strong>一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活</strong>。</p><p>在使用notify/notifyAll()方法进行通知时，被通知的线程是有JVM选择的，使用ReentrantLock类结合Condition实例可以实现<strong>“选择性通知”</strong>，这个功能非常重要，而且是Condition接口默认提供的。</p><p>而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</p><p><strong>Condition接口的常见方法：</strong></p><blockquote><ul><li>void await()    相当于Object类的wait方法</li><li>boolean await(long time, TimeUnit unit)    相当于Object类的wait(long timeout)方法</li><li>signal()    相当于Object类的notify方法</li><li>signalAll()    相当于Object类的notifyAll方法</li></ul></blockquote><h3 id="2-3-使用Condition实现等待-通知机制"><a href="#2-3-使用Condition实现等待-通知机制" class="headerlink" title="2.3 使用Condition实现等待/通知机制"></a>2.3 使用Condition实现等待/通知机制</h3><p><strong>1. 使用单个Condition实例实现等待/通知机制：</strong></p><p>UseSingleConditionWaitNotify.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class UseSingleConditionWaitNotify &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyService service = new MyService();</span><br><span class="line"></span><br><span class="line">        ThreadA a = new ThreadA(service);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        service.signal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyService &#123;</span><br><span class="line"></span><br><span class="line">        private Lock lock = new ReentrantLock();</span><br><span class="line">        public Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        public void await() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot; await时间为&quot; + System.currentTimeMillis());</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(&quot;这是condition.await()方法之后的语句，condition.signal()方法之后我才被执行&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void signal() throws InterruptedException &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;signal时间为&quot; + System.currentTimeMillis());</span><br><span class="line">                condition.signal();</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;这是condition.signal()方法之后的语句&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyService service;</span><br><span class="line"></span><br><span class="line">        public ThreadA(MyService service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190119java1/1.png" alt=""></p><p><strong>在使用wait/notify实现等待通知机制的时候我们知道必须执行完notify()方法所在的synchronized代码块后才释放锁。在这里也差不多，必须执行完signal所在的try语句块之后才释放锁，condition.await()后的语句才能被执行。</strong></p><p>注意： 必须在condition.await()方法调用之前调用lock.lock()代码获得同步监视器，不然会报错。</p><p><strong>2. 使用多个Condition实例实现等待/通知机制：</strong></p><p>UseMoreConditionWaitNotify.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class UseMoreConditionWaitNotify &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyserviceMoreCondition service = new MyserviceMoreCondition();</span><br><span class="line"></span><br><span class="line">        ThreadA a = new ThreadA(service);</span><br><span class="line">        a.setName(&quot;A&quot;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = new ThreadB(service);</span><br><span class="line">        b.setName(&quot;B&quot;);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        service.signalAll_A();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyserviceMoreCondition service;</span><br><span class="line"></span><br><span class="line">        public ThreadA(MyserviceMoreCondition service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.awaitA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadB extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyserviceMoreCondition service;</span><br><span class="line"></span><br><span class="line">        public ThreadB(MyserviceMoreCondition service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.awaitB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyserviceMoreCondition.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class MyserviceMoreCondition &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    public Condition conditionA = lock.newCondition();</span><br><span class="line">    public Condition conditionB = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void awaitA() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;begin awaitA时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionA.await();</span><br><span class="line">            System.out.println(&quot;  end awaitA时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void awaitB() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;begin awaitB时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionB.await();</span><br><span class="line">            System.out.println(&quot;  end awaitB时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void signalAll_A() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;  signalAll_A时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void signalAll_B() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;  signalAll_B时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190119java1/2.png" alt=""></p><p>只有A线程被唤醒了。</p><p><strong>3. 使用Condition实现顺序执行</strong></p><p>ConditionSeqExec.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ConditionSeqExec &#123;</span><br><span class="line"></span><br><span class="line">    volatile private static int nextPrintWho = 1;</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    final private static Condition conditionA = lock.newCondition();</span><br><span class="line">    final private static Condition conditionB = lock.newCondition();</span><br><span class="line">    final private static Condition conditionC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (nextPrintWho != 1) &#123;</span><br><span class="line">                        conditionA.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;ThreadA &quot; + (i + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = 2;</span><br><span class="line">                    //通知conditionB实例的线程运行</span><br><span class="line">                    conditionB.signalAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadB = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (nextPrintWho != 2) &#123;</span><br><span class="line">                        conditionB.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;ThreadB &quot; + (i + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = 3;</span><br><span class="line">                    //通知conditionC实例的线程运行</span><br><span class="line">                    conditionC.signalAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadC = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (nextPrintWho != 3) &#123;</span><br><span class="line">                        conditionC.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;ThreadC &quot; + (i + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = 1;</span><br><span class="line">                    //通知conditionA实例的线程运行</span><br><span class="line">                    conditionA.signalAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread[] aArray = new Thread[5];</span><br><span class="line">        Thread[] bArray = new Thread[5];</span><br><span class="line">        Thread[] cArray = new Thread[5];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            aArray[i] = new Thread(threadA);</span><br><span class="line">            bArray[i] = new Thread(threadB);</span><br><span class="line">            cArray[i] = new Thread(threadC);</span><br><span class="line"></span><br><span class="line">            aArray[i].start();</span><br><span class="line">            bArray[i].start();</span><br><span class="line">            cArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br></pre></td></tr></table></figure><p>通过代码很好理解，说简单就是在一个线程运行完之后通过condition.singal()/condition.signalAll()方法通知下一个特定的线程运行，就这样循环往复即可。</p><p>注意：默认情况下ReentranLock类使用的是非公平锁。</p><p><strong>2.4 公平锁与非公平锁</strong></p><p>Lock锁分为：<strong>公平锁</strong> 和 <strong>非公平锁</strong>。公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的<strong>FIFO先进先出顺序</strong>。而非公平锁就是一种获取锁的抢占机制，是<strong>随机获取</strong>锁的，和公平锁不一样的就是先来的不一定先的到锁，这样可能造成某些线程一直拿不到锁，结果也就是不公平的了。</p><p>FairorNofairLock.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairorNofairLock &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Service service = new Service(true);//true为公平锁，false为非公平锁</span><br><span class="line"></span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;★线程&quot; + Thread.currentThread().getName()</span><br><span class="line">                        + &quot;运行了&quot;);</span><br><span class="line">                service.serviceMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread[] threadArray = new Thread[10];</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            threadArray[i] = new Thread(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            threadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static public class Service &#123;</span><br><span class="line"></span><br><span class="line">        private ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">        public Service(boolean isFair) &#123;</span><br><span class="line">            super();</span><br><span class="line">            lock = new ReentrantLock(isFair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void serviceMethod() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()</span><br><span class="line">                        + &quot;获得锁定&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">★线程Thread-0运行了</span><br><span class="line">★线程Thread-2运行了</span><br><span class="line">★线程Thread-1运行了</span><br><span class="line">ThreadName=Thread-0获得锁定</span><br><span class="line">★线程Thread-3运行了</span><br><span class="line">★线程Thread-4运行了</span><br><span class="line">★线程Thread-5运行了</span><br><span class="line">ThreadName=Thread-2获得锁定</span><br><span class="line">ThreadName=Thread-1获得锁定</span><br><span class="line">★线程Thread-6运行了</span><br><span class="line">★线程Thread-7运行了</span><br><span class="line">ThreadName=Thread-3获得锁定</span><br><span class="line">ThreadName=Thread-4获得锁定</span><br><span class="line">★线程Thread-8运行了</span><br><span class="line">ThreadName=Thread-5获得锁定</span><br><span class="line">ThreadName=Thread-6获得锁定</span><br><span class="line">ThreadName=Thread-7获得锁定</span><br><span class="line">★线程Thread-9运行了</span><br><span class="line">ThreadName=Thread-8获得锁定</span><br><span class="line">ThreadName=Thread-9获得锁定</span><br></pre></td></tr></table></figure><p>公平锁的运行结果是有序的。</p><p>把Service的参数修改为false则为非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Service service = new Service(false); //true为公平锁，false为非公平锁</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">★线程Thread-1运行了</span><br><span class="line">★线程Thread-3运行了</span><br><span class="line">★线程Thread-2运行了</span><br><span class="line">★线程Thread-0运行了</span><br><span class="line">★线程Thread-4运行了</span><br><span class="line">ThreadName=Thread-1获得锁定</span><br><span class="line">★线程Thread-5运行了</span><br><span class="line">ThreadName=Thread-5获得锁定</span><br><span class="line">★线程Thread-6运行了</span><br><span class="line">ThreadName=Thread-6获得锁定</span><br><span class="line">★线程Thread-7运行了</span><br><span class="line">ThreadName=Thread-2获得锁定</span><br><span class="line">ThreadName=Thread-3获得锁定</span><br><span class="line">★线程Thread-8运行了</span><br><span class="line">ThreadName=Thread-0获得锁定</span><br><span class="line">ThreadName=Thread-4获得锁定</span><br><span class="line">ThreadName=Thread-7获得锁定</span><br><span class="line">★线程Thread-9运行了</span><br><span class="line">ThreadName=Thread-8获得锁定</span><br><span class="line">ThreadName=Thread-9获得锁定</span><br></pre></td></tr></table></figure><p>非公平锁的运行结果是无序的。</p><h2 id="三-ReadWriteLock接口的实现类：ReentrantReadWriteLock"><a href="#三-ReadWriteLock接口的实现类：ReentrantReadWriteLock" class="headerlink" title="三 ReadWriteLock接口的实现类：ReentrantReadWriteLock"></a>三 ReadWriteLock接口的实现类：ReentrantReadWriteLock</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>我们刚刚接触到的<strong>ReentrantLock（排他锁）</strong>具有完全互斥排他的效果，即<strong>同一时刻只允许一个线程访问</strong>，这样做虽然虽然保证了实例变量的线程安全性，但效率非常低下。ReadWriteLock接口的实现类-ReentrantReadWriteLock读写锁就是为了解决这个问题。</p><p><strong>读写锁维护了两个锁，一个是读操作相关的锁也成为共享锁，一个是写操作相关的锁 也称为排他锁。通过分离读锁和写锁，其并发性比一般排他锁有了很大提升。</strong></p><p><strong>多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥（只要出现写操作的过程就是互斥的）</strong>。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。</p><h3 id="3-2-ReentrantReadWriteLock的特性与常见方法"><a href="#3-2-ReentrantReadWriteLock的特性与常见方法" class="headerlink" title="3.2 ReentrantReadWriteLock的特性与常见方法"></a>3.2 ReentrantReadWriteLock的特性与常见方法</h3><p>ReentrantReadWriteLock的特性：</p><blockquote><ul><li><strong>公平性选择</strong>    支持非公平（默认）和公平的锁获取方式，吞吐量上来看还是非公平优于公平</li><li><strong>重进入</strong>    该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁也能够同时获取读锁</li><li><strong>锁降级</strong>    遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁</li></ul></blockquote><p>ReentrantReadWriteLock常见方法： </p><p>构造方法</p><blockquote><ul><li>ReentrantReadWriteLock()    创建一个 ReentrantReadWriteLock()的实例</li><li>ReentrantReadWriteLock(boolean fair)    创建一个特定锁类型（公平锁/非公平锁）的ReentrantReadWriteLock的实例</li></ul></blockquote><p>常见方法： </p><p>和ReentrantLock类 类似。</p><h3 id="3-3-ReentrantReadWriteLock的使用"><a href="#3-3-ReentrantReadWriteLock的使用" class="headerlink" title="3.3 ReentrantReadWriteLock的使用"></a>3.3 ReentrantReadWriteLock的使用</h3><p><strong>1. 读读共享</strong></p><p>两个线程同时运行read方法，你会发现两个线程可以同时或者说是几乎同时运行lock()方法后面的代码，输出的两句话显示的时间一样。这样提高了程序的运行效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot; &quot; + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 写写互斥</strong></p><p>把上面的代码的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.readLock().lock();</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.writeLock().lock();</span><br></pre></td></tr></table></figure><p>两个线程同时运行read方法，你会发现同一时间只允许一个线程执行lock()方法后面的代码。</p><p><strong>3. 读写互斥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot; &quot; + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(&quot;获得写锁&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot; &quot; + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Service service = new Service();</span><br><span class="line"></span><br><span class="line">ThreadA a = new ThreadA(service);</span><br><span class="line">a.setName(&quot;A&quot;);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">ThreadB b = new ThreadB(service);</span><br><span class="line">b.setName(&quot;B&quot;);</span><br><span class="line">b.start();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获得读锁A 1547869177028</span><br><span class="line">获得写锁B 1547869187031</span><br></pre></td></tr></table></figure><p>第一条语句和第二条语句间隔10秒，第二条语句和结束间隔10秒，说明是互斥的。</p><p>运行两个使用同一个Service对象实例的线程a,b，线程a执行上面的read方法，线程b执行上面的write方法。你会发现同一时间只允许一个线程执行lock()方法后面的代码。记住：只要出现写操作的过程就是互斥的。</p><p><strong>4. 写读互斥</strong></p><p>和读写互斥类似。记住：只要出现写操作的过程就是互斥的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lock锁的使用&quot;&gt;&lt;a href=&quot;#Lock锁的使用&quot; class=&quot;headerlink&quot; title=&quot;Lock锁的使用&quot;&gt;&lt;/a&gt;Lock锁的使用&lt;/h1&gt;&lt;h2 id=&quot;一-Lock接口&quot;&gt;&lt;a href=&quot;#一-Lock接口&quot; class=&quot;head
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-join和ThreadLocal的使用</title>
    <link href="http://www.herobin.top/2019/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-join%E5%92%8CThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/01/18/Java多线程-join和ThreadLocal的使用/</id>
    <published>2019-01-18T03:49:38.000Z</published>
    <updated>2019-01-18T06:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是<strong>主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。另外，一个线程需要等待另一个线程也需要用到join()方法</strong>。</p><p>Thread类除了提供<strong>join()方法</strong>之外，还提供了<strong>join(long millis)、join(long millis, int nanos)</strong>两个具有超时特性的方法。这两个超时方法表示，如果线程thread在指定的超时时间没有终止，那么将会从该超时方法中返回。</p><h3 id="2-1-join方法使用"><a href="#2-1-join方法使用" class="headerlink" title="2.1 join方法使用"></a>2.1 join方法使用</h3><p><strong>不使用join方法的问题：</strong></p><p>Test.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyThread threadTest = new MyThread();</span><br><span class="line">        threadTest.start();</span><br><span class="line"></span><br><span class="line">        //Thread.sleep(?);//因为不知道子线程要花的时间这里不知道填多少时间</span><br><span class="line">        System.out.println(&quot;我想当threadTest对象执行完毕后我再执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;我想先执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/1.png" alt=""></p><p>可以看到子线程中后被执行，这里的例子只是一个简单的演示，我们想一下：<strong>假如子线程运行的结果被主线程运行需要怎么办？sleep方法？</strong>当然可以，但是子线程运行需要的时间是不确定的，所以sleep多长时间当然也就不确定了。这里就需要使用join方法解决上面的问题。</p><p><strong>使用join方法解决上面的问题：</strong></p><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyThread threadTest = new MyThread();</span><br><span class="line">        threadTest.start();</span><br><span class="line"></span><br><span class="line">        //Thread.sleep(?);//因为不知道子线程要花的时间这里不知道填多少时间</span><br><span class="line">        threadTest.join();</span><br><span class="line">        System.out.println(&quot;我想当threadTest对象执行完毕后我再执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;我想先执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅加了一句：<strong>threadTest.join()</strong>。在这里join方法的作用就是<strong>主线程需要等待子线程执行完成之后再结束</strong>。</p><h3 id="2-2-join-long-millis-方法的使用"><a href="#2-2-join-long-millis-方法的使用" class="headerlink" title="2.2 join(long millis)方法的使用"></a>2.2 join(long millis)方法的使用</h3><p>join(long millis)中的参数就是设定的等待时间。</p><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyThread threadTest = new MyThread();</span><br><span class="line">            threadTest.start();</span><br><span class="line"></span><br><span class="line">            threadTest.join(2000);// 只等2秒</span><br><span class="line">            //Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;  end timer=&quot; + System.currentTimeMillis());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;begin Timer=&quot; + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(10000);</span><br><span class="line">                System.out.println(&quot;last Timer=&quot; + System.currentTimeMillis());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/uploads/190118java3/2.png" alt=""></p><p>可以看到begin和end之间间隔两秒，end和last之间间隔八秒。<br>而且在main中不管是用threadTest.join(2000)还是Thread.sleep(2000)，begin和end的间隔都是两秒，threadTest.join(2000) 和Thread.sleep(2000) 和区别在于： <strong>Thread.sleep(2000)不会释放锁，threadTest.join(2000)会释放锁</strong> 。</p><h2 id="三-ThreadLocal的使用"><a href="#三-ThreadLocal的使用" class="headerlink" title="三 ThreadLocal的使用"></a>三 ThreadLocal的使用</h2><p>变量值的共享可以使用public static变量的形式，所有线程都使用一个public static变量。<strong>如果想实现每一个线程都有自己的共享变量该如何解决呢？</strong>JDK中提供的<strong>ThreadLocal类</strong>正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p><strong>再举个简单的例子： </strong><br>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。</p><p><strong>ThreadLocal类相关方法：</strong><br><strong>get()</strong>    返回当前线程的此线程局部变量的副本中的值。<br><strong>set(T value)</strong>    将当前线程的此线程局部变量的副本设置为指定的值<br><strong>remove()</strong>    删除此线程局部变量的当前线程的值。<br><strong>initialValue()</strong>    返回此线程局部变量的当前线程的“初始值”</p><h3 id="3-1-ThreadLocal类的初试"><a href="#3-1-ThreadLocal类的初试" class="headerlink" title="3.1 ThreadLocal类的初试"></a>3.1 ThreadLocal类的初试</h3><p>Test1.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    public static ThreadLocal&lt;String&gt; t1 = new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (t1.get() == null) &#123;</span><br><span class="line">            System.out.println(&quot;为ThreadLocal类对象放入值:aaa&quot;);</span><br><span class="line">            t1.set(&quot;aaaֵ&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.get());//aaa</span><br><span class="line">        System.out.println(t1.get());//aaa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为ThreadLocal类对象放入值:aaa</span><br><span class="line">aaaֵ</span><br><span class="line">aaaֵ</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，第一次调用ThreadLocal对象的<strong>get()方法</strong>时返回的值是<strong>null</strong>,通过调用<strong>set()方法</strong>可以为ThreadLocal对象赋值。</p><p>如果想要解决get()方法null的问题，可以使用ThreadLocal对象的<strong>initialValue方法</strong>。如下：</p><p>Test2.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public static ThreadLocalExt t1 = new ThreadLocalExt();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (t1.get() == null) &#123;</span><br><span class="line">            System.out.println(&quot;从未放过值&quot;);</span><br><span class="line">            t1.set(&quot;我的值&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.get());</span><br><span class="line">        System.out.println(t1.get());</span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadLocalExt extends ThreadLocal &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object initialValue() &#123;</span><br><span class="line">            return &quot;我是默认值 第一次get不再为null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是默认值 第一次get不再为null</span><br><span class="line">我是默认值 第一次get不再为null</span><br></pre></td></tr></table></figure><h3 id="3-2-验证线程变量间的隔离性"><a href="#3-2-验证线程变量间的隔离性" class="headerlink" title="3.2 验证线程变量间的隔离性"></a>3.2 验证线程变量间的隔离性</h3><p>Test3.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">/**</span><br><span class="line"> *TODO 验证线程变量间的隔离性</span><br><span class="line"> */</span><br><span class="line">public class Test3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(&quot;       在Main线程中取值=&quot; + Tools.tl.get());</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            ThreadA a = new ThreadA();</span><br><span class="line">            a.start();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static public class Tools &#123;</span><br><span class="line">        public static ThreadLocalExt tl = new ThreadLocalExt();</span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadLocalExt extends ThreadLocal &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object initialValue() &#123;</span><br><span class="line">            return new Date().getTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;在ThreadA线程中取值=&quot; + Tools.tl.get());</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/3.png" alt=""></p><p>从运行结果可以看出子线程和父线程各自拥有各自的值。</p><h3 id="3-3-InheritableThreadLocal"><a href="#3-3-InheritableThreadLocal" class="headerlink" title="3.3 InheritableThreadLocal"></a>3.3 InheritableThreadLocal</h3><p><strong>ThreadLocal类固然很好，但是子线程并不能取到父线程的ThreadLocal类的变量，InheritableThreadLocal类就是解决这个问题的。</strong></p><p>取父线程的值：</p><p>修改Test3.java的内部类Tools 和ThreadLocalExt类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static public class Tools &#123;</span><br><span class="line">       public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt();</span><br><span class="line">   &#125;</span><br><span class="line">   static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123;</span><br><span class="line">       @Override</span><br><span class="line">       protected Object initialValue() &#123;</span><br><span class="line">           return new Date().getTime();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/4.png" alt=""></p><p>取父线程的值并修改：</p><p>修改Test3.java的内部类Tools和InheritableThreadLocalExt类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static public class Tools &#123;</span><br><span class="line">    public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt();</span><br><span class="line">&#125;</span><br><span class="line">static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object initialValue() &#123;</span><br><span class="line">        return new Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object childValue(Object parentValue) &#123;</span><br><span class="line">        return parentValue + &quot; 我在子线程加的~!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/5.png" alt=""></p><p>在使用InheritableThreadLocal类需要注意的一点是：<strong>如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的还是旧值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Thread-join-的使用&quot;&gt;&lt;a href=&quot;#Thread-join-的使用&quot; class=&quot;headerlink&quot; title=&quot;Thread.join()的使用&quot;&gt;&lt;/a&gt;Thread.join()的使用&lt;/h2&gt;&lt;p&gt;在很多情况下，主线程生成并起动了
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-wait/notify机制</title>
    <link href="http://www.herobin.top/2019/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-wait-notify%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.herobin.top/2019/01/18/Java多线程-wait-notify机制/</id>
    <published>2019-01-18T02:30:01.000Z</published>
    <updated>2019-01-18T03:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待-通知（wait-notify）机制"><a href="#等待-通知（wait-notify）机制" class="headerlink" title="等待/通知（wait/notify）机制"></a>等待/通知（wait/notify）机制</h1><h2 id="一-等待-通知机制介绍"><a href="#一-等待-通知机制介绍" class="headerlink" title="一 等待/通知机制介绍"></a>一 等待/通知机制介绍</h2><h3 id="1-1-不使用等待-通知机制"><a href="#1-1-不使用等待-通知机制" class="headerlink" title="1.1 不使用等待/通知机制"></a>1.1 不使用等待/通知机制</h3><p>当两个线程之间存在<strong>生产和消费者关系</strong>，也就是说<strong>第一个线程（生产者）做相应的操作然后第二个线程（消费者）感知到了变化又进行相应的操作</strong>。比如像下面的whie语句一样，假设这个value值就是第一个线程操作的结果，doSomething()是第二个线程要做的事，当满足条件value=desire后才执行doSomething()。</p><p>但是这里有个问题就是：第二个语句不停的通过轮询机制来检测判断条件是否成立。<strong>如果轮询时间的间隔太小会浪费CPU资源，轮询时间的间隔太大，就可能取不到自己想要的数据。所以这里就需要我们今天讲到的等待/通知（wait/notify）机制来解决这两个矛盾</strong>。</p><pre><code>while(value=desire){    doSomething();}</code></pre><h3 id="1-2-什么是等待-通知机制？"><a href="#1-2-什么是等待-通知机制？" class="headerlink" title="1.2 什么是等待/通知机制？"></a>1.2 什么是等待/通知机制？</h3><p><strong>通俗来讲：</strong></p><p>等待/通知机制在我们生活中比比皆是，一个形象的例子就是厨师和服务员之间就存在等待/通知机制。</p><blockquote><ul><li><ol><li>厨师做完一道菜的时间是不确定的，所以菜到服务员手中的时间是不确定的； </li></ol></li><li><ol start="2"><li>服务员就需要去“等待（wait）”； </li></ol></li><li><ol start="3"><li>厨师把菜做完之后，按一下铃，这里的按铃就是“通知（nofity）”； </li></ol></li><li><ol start="4"><li>服务员听到铃声之后就知道菜做好了，他可以去端菜了。</li></ol></li></ul></blockquote><p><strong>用专业术语讲：</strong></p><p>等待/通知机制，是指一个线程A调用了对象O的<strong>wait()方法</strong>进入<strong>等待状态</strong>，而另一个线程B调用了对象O的<strong>notify()/notifyAll()方法</strong>，线程A收到通知后退出<strong>等待队列</strong>，进入可运行状态，进而执行后续操作。上诉两个线程通过对象O来完成交互，而对象上的<strong>wait()方法</strong>和<strong>notify()/notifyAll()方法</strong>的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><h3 id="1-3-等待-通知机制的相关方法"><a href="#1-3-等待-通知机制的相关方法" class="headerlink" title="1.3 等待/通知机制的相关方法"></a>1.3 等待/通知机制的相关方法</h3><p><strong>notify()</strong>    随机唤醒等待队列中等待同一共享资源的 <strong>“一个线程”</strong>，并使该线程退出等待队列，进入可运行状态，也就是<strong>notify()方法仅通知“一个线程”</strong>.</p><p><strong>notifyAll()</strong>    使所有正在等待队列中等待同一共享资源的 <strong>“全部线程”</strong> 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现.</p><p><strong>wait()</strong>    使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒</p><p><strong>wait(long)</strong>    超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回.</p><p><strong>wait(long，int)</strong>    对于超时时间更细力度的控制，可以达到纳秒.</p><h2 id="二-等待-通知机制的实现"><a href="#二-等待-通知机制的实现" class="headerlink" title="二 等待/通知机制的实现"></a>二 等待/通知机制的实现</h2><h3 id="2-1-我的第一个等待-通知机制程序"><a href="#2-1-我的第一个等待-通知机制程序" class="headerlink" title="2.1 我的第一个等待/通知机制程序"></a>2.1 我的第一个等待/通知机制程序</h3><p>MyList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class MyList &#123;</span><br><span class="line">    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        list.add(&quot;anyString&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public ThreadA(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (MyList.size() != 5) &#123;</span><br><span class="line">                    System.out.println(&quot;wait begin &quot;</span><br><span class="line">                            + System.currentTimeMillis());</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(&quot;wait end  &quot;</span><br><span class="line">                            + System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadB.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class ThreadB extends Thread &#123;</span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public ThreadB(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    MyList.add();</span><br><span class="line">                    if (MyList.size() == 5) &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        System.out.println(&quot;已发出通知！&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Object lock = new Object();</span><br><span class="line">            ThreadA a = new ThreadA(lock);</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            ThreadB b = new ThreadB(lock);</span><br><span class="line">            b.start();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java2/1.png" alt=""></p><p>可以看到：<strong>nofify()执行后并不会立即释放锁</strong>。</p><p><strong>synchronized关键字</strong>可以将任何一个Object对象作为同步对象来看待，而<strong>Java为每个Object都实现了等待/通知（wait/notify）机制的相关方法</strong>，它们必须用在synchronized关键字同步的Object的临界区内。通过调用<strong>wait()方法</strong>可以使处于临界区内的线程进入<strong>等待状态</strong>，同时<strong>释放被同步对象的锁</strong>。而notify()方法可以唤醒一个因调用wait操作而处于阻塞状态中的线程，使其进入就绪状态。被重新唤醒的线程会视图重新获得临界区的控制权也就是锁，并继续执行wait方法之后的代码。如果发出notify操作时没有处于阻塞状态中的线程，那么该命令会被忽略。</p><p>如果我们这里不通过<strong>等待/通知（wait/notify）机制</strong>实现，而是使用如下的<strong>while循环</strong>实现的话，我们上面也讲过会有很大的弊端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(MyList.size() == 5)&#123;</span><br><span class="line">       doSomething();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-线程的基本状态"><a href="#2-2-线程的基本状态" class="headerlink" title="2.2 线程的基本状态"></a>2.2 线程的基本状态</h3><p>上面我们已经提到了和线程有关的大部分API，这些API可以改变线程对象的状态。如下图所示：</p><p><img src="/uploads/190118java2/2.png" alt=""></p><blockquote><p> <strong>新建(new)</strong>：新创建了一个线程对象。 </p></blockquote><blockquote><p> <strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。 </p></blockquote><blockquote><p> <strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。 </p></blockquote><blockquote><p> <strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：</p></blockquote><blockquote><ul><li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。</li></ul></blockquote><blockquote><ul><li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li></ul></blockquote><blockquote><ul><li>其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul></blockquote><blockquote><p><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></blockquote><p><strong>备注：<br>可以用早起坐地铁来比喻这个过程：</strong></p><blockquote><ul><li>还没起床：sleeping</li></ul></blockquote><blockquote><ul><li>起床收拾好了，随时可以坐地铁出发：Runnable</li></ul></blockquote><blockquote><ul><li>等地铁来：Waiting</li></ul></blockquote><blockquote><ul><li>地铁来了，但要排队上地铁：I/O阻塞</li></ul></blockquote><blockquote><ul><li>上了地铁，发现暂时没座位：synchronized阻塞</li></ul></blockquote><blockquote><ul><li>地铁上找到座位：Running</li></ul></blockquote><blockquote><ul><li>到达目的地：Dead</li></ul></blockquote><h3 id="2-3-notify-锁不释放"><a href="#2-3-notify-锁不释放" class="headerlink" title="2.3 notify()锁不释放"></a>2.3 notify()锁不释放</h3><p><strong>当方法wait()被执行后，锁自动被释放，但执行完notify()方法后，锁不会自动释放。必须执行完notify()方法所在的synchronized代码块后才释放。</strong></p><h3 id="2-4-当interrupt方法遇到wait方法"><a href="#2-4-当interrupt方法遇到wait方法" class="headerlink" title="2.4 当interrupt方法遇到wait方法"></a>2.4 当interrupt方法遇到wait方法</h3><p><strong>当线程呈现wait状态时，对线程对象调用interrupt方法会出现interruptedException异常。</strong></p><p>service.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/17.</span><br><span class="line"> */</span><br><span class="line">public class Service &#123;</span><br><span class="line">    public void testMethod(Object lock) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(&quot;begin wait()&quot;);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(&quot;  end wait()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;出现异常了，因为呈wait状态的线程被interrupt了！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public ThreadA(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Service service = new Service();</span><br><span class="line">        service.testMethod(lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Object lock = new Object();</span><br><span class="line">            ThreadA a = new ThreadA(lock);</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            a.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java2/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;等待-通知（wait-notify）机制&quot;&gt;&lt;a href=&quot;#等待-通知（wait-notify）机制&quot; class=&quot;headerlink&quot; title=&quot;等待/通知（wait/notify）机制&quot;&gt;&lt;/a&gt;等待/通知（wait/notify）机制&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-volatile关键字</title>
    <link href="http://www.herobin.top/2019/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.herobin.top/2019/01/18/Java多线程-volatile关键字/</id>
    <published>2019-01-18T02:05:34.000Z</published>
    <updated>2019-01-18T02:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><p><strong>Java中的“volatile关键字”：</strong></p><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存（即共享内存）读取变量</strong>，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。 </p><p><img src="/uploads/190118java1/1.png" alt=""></p><p>要解决这个问题，就需要把变量声明为 <strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 </p><p><img src="/uploads/190118java1/2.png" alt=""></p><h2 id="二-volatile关键字的可见性"><a href="#二-volatile关键字的可见性" class="headerlink" title="二 volatile关键字的可见性"></a>二 volatile关键字的可见性</h2><p><strong>volatile 修饰的成员变量</strong>在每次被线程访问时，都强迫<strong>从主存（共享内存）中重读该成员变量的值</strong>。而且，当成员变量发生变化时，<strong>强迫线程将变化值回写到主存（共享内存）</strong>。这样在任何时刻，<strong>两个不同的线程总是看到某个成员变量的同一个值</strong>，这样也就保证了同步数据的<strong>可见性</strong>。</p><p>RunThread.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class RunThread extends Thread&#123;</span><br><span class="line">    private boolean isRunning = true;</span><br><span class="line">    int m;</span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setRunning(boolean isRunning) &#123;</span><br><span class="line">        this.isRunning = isRunning;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;进入run了&quot;);</span><br><span class="line">        while (isRunning == true) &#123;</span><br><span class="line">            int a=2;</span><br><span class="line">            int b=3;</span><br><span class="line">            int c=a+b;</span><br><span class="line">            m=c;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        System.out.println(&quot;线程被停止了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        RunThread thread = new RunThread();</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        thread.setRunning(false);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;已经赋值为false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java1/3.png" alt=""></p><p>RunThread类中的isRunning变量没有加上<strong>volatile关键字</strong>时，运行以上代码会出现<strong>死循环</strong>，这是因为isRunning变量虽然被修改但是没有被写到<strong>主存</strong>中，这也就导致该线程在<strong>本地内存中</strong>的值一直为true，这样就导致了死循环的产生。</p><p>解决办法也很简单：isRunning变量前加上<strong>volatile关键字</strong>即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile private boolean isRunning = true;</span><br></pre></td></tr></table></figure><p>这样运行就不会出现死循环了。<br>加上volatile关键字后的运行结果： </p><p><img src="/uploads/190118java1/4.png" alt=""></p><p>奇怪的是如果我们在while循环代码里加上任意一个输出语句或者sleep方法你会发现死循环也会停止，不管isRunning变量是否被加上volatile关键字。</p><p><img src="/uploads/190118java1/5.png" alt=""></p><p>这是为什么呢？</p><p><strong>因为：JVM会尽力保证内存的可见性，即使这个变量没有加同步关键字</strong>。换句话说，只要CPU有时间，JVM会尽力去保证变量值的更新。这种与volatile关键字的不同在于，volatile关键字会强制的保证线程的可见性。而不加这个关键字，JVM也会尽力去保证可见性，但是如果CPU一直有其他的事情在处理，它也没办法。最开始的代码，一直处于死循环中，CPU处于一直占用的状态，这个时候CPU没有时间，JVM也不能强制要求CPU分点时间去取最新的变量值。<strong>而加了输出或者sleep语句之后，CPU就有可能有时间去保证内存的可见性，于是while循环可以被终止</strong>。</p><h2 id="三-volatile关键字能保证原子性吗？"><a href="#三-volatile关键字能保证原子性吗？" class="headerlink" title="三 volatile关键字能保证原子性吗？"></a>三 volatile关键字能保证原子性吗？</h2><p>没有确切的说法，《Java并发编程艺术》这本书上说保证但是在自增操作（非原子操作）上不保证，《Java多线程编程核心艺术》这本书说不保证。不过应该是<strong>volatile无法保证对变量原子性的，要保证数据的原子性还是要使用synchronized关键字</strong>。</p><h2 id="四-synchronized关键字和volatile关键字比较"><a href="#四-synchronized关键字和volatile关键字比较" class="headerlink" title="四 synchronized关键字和volatile关键字比较"></a>四 synchronized关键字和volatile关键字比较</h2><p><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用synchronized关键字还是更多一些</strong>。</p><p><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></p><p><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></p><p><strong>volatile关键字用于解决变量在多个线程之间的可见性，而ynchronized关键字解决的是多个线程之间访问资源的同步性。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;volatile关键字&quot;&gt;&lt;a href=&quot;#volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;volatile关键字&quot;&gt;&lt;/a&gt;volatile关键字&lt;/h1&gt;&lt;h2 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-synchronized关键字</title>
    <link href="http://www.herobin.top/2019/01/17/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.herobin.top/2019/01/17/Java多线程-synchronized关键字/</id>
    <published>2019-01-17T13:19:16.000Z</published>
    <updated>2019-01-18T02:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><p>Java并发编程这个领域中<strong>synchronized关键字</strong>一直都是元老级的角色，很久之前很多人都会称它为<strong>“重量级锁”</strong>。但是，在JavaSE 1.6之后进行了主要包括为了<strong>减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁</strong>以及其它各种优化之后变得在某些情况下并不是那么重了。</p><p>本次总结不会介绍synchronized关键字的实现原理，更多的是synchronized关键字的使用。后面在看过《Java并发编程的艺术》之后会再次分析它的实现原理。</p><p>本篇博文参考出处:<br><a href="https://blog.csdn.net/qq_34337272/article/details/79655194" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/79655194</a></p><h2 id="二-变量安全性"><a href="#二-变量安全性" class="headerlink" title="二 变量安全性"></a>二 变量安全性</h2><p><strong>“非线程安全”</strong>问题存在于<strong>“实例变量”</strong>中，如果是<strong>方法内部的私有变量</strong>，则不存在<strong>“非线程安全”</strong>问题，所得结果也就是<strong>“线程安全”</strong>的了。</p><p>如果两个线程同时操作对象中的实例变量，则会出现<strong>“非线程安全”</strong>，解决办法就是在方法前加上<strong>synchronized关键字</strong>即可。</p><h2 id="三-多个对象多个锁"><a href="#三-多个对象多个锁" class="headerlink" title="三 多个对象多个锁"></a>三 多个对象多个锁</h2><p><strong>先看例子：</strong></p><p>HasSelfPrivateNum.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HasSelfPrivateNum &#123;</span><br><span class="line"></span><br><span class="line">    private int num = 0;</span><br><span class="line"></span><br><span class="line">    synchronized public void addI(String username) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (username.equals(&quot;a&quot;)) &#123;</span><br><span class="line">                num = 100;</span><br><span class="line">                System.out.println(&quot;a set over!&quot;);</span><br><span class="line">                //如果去掉hread.sleep(2000)，那么运行结果就会显示为同步的效果</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                num = 200;</span><br><span class="line">                System.out.println(&quot;b set over!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(username + &quot; num=&quot; + num);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line">    private HasSelfPrivateNum numRef;</span><br><span class="line">    public ThreadA(HasSelfPrivateNum numRef) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.numRef = numRef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        numRef.addI(&quot;a&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadB.java</span><br><span class="line">public class ThreadB extends Thread &#123;</span><br><span class="line">    private HasSelfPrivateNum numRef;</span><br><span class="line">    public ThreadB(HasSelfPrivateNum numRef) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.numRef = numRef;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        numRef.addI(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Run.java</span><br><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HasSelfPrivateNum numRef1 = new HasSelfPrivateNum();</span><br><span class="line">        HasSelfPrivateNum numRef2 = new HasSelfPrivateNum();</span><br><span class="line">        ThreadA athread = new ThreadA(numRef1);</span><br><span class="line">        athread.start();</span><br><span class="line">        ThreadB bthread = new ThreadB(numRef2);</span><br><span class="line">        bthread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：（a num=100停顿一会才执行出来）</p><p><img src="/uploads/190117java1/1.png" alt=""></p><p>（按说定义了synchronized，应该等a执行完才执行b的啊，往下看。。。）</p><p>上面实例中两个线程ThreadA和ThreadB分别访问同一个类的不同实例的相同名称的同步方法，但是效果确实异步执行。</p><p><strong>为什么会这样呢？</strong></p><p>这是因为<strong>synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁</strong>。所以在上面的实例中，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法<strong>所属对象的锁Lock</strong>，那么其他线程只能呈等待状态，<strong>前提是多个线程访问的是同一个对象</strong>。本例中很显然是两个对象。</p><p>在本例中创建了两个HasSelfPrivateNum类对象，所以就<strong>产生了两个锁</strong>。当ThreadA的引用执行到addI方法中的runThread.sleep(2000)语句时，ThreadB就会<strong>“乘机执行”</strong>。所以才会导致执行结果如上图所示（备注：由于runThread.sleep(2000)，“a num=100”停顿了两秒才输出）</p><h2 id="四-synchronized方法与锁对象"><a href="#四-synchronized方法与锁对象" class="headerlink" title="四 synchronized方法与锁对象"></a>四 synchronized方法与锁对象</h2><p>通过上面我们知道<strong>synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁</strong>。如果多个线程访问的是同一个对象，哪个线程先执行带synchronized关键字的方法，则哪个线程就持有该方法，那么其他线程只能呈等待状态。如果多个线程访问的是多个对象则不一定，因为多个对象会产生多个锁。</p><p><strong>那么我们思考一下当多个线程访问的是同一个对象中的非synchronized类型方法会是什么效果？</strong></p><p>答案是：会异步调用非synchronized类型方法，解决办法也很简单在非synchronized类型方法前加上synchronized关键字即可。</p><h2 id="五-脏读"><a href="#五-脏读" class="headerlink" title="五 脏读"></a>五 脏读</h2><p>发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过。</p><p>PublicVar.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PublicVar &#123;</span><br><span class="line"></span><br><span class="line">    public String username = &quot;A&quot;;</span><br><span class="line">    public String password = &quot;AA&quot;;</span><br><span class="line"></span><br><span class="line">    synchronized public void setValue(String username, String password) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.username = username;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            this.password = password;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;setValue method thread name=&quot;</span><br><span class="line">                    + Thread.currentThread().getName() + &quot; username=&quot;</span><br><span class="line">                    + username + &quot; password=&quot; + password);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //该方法前加上synchronized关键字就同步了</span><br><span class="line">    public void getValue() &#123;</span><br><span class="line">        System.out.println(&quot;getValue method thread name=&quot;</span><br><span class="line">                + Thread.currentThread().getName() + &quot; username=&quot; + username</span><br><span class="line">                + &quot; password=&quot; + password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadA.java</span><br><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private PublicVar publicVar;</span><br><span class="line"></span><br><span class="line">    public ThreadA(PublicVar publicVar) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.publicVar = publicVar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        publicVar.setValue(&quot;B&quot;, &quot;BB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Test.java</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            PublicVar publicVarRef = new PublicVar();</span><br><span class="line">            ThreadA thread = new ThreadA(publicVarRef);</span><br><span class="line">            thread.start();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(200);//打印结果受此值大小影响</span><br><span class="line"></span><br><span class="line">            publicVarRef.getValue();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/2.png" alt=""></p><p>解决办法：getValue()方法前加上synchronized关键字即可。</p><p>加上后运行结果：</p><p><img src="/uploads/190117java1/3.png" alt=""></p><h2 id="六-synchronized锁重入"><a href="#六-synchronized锁重入" class="headerlink" title="六 synchronized锁重入"></a>六 synchronized锁重入</h2><p><strong>“可重入锁”</strong>概念是：<strong>自己可以再次获取自己的内部锁</strong>。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。</p><p>Service.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Service &#123;</span><br><span class="line">    synchronized public void service1() &#123;</span><br><span class="line">        System.out.println(&quot;service1&quot;);</span><br><span class="line">        service2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized public void service2() &#123;</span><br><span class="line">        System.out.println(&quot;service2&quot;);</span><br><span class="line">        service3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized public void service3() &#123;</span><br><span class="line">        System.out.println(&quot;service3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Service service = new Service();</span><br><span class="line">        service.service1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread t = new MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/4.png" alt=""></p><p>另外<strong>可重入锁也支持在父子类继承的环境中</strong></p><p>Main.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public int i = 10;</span><br><span class="line"></span><br><span class="line">    synchronized public void operateIMainMethod() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            i--;</span><br><span class="line">            System.out.println(&quot;main print i=&quot; + i);</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sub.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Sub extends Main &#123;</span><br><span class="line"></span><br><span class="line">    synchronized public void operateISubMethod() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            while (i &gt; 0) &#123;</span><br><span class="line">                i--;</span><br><span class="line">                System.out.println(&quot;sub print i=&quot; + i);</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">                this.operateIMainMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        sub.operateISubMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyThread t = new MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/5.png" alt=""></p><p>说明当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法。</p><p>另外出现异常时，其锁持有的锁会自动释放。</p><h2 id="七-同步不具有继承性"><a href="#七-同步不具有继承性" class="headerlink" title="七 同步不具有继承性"></a>七 同步不具有继承性</h2><p>如果父类有一个带synchronized关键字的方法，子类继承并重写了这个方法。<br>但是同步不能继承，所以还是需要在子类方法中添加synchronized关键字。</p><h1 id="synchronized同步语句块"><a href="#synchronized同步语句块" class="headerlink" title="synchronized同步语句块"></a>synchronized同步语句块</h1><h2 id="一-synchronized方法的缺点"><a href="#一-synchronized方法的缺点" class="headerlink" title="一 synchronized方法的缺点"></a>一 synchronized方法的缺点</h2><p>使用<strong>synchronized关键字</strong>声明方法有些时候是有很大的弊端的，比如我们有两个线程一个线程A调用同步方法后获得锁，那么另一个线程B就需要等待A执行完，但是如果说A执行的是一个很费时间的任务的话这样就会很耗时。<br>先来看一个<strong>暴露synchronized方法的缺点实例</strong>，然后在看看如何通过<strong>synchronized同步语句块</strong>解决这个问题。</p><p>Task.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">    private String getData1;</span><br><span class="line">    private String getData2;</span><br><span class="line"></span><br><span class="line">    public synchronized void doLongTimeTask() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;begin task&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">            getData1 = &quot;长时间处理任务后从远程返回的值1 threadName=&quot;</span><br><span class="line">                    + Thread.currentThread().getName();</span><br><span class="line">            getData2 = &quot;长时间处理任务后从远程返回的值2 threadName=&quot;</span><br><span class="line">                    + Thread.currentThread().getName();</span><br><span class="line">            System.out.println(getData1);</span><br><span class="line">            System.out.println(getData2);</span><br><span class="line">            System.out.println(&quot;end task&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CommonUtils.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class CommonUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static long beginTime1;</span><br><span class="line">    public static long endTime1;</span><br><span class="line"></span><br><span class="line">    public static long beginTime2;</span><br><span class="line">    public static long endTime2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread1.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread1 extends Thread &#123;</span><br><span class="line">    private Task task;</span><br><span class="line">    public MyThread1(Task task) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        CommonUtils.beginTime1 = System.currentTimeMillis();</span><br><span class="line">        task.doLongTimeTask();</span><br><span class="line">        CommonUtils.endTime1 = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyThread2.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread2 extends Thread &#123;</span><br><span class="line">    private Task task;</span><br><span class="line">    public MyThread2(Task task) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        CommonUtils.beginTime2 = System.currentTimeMillis();</span><br><span class="line">        task.doLongTimeTask();</span><br><span class="line">        CommonUtils.endTime2 = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Task task = new Task();</span><br><span class="line"></span><br><span class="line">        MyThread1 thread1 = new MyThread1(task);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        MyThread2 thread2 = new MyThread2(task);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long beginTime = CommonUtils.beginTime1;</span><br><span class="line">        if (CommonUtils.beginTime2 &lt; CommonUtils.beginTime1) &#123;</span><br><span class="line">            beginTime = CommonUtils.beginTime2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long endTime = CommonUtils.endTime1;</span><br><span class="line">        if (CommonUtils.endTime2 &gt; CommonUtils.endTime1) &#123;</span><br><span class="line">            endTime = CommonUtils.endTime2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;耗时：&quot; + ((endTime - beginTime) / 1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/6.png" alt=""></p><p>从运行时间来看，synchronized方法的问题很明显。可以<strong>使用synchronized同步块</strong>来解决这个问题。但是要注意synchronized同步块的使用方法，如果synchronized同步块使用不好的话并不会带来效率的提升。</p><h2 id="二-synchronized（this）同步代码块的使用"><a href="#二-synchronized（this）同步代码块的使用" class="headerlink" title="二 synchronized（this）同步代码块的使用"></a>二 synchronized（this）同步代码块的使用</h2><p>修改上例中的Task.java如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Task &#123;</span><br><span class="line"></span><br><span class="line">    private String getData1;</span><br><span class="line">    private String getData2;</span><br><span class="line"></span><br><span class="line">    public void doLongTimeTask() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;begin task&quot;);</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">            String privateGetData1 = &quot;长时间处理任务后从远程返回的值1 threadName=&quot;</span><br><span class="line">                    + Thread.currentThread().getName();</span><br><span class="line">            String privateGetData2 = &quot;长时间处理任务后从远程返回的值2 threadName=&quot;</span><br><span class="line">                    + Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                getData1 = privateGetData1;</span><br><span class="line">                getData2 = privateGetData2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(getData1);</span><br><span class="line">            System.out.println(getData2);</span><br><span class="line">            System.out.println(&quot;end task&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/7.png" alt=""></p><p>从上面代码可以看出<strong>当一个线程访问一个对象的synchronized同步代码块时，另一个线程仍然可以访问该对象非synchronized同步代码块</strong>。</p><p>时间虽然缩短了，但是大家考虑一下synchronized代码块真的是同步的吗？它真的持有当前调用对象的锁吗？</p><p><strong>是的。不在synchronized代码块中就异步执行，在synchronized代码块中就是同步执行。</strong></p><h2 id="三-synchronized（object）代码块间使用"><a href="#三-synchronized（object）代码块间使用" class="headerlink" title="三 synchronized（object）代码块间使用"></a>三 synchronized（object）代码块间使用</h2><p>MyObject.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class MyObject &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Service &#123;</span><br><span class="line"></span><br><span class="line">    public void testMethod1(MyObject object) &#123;</span><br><span class="line">        synchronized (object) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;testMethod1 ____getLock time=&quot;</span><br><span class="line">                        + System.currentTimeMillis() + &quot; run ThreadName=&quot;</span><br><span class="line">                        + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">                System.out.println(&quot;testMethod1 releaseLock time=&quot;</span><br><span class="line">                        + System.currentTimeMillis() + &quot; run ThreadName=&quot;</span><br><span class="line">                        + Thread.currentThread().getName());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line">    private Service service;</span><br><span class="line">    private MyObject object;</span><br><span class="line"></span><br><span class="line">    public ThreadA(Service service, MyObject object) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.service = service;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        service.testMethod1(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadB.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadB extends Thread &#123;</span><br><span class="line">    private Service service;</span><br><span class="line">    private MyObject object;</span><br><span class="line"></span><br><span class="line">    public ThreadB(Service service, MyObject object) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.service = service;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        super.run();</span><br><span class="line">        service.testMethod1(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Service service = new Service();</span><br><span class="line">        MyObject object = new MyObject();</span><br><span class="line"></span><br><span class="line">        ThreadA a = new ThreadA(service, object);</span><br><span class="line">        a.setName(&quot;a&quot;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = new ThreadB(service, object);</span><br><span class="line">        b.setName(&quot;b&quot;);</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/8.png" alt=""></p><p>可以看出如下图所示，<strong>两个线程使用了同一个“对象监视器”，所以运行结果是同步的</strong>。</p><p>那么如果使用不同的对象监视器会出现什么情况呢？</p><p>修改Run.java：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Service service = new Service();</span><br><span class="line">        MyObject object1 = new MyObject();</span><br><span class="line">        MyObject object2 = new MyObject();</span><br><span class="line"></span><br><span class="line">        ThreadA a = new ThreadA(service, object1);</span><br><span class="line">        a.setName(&quot;a&quot;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = new ThreadB(service, object2);</span><br><span class="line">        b.setName(&quot;b&quot;);</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/10.png" alt=""></p><p>可以看出如下图所示，两个线程使用了不同的“对象监视器”，所以运行结果就不是同步的了。</p><p><img src="/uploads/190117java1/11.png" alt=""></p><h2 id="四-synchronized代码块间的同步性"><a href="#四-synchronized代码块间的同步性" class="headerlink" title="四 synchronized代码块间的同步性"></a>四 synchronized代码块间的同步性</h2><p>当一个对象访问synchronized(this)代码块时，其他线程对同一个对象中所有其他synchronized(this)代码块代码块的访问将被阻塞，这说明<strong>synchronized(this)代码块使用的“对象监视器”是一个</strong>。<br>也就是说<strong>和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的</strong>。</p><p>另外通过上面的学习我们可以得出<strong>两个结论</strong>。</p><ol><li>其他线程执行对象中synchronized同步方法和synchronized(this)代码块时呈现同步效果;</li><li>如果两个线程使用了同一个“对象监视器”,运行结果同步，否则不同步.</li></ol><h2 id="五-静态同步synchronized方法与synchronized-class-代码块"><a href="#五-静态同步synchronized方法与synchronized-class-代码块" class="headerlink" title="五 静态同步synchronized方法与synchronized(class)代码块"></a>五 静态同步synchronized方法与synchronized(class)代码块</h2><p><strong>synchronized关键字加到static静态方法和synchronized(class)代码块上都是是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。</strong></p><p>Service.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Service &#123;</span><br><span class="line"></span><br><span class="line">    public static void printA() &#123;</span><br><span class="line">        synchronized (Service.class) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(</span><br><span class="line">                        &quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printA&quot;);</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(</span><br><span class="line">                        &quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printA&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized public static void printB() &#123;</span><br><span class="line">        System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printB&quot;);</span><br><span class="line">        System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized public void printC() &#123;</span><br><span class="line">        System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;进入printC&quot;);</span><br><span class="line">        System.out.println(&quot;线程名称为：&quot; + Thread.currentThread().getName() + &quot;在&quot; + System.currentTimeMillis() + &quot;离开printC&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line">    private Service service;</span><br><span class="line">    public ThreadA(Service service) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        service.printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadB.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadB extends Thread &#123;</span><br><span class="line">    private Service service;</span><br><span class="line">    public ThreadB(Service service) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadC.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadB extends Thread &#123;</span><br><span class="line">    private Service service;</span><br><span class="line">    public ThreadB(Service service) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.service = service;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Service service = new Service();</span><br><span class="line">        ThreadA a = new ThreadA(service);</span><br><span class="line">        a.setName(&quot;A&quot;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = new ThreadB(service);</span><br><span class="line">        b.setName(&quot;B&quot;);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">        ThreadC c = new ThreadC(service);</span><br><span class="line">        c.setName(&quot;C&quot;);</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190117java1/12.png" alt=""></p><p>从运行结果可以看出:静态同步synchronized方法与synchronized(class)代码块持有的锁一样，都是<strong>Class锁，Class锁对对象的所有实例起作用。synchronized关键字加到非static静态方法上持有的是对象锁</strong>。<br>线程A,B和线程C持有的锁不一样，所以A和B运行同步，但是和C运行不同步。 </p><p><img src="/uploads/190117java1/13.png" alt=""></p><h2 id="六-数据类型String的常量池属性"><a href="#六-数据类型String的常量池属性" class="headerlink" title="六 数据类型String的常量池属性"></a>六 数据类型String的常量池属性</h2><p><strong>在Jvm中具有String常量池缓存的功能</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;a&quot;;</span><br><span class="line">String s2 = &quot;a&quot;;</span><br><span class="line">System.out.println(s1==s2);//true</span><br></pre></td></tr></table></figure><p>上面代码输出为true.<strong>这是为什么呢？</strong></p><p><strong>字符串常量池中的字符串只存在一份！ 即执行完第一行代码后，常量池中已存在 “a”，那么s2不会在常量池中申请新的空间，而是直接把已存在的字符串内存地址返回给s2。</strong></p><p>因为数据类型String的常量池属性，所以synchronized(string)在使用时某些情况下会出现一些问题，比如两个线程运行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(“abc”)｛ </span><br><span class="line">｝和 </span><br><span class="line">synchronized(“abc”)｛ </span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>修饰的方法时，这两个线程就会持有相同的锁，导致某一时刻只有一个线程能运行。所以尽量不要使用synchronized(string)而使用synchronized(object)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;synchronized关键字&quot;&gt;&lt;a href=&quot;#synchronized关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronized关键字&quot;&gt;&lt;/a&gt;synchronized关键字&lt;/h1&gt;&lt;h2 id=&quot;一-简介&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码学习</title>
    <link href="http://www.herobin.top/2019/01/15/HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.herobin.top/2019/01/15/HashMap源码学习/</id>
    <published>2019-01-15T11:34:56.000Z</published>
    <updated>2019-01-15T12:45:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p><h2 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h2><h3 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h3><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    // key.hashCode()：返回散列值也就是hashcode</span><br><span class="line">    // ^ ：按位异或</span><br><span class="line">    // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int hash(int h) &#123;</span><br><span class="line">    // This function ensures that hashCodes that differ only by</span><br><span class="line">    // constant multiples at each bit position have a bounded</span><br><span class="line">    // number of collisions (approximately 8 at default load factor).</span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span><br><span class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="/uploads/190115java1/1.png" alt=""></p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/uploads/190115java1/2.png" alt=""></p><p>类的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    // 序列号</span><br><span class="line">    private static final long serialVersionUID = 362498820763181265L;    </span><br><span class="line">    // 默认的初始容量是16</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;   </span><br><span class="line">    // 最大容量</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; </span><br><span class="line">    // 默认的填充因子</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">    // 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">    static final int TREEIFY_THRESHOLD = 8; </span><br><span class="line">    // 当桶(bucket)上的结点数小于这个值时树转链表</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">    // 桶中结构转化为红黑树对应的table的最小大小</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line">    // 存储元素的数组，总是2的幂次倍</span><br><span class="line">    transient Node&lt;k,v&gt;[] table; </span><br><span class="line">    // 存放具体元素的集</span><br><span class="line">    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    // 存放元素的个数，注意这个不等于数组的长度。</span><br><span class="line">    transient int size;</span><br><span class="line">    // 每次扩容和更改map结构的计数器</span><br><span class="line">    transient int modCount;   </span><br><span class="line">    // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span><br><span class="line">    int threshold;</span><br><span class="line">    // 填充因子</span><br><span class="line">    final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>loadFactor加载因子</strong></li></ul></blockquote><blockquote><p> loadFactor加载因子是控制数组存放数组的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load Factor越小，也就是趋近于0</p></blockquote><blockquote><p>  <strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 　</strong></p></blockquote><blockquote><ul><li><strong>threshold</strong></li></ul></blockquote><blockquote><p>  threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准。</strong></p></blockquote><p><strong>Node节点类源码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 继承自 Map.Entry&lt;K,V&gt;</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br><span class="line">       final K key;//键</span><br><span class="line">       V value;//值</span><br><span class="line">       // 指向下一个节点</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line">        // 重写hashCode()方法</span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 重写 equals() 方法</span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o == this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树节点类源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; parent;  // 父</span><br><span class="line">       TreeNode&lt;K,V&gt; left;    // 左</span><br><span class="line">       TreeNode&lt;K,V&gt; right;   // 右</span><br><span class="line">       TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">       boolean red;           // 判断颜色</span><br><span class="line">       TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           super(hash, key, val, next);</span><br><span class="line">       &#125;</span><br><span class="line">       // 返回根节点</span><br><span class="line">       final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">           for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">               if ((p = r.parent) == null)</span><br><span class="line">                   return r;</span><br><span class="line">               r = p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 默认构造函数。</span><br><span class="line">// 加载因子默认初值 0.75f</span><br><span class="line">  public More ...HashMap() &#123;</span><br><span class="line">      this.loadFactor = DEFAULT_LOAD_FACTOR; // all   other fields defaulted</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 包含另一个“Map”的构造函数</span><br><span class="line">   public More ...HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">       this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, false);//下面会分析到这个方法</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 指定“容量大小”的构造函数</span><br><span class="line">   public More ...HashMap(int initialCapacity) &#123;</span><br><span class="line">       this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 指定“容量大小”和“加载因子”的构造函数</span><br><span class="line">   public More ...HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">       if (initialCapacity &lt; 0)</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);</span><br><span class="line">       if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);</span><br><span class="line">       this.loadFactor = loadFactor;</span><br><span class="line">       this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">    int s = m.size();</span><br><span class="line">    if (s &gt; 0) &#123;</span><br><span class="line">        // 判断table是否已经初始化</span><br><span class="line">        if (table == null) &#123; // pre-size</span><br><span class="line">            // 未初始化，s为m的实际元素个数</span><br><span class="line">            float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            // 计算得到的t大于阈值，则初始化阈值</span><br><span class="line">            if (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        // 已初始化，并且m元素个数大于阈值，进行扩容处理</span><br><span class="line">        else if (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        // 将m中的所有元素添加至HashMap中</span><br><span class="line">        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, false, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p>对putVal方法添加元素的分析如下：</p><blockquote><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入。</li></ul></blockquote><p><img src="/uploads/190115java1/3.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // table未初始化或者长度为0，进行扩容</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    // 桶中已经存在元素</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                // 将第一个元素赋值给e，用e来记录</span><br><span class="line">                e = p;</span><br><span class="line">        // hash值不相等，即key不相等；为红黑树结点</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            // 放入树中</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        // 为链表结点</span><br><span class="line">        else &#123;</span><br><span class="line">            // 在链表最末插入结点</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // 到达链表的尾部</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    // 在尾部插入新结点</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    // 结点数量达到阈值，转化为红黑树</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    // 跳出循环</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 判断链表中结点的key值与插入的元素的key值是否相等</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    // 相等，跳出循环</span><br><span class="line">                    break;</span><br><span class="line">                // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 表示在桶中找到key值、hash值与插入元素相等的结点</span><br><span class="line">        if (e != null) &#123; </span><br><span class="line">            // 记录e的value</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            // onlyIfAbsent为false或者旧值为null</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                //用新值替换旧值</span><br><span class="line">                e.value = value;</span><br><span class="line">            // 访问后回调</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            // 返回旧值</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 结构性修改</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 实际大小大于阈值则扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    // 插入后回调</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来对比一下 JDK1.7 put方法的代码</p><p>对于put方法的分析如下：</p><blockquote><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value)</span><br><span class="line">    if (table == EMPTY_TABLE) &#123; </span><br><span class="line">    inflateTable(threshold); </span><br><span class="line">&#125;  </span><br><span class="line">    if (key == null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    int hash = hash(key);</span><br><span class="line">    int i = indexFor(hash, table.length);</span><br><span class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  // 再插入</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 数组元素相等</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        // 桶中不止一个节点</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            // 在树中get</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            // 在链表中get</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没超过最大值，就扩充为原来的2倍</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123; </span><br><span class="line">        signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算新的resize上限</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        // 把每个bucket都移动到新的buckets中</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 原索引</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 原索引+oldCap</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原索引放到bucket里</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 原索引+oldCap放到bucket里</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package map;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class HashMapDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        // 键不能重复，值可以重复</span><br><span class="line">        map.put(&quot;san&quot;, &quot;张三&quot;);</span><br><span class="line">        map.put(&quot;si&quot;, &quot;李四&quot;);</span><br><span class="line">        map.put(&quot;wu&quot;, &quot;王五&quot;);</span><br><span class="line">        map.put(&quot;wang&quot;, &quot;老王&quot;);</span><br><span class="line">        map.put(&quot;wang&quot;, &quot;老王2&quot;);// 老王被覆盖</span><br><span class="line">        map.put(&quot;lao&quot;, &quot;老王&quot;);</span><br><span class="line">        System.out.println(&quot;-------直接输出hashmap:-------&quot;);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        /**</span><br><span class="line">         * 遍历HashMap</span><br><span class="line">         */</span><br><span class="line">        // 1.获取Map中的所有键</span><br><span class="line">        System.out.println(&quot;-------foreach获取Map中所有的键:------&quot;);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();//换行</span><br><span class="line">        // 2.获取Map中所有值</span><br><span class="line">        System.out.println(&quot;-------foreach获取Map中所有的值:------&quot;);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        for (String value : values) &#123;</span><br><span class="line">            System.out.print(value+&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();//换行</span><br><span class="line">        // 3.得到key的值的同时得到key所对应的值</span><br><span class="line">        System.out.println(&quot;-------得到key的值的同时得到key所对应的值:-------&quot;);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        for (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + &quot;：&quot; + map.get(key)+&quot;   &quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        /**</span><br><span class="line">         * 另外一种不常用的遍历方式</span><br><span class="line">         */</span><br><span class="line">        // 当我调用put(key,value)方法的时候，首先会把key和value封装到</span><br><span class="line">        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span><br><span class="line">        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span><br><span class="line">        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /**</span><br><span class="line">         * HashMap其他常用方法</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;after map.size()：&quot;+map.size());</span><br><span class="line">        System.out.println(&quot;after map.isEmpty()：&quot;+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(&quot;san&quot;));</span><br><span class="line">        System.out.println(&quot;after map.remove()：&quot;+map);</span><br><span class="line">        System.out.println(&quot;after map.get(si)：&quot;+map.get(&quot;si&quot;));</span><br><span class="line">        System.out.println(&quot;after map.containsKey(si)：&quot;+map.containsKey(&quot;si&quot;));</span><br><span class="line">        System.out.println(&quot;after containsValue(李四)：&quot;+map.containsValue(&quot;李四&quot;));</span><br><span class="line">        System.out.println(map.replace(&quot;si&quot;, &quot;李四2&quot;));</span><br><span class="line">        System.out.println(&quot;after map.replace(si, 李四2):&quot;+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HashMap简介&quot;&gt;&lt;a href=&quot;#HashMap简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap简介&quot;&gt;&lt;/a&gt;HashMap简介&lt;/h2&gt;&lt;p&gt;HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="源码" scheme="http://www.herobin.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码学习</title>
    <link href="http://www.herobin.top/2019/01/14/LinkedList%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.herobin.top/2019/01/14/LinkedList源码学习/</id>
    <published>2019-01-14T06:24:50.000Z</published>
    <updated>2019-01-14T07:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list=Collections.synchronizedList(new LinkedList(...));</span><br></pre></td></tr></table></figure><h2 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a>内部结构分析</h2><p><img src="/uploads/190114java1/1.png" alt=""></p><p>结合上图和LinkedList类中的内部私有类Node就很好理解了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">       E item;//节点值</span><br><span class="line">       Node&lt;E&gt; next;//后继节点</span><br><span class="line">       Node&lt;E&gt; prev;//前驱节点</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           this.item = element;</span><br><span class="line">           this.next = next;</span><br><span class="line">           this.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p><h2 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>空构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用已有的集合创建链表的构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a>add()方法</h3><p>add(E e)方法：将元素添加到链表尾部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       linkLast(e);//这里就只调用了这一个方法</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">  /**</span><br><span class="line">    * 链接使e作为最后一个元素。</span><br><span class="line">    */</span><br><span class="line">   void linkLast(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">       last = newNode;//新建节点</span><br><span class="line">       if (l == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           l.next = newNode;//指向后继元素也就是指向下一个元素</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>add(int index, E e)：在指定位置添加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       checkPositionIndex(index); //检查索引是否处于[0-size]之间</span><br><span class="line"></span><br><span class="line">       if (index == size)//添加在链表尾部</span><br><span class="line">           linkLast(element);</span><br><span class="line">       else//添加在链表中间</span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node</p><p>addAll(Collection c )：将集合插入到链表尾部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        return addAll(size, c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>addAll(int index, Collection c)： 将集合从指定位置开始插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        //1:检查index范围是否在size之内</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        //2:toArray()方法把集合的数据存到对象数组中</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        if (numNew == 0)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        //3：得到插入位置的前驱节点和后继节点</span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        //如果插入位置为尾部，前驱节点为last，后继节点为null</span><br><span class="line">        if (index == size) &#123;</span><br><span class="line">            succ = null;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，调用node()方法得到后继节点，再得到前驱节点</span><br><span class="line">        else &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4：遍历数据将数据插入</span><br><span class="line">        for (Object o : a) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">            //创建新节点</span><br><span class="line">            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">            //如果插入位置在链表头部</span><br><span class="line">            if (pred == null)</span><br><span class="line">                first = newNode;</span><br><span class="line">            else</span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果插入位置在尾部，重置last节点</span><br><span class="line">        if (succ == null) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125;</span><br><span class="line">        //否则，将插入的链表与先前链表连接起来</span><br><span class="line">        else &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面可以看出addAll方法通常包括下面四个步骤：</p><blockquote><ul><li>检查index范围是否在size之内</li><li>toArray()方法把集合的数据存到对象数组中</li><li>得到插入位置的前驱和后继节点</li><li>遍历数据，将数据插入到指定位置</li></ul></blockquote><p>addFirst(E e)： 将元素添加到链表头部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">       linkFirst(e);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点</span><br><span class="line">       first = newNode;</span><br><span class="line">       //如果链表为空，last节点也指向该节点</span><br><span class="line">       if (f == null)</span><br><span class="line">           last = newNode;</span><br><span class="line">       //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span><br><span class="line">       else</span><br><span class="line">           f.prev = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>addLast(E e)： 将元素添加到链表尾部，与 add(E e) 方法一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void addLast(E e) &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h3><p>get(int index)：：根据指定索引返回数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">       //检查index范围是否在size之内</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       //调用Node(index)去找到index对应的node然后返回它的值</span><br><span class="line">       return node(index).item;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>获取头节点（index=0）数据方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        if (f == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return f.item;</span><br><span class="line">    &#125;</span><br><span class="line">public E element() &#123;</span><br><span class="line">        return getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E peek() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : f.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public E peekFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : f.item;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>区别： getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中getFirst() 和element() 方法将会在链表为空时，抛出异常</p><p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException </p><p>获取尾节点（index=-1）数据方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E getLast() &#123;</span><br><span class="line">      final Node&lt;E&gt; l = last;</span><br><span class="line">      if (l == null)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">      return l.item;</span><br><span class="line">  &#125;</span><br><span class="line">public E peekLast() &#123;</span><br><span class="line">      final Node&lt;E&gt; l = last;</span><br><span class="line">      return (l == null) ? null : l.item;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>两者区别： getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只是会返回 null。</p><h3 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a>根据对象得到索引的方法</h3><p>int indexOf(Object o)： 从头遍历找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            //从头遍历</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                if (x.item == null)</span><br><span class="line">                    return index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //从头遍历</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                if (o.equals(x.item))</span><br><span class="line">                    return index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>int lastIndexOf(Object o)： 从尾遍历找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">        int index = size;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            //从尾遍历</span><br><span class="line">            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                if (x.item == null)</span><br><span class="line">                    return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //从尾遍历</span><br><span class="line">            for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                if (o.equals(x.item))</span><br><span class="line">                    return index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="检查链表是否包含某对象的方法："><a href="#检查链表是否包含某对象的方法：" class="headerlink" title="检查链表是否包含某对象的方法："></a>检查链表是否包含某对象的方法：</h3><p>contains(Object o)： 检查对象o是否存在于链表中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">      return indexOf(o) != -1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>删除方法 remove() ,removeFirst(),pop(): 删除头节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E pop() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        return removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        if (f == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkFirst(f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>removeLast(),pollLast(): 删除尾节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       if (l == null)</span><br><span class="line">           throw new NoSuchElementException();</span><br><span class="line">       return unlinkLast(l);</span><br><span class="line">   &#125;</span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">       final Node&lt;E&gt; l = last;</span><br><span class="line">       return (l == null) ? null : unlinkLast(l);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>区别： removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p>remove(Object o): 删除指定元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">        //如果删除对象为null</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            //从头开始遍历</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                //找到元素</span><br><span class="line">                if (x.item == null) &#123;</span><br><span class="line">                   //从链表中移除找到的元素</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //从头开始遍历</span><br><span class="line">            for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;</span><br><span class="line">                //找到元素</span><br><span class="line">                if (o.equals(x.item)) &#123;</span><br><span class="line">                    //从链表中移除找到的元素</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p><p>unlink(Node x) 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">       // assert x != null;</span><br><span class="line">       final E element = x.item;</span><br><span class="line">       final Node&lt;E&gt; next = x.next;//得到后继节点</span><br><span class="line">       final Node&lt;E&gt; prev = x.prev;//得到前驱节点</span><br><span class="line"></span><br><span class="line">       //删除前驱指针</span><br><span class="line">       if (prev == null) &#123;</span><br><span class="line">           first = next;如果删除的节点是头节点,令头节点指向该节点的后继节点</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           prev.next = next;//将前驱节点的后继节点指向后继节点</span><br><span class="line">           x.prev = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //删除后继指针</span><br><span class="line">       if (next == null) &#123;</span><br><span class="line">           last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           next.prev = prev;</span><br><span class="line">           x.next = null;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       x.item = null;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       return element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>remove(int index)：删除指定位置的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">       //检查index范围</span><br><span class="line">       checkElementIndex(index);</span><br><span class="line">       //将节点删除</span><br><span class="line">       return unlink(node(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a>LinkedList类常用方法测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">package list;</span><br><span class="line"></span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LinkedListDemo &#123;</span><br><span class="line">    public static void main(String[] srgs) &#123;</span><br><span class="line">        //创建存放int类型的linkedList</span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;();</span><br><span class="line">        /************************** linkedList的基本操作 ************************/</span><br><span class="line">        linkedList.addFirst(0); // 添加元素到列表开头</span><br><span class="line">        linkedList.add(1); // 在列表结尾添加元素</span><br><span class="line">        linkedList.add(2, 2); // 在指定位置添加元素</span><br><span class="line">        linkedList.addLast(3); // 添加元素到列表结尾</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;LinkedList（直接输出的）: &quot; + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;getFirst()获得第一个元素: &quot; + linkedList.getFirst()); // 返回此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;getLast()获得第最后一个元素: &quot; + linkedList.getLast()); // 返回此列表的最后一个元素</span><br><span class="line">        System.out.println(&quot;removeFirst()删除第一个元素并返回: &quot; + linkedList.removeFirst()); // 移除并返回此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;removeLast()删除最后一个元素并返回: &quot; + linkedList.removeLast()); // 移除并返回此列表的最后一个元素</span><br><span class="line">        System.out.println(&quot;After remove:&quot; + linkedList);</span><br><span class="line">        System.out.println(&quot;contains()方法判断列表是否包含1这个元素:&quot; + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true</span><br><span class="line">        System.out.println(&quot;该linkedList的大小 : &quot; + linkedList.size()); // 返回此列表的元素个数</span><br><span class="line"></span><br><span class="line">        /************************** 位置访问操作 ************************/</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素</span><br><span class="line">        System.out.println(&quot;After set(1, 3):&quot; + linkedList);</span><br><span class="line">        System.out.println(&quot;get(1)获得指定位置（这里为1）的元素: &quot; + linkedList.get(1)); // 返回此列表中指定位置处的元素</span><br><span class="line"></span><br><span class="line">        /************************** Search操作 ************************/</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.add(3);</span><br><span class="line">        System.out.println(&quot;indexOf(3): &quot; + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引</span><br><span class="line">        System.out.println(&quot;lastIndexOf(3): &quot; + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引</span><br><span class="line"></span><br><span class="line">        /************************** Queue操作 ************************/</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;peek(): &quot; + linkedList.peek()); // 获取但不移除此列表的头</span><br><span class="line">        System.out.println(&quot;element(): &quot; + linkedList.element()); // 获取但不移除此列表的头</span><br><span class="line">        linkedList.poll(); // 获取并移除此列表的头</span><br><span class="line">        System.out.println(&quot;After poll():&quot; + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(&quot;After remove():&quot; + linkedList); // 获取并移除此列表的头</span><br><span class="line">        linkedList.offer(4);</span><br><span class="line">        System.out.println(&quot;After offer(4):&quot; + linkedList); // 将指定元素添加到此列表的末尾</span><br><span class="line"></span><br><span class="line">        /************************** Deque操作 ************************/</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.offerFirst(2); // 在此列表的开头插入指定的元素</span><br><span class="line">        System.out.println(&quot;After offerFirst(2):&quot; + linkedList);</span><br><span class="line">        linkedList.offerLast(5); // 在此列表末尾插入指定的元素</span><br><span class="line">        System.out.println(&quot;After offerLast(5):&quot; + linkedList);</span><br><span class="line">        System.out.println(&quot;peekFirst(): &quot; + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;peekLast(): &quot; + linkedList.peekLast()); // 获取但不移除此列表的第一个元素</span><br><span class="line">        linkedList.pollFirst(); // 获取并移除此列表的第一个元素</span><br><span class="line">        System.out.println(&quot;After pollFirst():&quot; + linkedList);</span><br><span class="line">        linkedList.pollLast(); // 获取并移除此列表的最后一个元素</span><br><span class="line">        System.out.println(&quot;After pollLast():&quot; + linkedList);</span><br><span class="line">        linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头）</span><br><span class="line">        System.out.println(&quot;After push(2):&quot; + linkedList);</span><br><span class="line">        linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span><br><span class="line">        System.out.println(&quot;After pop():&quot; + linkedList);</span><br><span class="line">        linkedList.add(3);</span><br><span class="line">        linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span><br><span class="line">        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表）</span><br><span class="line">        System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList);</span><br><span class="line"></span><br><span class="line">        /************************** 遍历操作 ************************/</span><br><span class="line">        System.out.println(&quot;-----------------------------------------&quot;);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        // 迭代器遍历</span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;Iterator：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        // 顺序遍历(随机遍历)</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;for：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        // 另一种for循环遍历</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        for (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;for2：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        // 通过pollFirst()或pollLast()来遍历LinkedList</span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        while (temp1.size() != 0) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;pollFirst()或pollLast()：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line"></span><br><span class="line">        // 通过removeFirst()或removeLast()来遍历LinkedList</span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        while (temp2.size() != 0) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;removeFirst()或removeLast()：&quot; + (end - start) + &quot; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="源码" scheme="http://www.herobin.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>透过源码角度分析ArrayList扩容机制</title>
    <link href="http://www.herobin.top/2019/01/14/%E9%80%8F%E8%BF%87%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.herobin.top/2019/01/14/透过源码角度分析ArrayList扩容机制/</id>
    <published>2019-01-14T05:02:03.000Z</published>
    <updated>2019-01-14T06:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-先从ArrayList的构造函数说起"><a href="#一-先从ArrayList的构造函数说起" class="headerlink" title="一 先从ArrayList的构造函数说起"></a>一 先从ArrayList的构造函数说起</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 默认初始容量大小</span><br><span class="line">     */</span><br><span class="line">    private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 用于空数组实例</span><br><span class="line">     */</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">/**</span><br><span class="line"> * 用于默认大小的空数组实例。用它与EMPTY_ELEMENTDATA区别开，以便了解在添加第一个元素时要扩容多少</span><br><span class="line"> */</span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认构造函数，初始容量为空构造一个空列表(无参数构造)</span><br><span class="line">     * 添加第一个元素时，容量扩为10</span><br><span class="line">     */</span><br><span class="line">    public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 带初始容量参数的构造函数。（用户自己指定容量）</span><br><span class="line">     */</span><br><span class="line">    public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;//初始容量大于0</span><br><span class="line">            //创建initialCapacity大小的数组</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;//初始容量等于0</span><br><span class="line">            //创建空数组</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;//初始容量小于0，抛出异常</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span><br><span class="line">    *如果指定的集合为null，throws NullPointerException。 </span><br><span class="line">    */</span><br><span class="line">     public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        if ((size = elementData.length) != 0) &#123;</span><br><span class="line">            // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">            if (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // replace with empty array.</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">可以发现：以无参构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10.</span><br><span class="line"></span><br><span class="line">## 二 一步一步分析ArrayList扩容机制</span><br><span class="line"></span><br><span class="line">以无参构造函数创建的ArrayList为例分析：</span><br><span class="line"></span><br><span class="line">### 1.先来看add()方法</span><br></pre></td></tr></table></figure><pre><code>/** * 将指定的元素追加到此列表的末尾。  */public boolean add(E e) {</code></pre><p>   //添加元素之前，先调用ensureCapacityInternal方法<br>        ensureCapacityInternal(size + 1);  // Increments modCount!!<br>        //这里看到ArrayList添加元素的实质就相当于为数组赋值<br>        elementData[size++] = e;<br>        return true;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 2.在看ensureCapacityInternal()方法</span><br></pre></td></tr></table></figure></p><pre><code>//得到最小扩容量private void ensureCapacityInternal(int minCapacity) {     //如果还是空数组    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {          // 获取默认的容量和传入参数的较大值        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }    ensureExplicitCapacity(minCapacity);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当要add进第一个元素时，minCapacity为1，在Math.max()方法比较后，minCatacity为10.</span><br><span class="line"></span><br><span class="line">### 3.ensureExplicitCapacity()方法</span><br><span class="line">如果调用ensureCapacityInternal()方法就一定会执行这个方法：</span><br></pre></td></tr></table></figure><pre><code>//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        //调用grow方法进行扩容，调用此方法代表已经开始扩容了        grow(minCapacity);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们来仔细分析一下：</span><br><span class="line">&gt; * 当我们要 add 进第1个元素到 ArrayList 时，elementData.length 为0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length &gt; 0 成立，所以会进入 grow(minCapacity) 方法。</span><br><span class="line">&gt; * 当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0 不成立，所以不会进入 （执行）grow(minCapacity) 方法。</span><br><span class="line">&gt; * 添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</span><br><span class="line">&gt; * 直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</span><br><span class="line"></span><br><span class="line">### 4.grow()方法</span><br></pre></td></tr></table></figure><pre><code>/** * 要分配的最大数组大小 * 要分配的最大数组大小。 一些VM在阵列中保留一些标题字。 *  尝试分配更大的数组可能会导致OutOfMemoryError：请求的数组大小超过VM限制 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) {    // oldCapacity为旧容量，newCapacity为新容量    int oldCapacity = elementData.length;    //将oldCapacity 右移一位，其效果相当于oldCapacity /2，    //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;   // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，   //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分析grow()方法：</span><br><span class="line">&gt; * 当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。</span><br><span class="line">&gt; * 当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true,size增为11。</span><br><span class="line">&gt; * 以此类推······</span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">&gt; * java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</span><br><span class="line">&gt; * java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.</span><br><span class="line">&gt; * java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</span><br><span class="line"></span><br><span class="line">### 5.hugeCapacity()方法</span><br><span class="line"></span><br><span class="line">从上面 grow() 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。</span><br></pre></td></tr></table></figure><pre><code>private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    //对minCapacity和MAX_ARRAY_SIZE进行比较    //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小    //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 三 System.arraycopy()和Arrays.copyOf()方法</span><br><span class="line"></span><br><span class="line">阅读源码可以发现ArrayList中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、toArray() 等方法中都用到了该方法！</span><br><span class="line"></span><br><span class="line">### 3.1 System.arraycopy() 方法</span><br></pre></td></tr></table></figure><pre><code>/** * 在此列表中的指定位置插入指定的元素。  *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) {    rangeCheckForAdd(index);    ensureCapacityInternal(size + 1);  // Increments modCount!!    //arraycopy()方法实现数组自己复制自己    //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；    System.arraycopy(elementData, index, elementData, index + 1, size - index);    elementData[index] = element;    size++;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们写一个简单的方法测试以下：</span><br></pre></td></tr></table></figure><p>public class ArraycopyTest {</p><pre><code>public static void main(String[] args) {    // TODO Auto-generated method stub    int[] a = new int[10];    a[0] = 0;    a[1] = 1;    a[2] = 2;    a[3] = 3;    System.arraycopy(a, 2, a, 3, 3);    a[2]=99;    for (int i = 0; i &lt; a.length; i++) {        System.out.println(a[i]);    }}</code></pre><p>}<br>结果：</p><p>0 1 99 2 3 0 0 0 0 0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 3.2 Arrays.copyOf()方法</span><br></pre></td></tr></table></figure></p><pre><code>/** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。  */public Object[] toArray() {//elementData：要复制的数组；size：要复制的长度    return Arrays.copyOf(elementData, size);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">个人觉得Arrays.copyOf()方法主要是为了给原有数组扩容，测试代码如下：</span><br></pre></td></tr></table></figure><p>public class ArrayscopyOfTest {</p><pre><code>public static void main(String[] args) {    int[] a = new int[3];    a[0] = 0;    a[1] = 1;    a[2] = 2;    int[] b = Arrays.copyOf(a, 10);    System.out.println(&quot;b.length&quot;+b.length);}</code></pre><p>}<br>结果：</p><p>10<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.3两者联系和区别</span><br><span class="line">联系：</span><br><span class="line">&gt; 看两者源代码可以发现copyOf()内部实际调用了System.arraycopy()方法</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">&gt; arraycopy() 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 copyOf() 是系统自动在内部新建一个数组，并返回该数组。</span><br><span class="line"></span><br><span class="line">## 四 ensureCapacity方法</span><br><span class="line">ArrayList 源码中有一个 ensureCapacity 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</span><br></pre></td></tr></table></figure></p><pre><code>/**如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。 * * @param   minCapacity   所需的最小容量 */public void ensureCapacity(int minCapacity) {    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)        // any size if not default element table        ? 0        // larger than default for default empty table. It&apos;s already        // supposed to be at default size.        : DEFAULT_CAPACITY;    if (minCapacity &gt; minExpand) {        ensureExplicitCapacity(minCapacity);    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量从新分配的次数</span><br><span class="line"></span><br><span class="line">我们通过下面的代码实际测试以下这个方法的效果：</span><br></pre></td></tr></table></figure><p>public class EnsureCapacityTest {<br>    public static void main(String[] args) {<br>        ArrayList<object> list = new ArrayList<object>();<br>        final int N = 10000000;<br>        long startTime = System.currentTimeMillis();<br>        for (int i = 0; i &lt; N; i++) {<br>            list.add(i);<br>        }<br>        long endTime = System.currentTimeMillis();<br>        System.out.println(“使用ensureCapacity方法前：”+(endTime - startTime));</object></object></p><pre><code>    list = new ArrayList&lt;Object&gt;();    long startTime1 = System.currentTimeMillis();    list.ensureCapacity(N);    for (int i = 0; i &lt; N; i++) {        list.add(i);    }    long endTime1 = System.currentTimeMillis();    System.out.println(&quot;使用ensureCapacity方法后：&quot;+(endTime1 - startTime1));}</code></pre><p>}<br>运行结果：</p><p>使用ensureCapacity方法前：4637<br>使用ensureCapacity方法后：241<br><code>`</code><br>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量从新分配的次数.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-先从ArrayList的构造函数说起&quot;&gt;&lt;a href=&quot;#一-先从ArrayList的构造函数说起&quot; class=&quot;headerlink&quot; title=&quot;一 先从ArrayList的构造函数说起&quot;&gt;&lt;/a&gt;一 先从ArrayList的构造函数说起&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="源码" scheme="http://www.herobin.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
