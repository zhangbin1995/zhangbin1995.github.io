<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeroBin&#39;s Blog</title>
  
  <subtitle>向阳而生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.herobin.top/"/>
  <updated>2019-05-15T15:08:55.504Z</updated>
  <id>http://www.herobin.top/</id>
  
  <author>
    <name>HeroBin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java的强引用、弱引用、软引用、虚引用</title>
    <link href="http://www.herobin.top/2019/05/15/Java%E7%9A%84%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/05/15/Java的强引用、弱引用、软引用、虚引用/</id>
    <published>2019-05-15T14:58:11.000Z</published>
    <updated>2019-05-15T15:08:55.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-强引用（StrongReference）"><a href="#1-强引用（StrongReference）" class="headerlink" title="1. 强引用（StrongReference）"></a>1. 强引用（StrongReference）</h1><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收期绝不会回收它。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object o=new Object();   //  强引用</span><br></pre></td></tr></table></figure></p><p>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o = null;  // 帮助垃圾收集器回收此对象</span><br></pre></td></tr></table></figure></p><p>显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。</p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void test()&#123;</span><br><span class="line">    Object o=new Object();</span><br><span class="line">    // 省略其他操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。</p><p>但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。</p><p>强引用在实际中有非常重要的用处，举个ArrayList的实现源代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private transient Object[] elementData;</span><br><span class="line">public void clear() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        // Let gc do its work</span><br><span class="line">        for (int i = 0; i &lt; size; i++)</span><br><span class="line">            elementData[i] = null;</span><br><span class="line">        size = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在ArrayList类中定义了一个私有的变量elementData数组，在调用方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null，强引用仍然存在，避免在后续调用 add()等方法添加元素时进行重新的内存分配。使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。 </p><h1 id="2、软引用（SoftReference）"><a href="#2、软引用（SoftReference）" class="headerlink" title="2、软引用（SoftReference）"></a>2、软引用（SoftReference）</h1><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=new String(&quot;abc&quot;);                                     // 强引用</span><br><span class="line">SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);     // 软引用</span><br></pre></td></tr></table></figure><p>当内存不足时，等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If(JVM.内存不足()) &#123;</span><br><span class="line">   str = null;  // 转换为软引用</span><br><span class="line">   System.gc(); // 垃圾回收器进行回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p><p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出</p><p>这时候就可以使用软引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Browser prev = new Browser();               // 获取页面进行浏览</span><br><span class="line">SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用        </span><br><span class="line">if(sr.get()!=null)&#123; </span><br><span class="line">    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了</span><br><span class="line">    sr = new SoftReference(prev);       // 重新构建</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就很好的解决了实际的问题。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h1 id="3、弱引用（WeakReference）"><a href="#3、弱引用（WeakReference）" class="headerlink" title="3、弱引用（WeakReference）"></a>3、弱引用（WeakReference）</h1><p> 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=new String(&quot;abc&quot;);    </span><br><span class="line">WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);</span><br><span class="line">str=null;</span><br></pre></td></tr></table></figure><p>当垃圾回收器进行扫描回收时等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure></p><p>如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。   </p><p>下面的代码会让str再次变为一个强引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String  abc = abcWeakRef.get();</span><br></pre></td></tr></table></figure></p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。</p><p>这个引用不会在对象的垃圾回收判断中产生任何附加的影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ReferenceQueue&lt;VeryBig&gt; rq = new ReferenceQueue&lt;VeryBig&gt;();</span><br><span class="line"></span><br><span class="line">    public static void checkQueue() &#123;</span><br><span class="line">        Reference&lt;? extends VeryBig&gt; ref = null;</span><br><span class="line">        while ((ref = rq.poll()) != null) &#123;</span><br><span class="line">            if (ref != null) &#123;</span><br><span class="line">                System.out.println(&quot;In queue: &quot;    + ((VeryBigWeakReference) (ref)).id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        int size = 3;</span><br><span class="line">        LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = new LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            weakList.add(new VeryBigWeakReference(new VeryBig(&quot;Weak &quot; + i), rq));</span><br><span class="line">            System.out.println(&quot;Just created weak: &quot; + weakList.getLast());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc(); </span><br><span class="line">        try &#123; // 下面休息几分钟，让上面的垃圾回收线程运行完成</span><br><span class="line">            Thread.currentThread().sleep(6000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        checkQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VeryBig &#123;</span><br><span class="line">    public String id;</span><br><span class="line">    // 占用空间,让线程进行回收</span><br><span class="line">    byte[] b = new byte[2 * 1024];</span><br><span class="line"></span><br><span class="line">    public VeryBig(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() &#123;</span><br><span class="line">        System.out.println(&quot;Finalizing VeryBig &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class VeryBigWeakReference extends WeakReference&lt;VeryBig&gt; &#123;</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public VeryBigWeakReference(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq) &#123;</span><br><span class="line">        super(big, rq);</span><br><span class="line">        this.id = big.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() &#123;</span><br><span class="line">        System.out.println(&quot;Finalizing VeryBigWeakReference &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Just created weak: com.javabase.reference.VeryBigWeakReference@1641c0</span><br><span class="line">Just created weak: com.javabase.reference.VeryBigWeakReference@136ab79</span><br><span class="line">Just created weak: com.javabase.reference.VeryBigWeakReference@33c1aa</span><br><span class="line">Finalizing VeryBig Weak 2</span><br><span class="line">Finalizing VeryBig Weak 1</span><br><span class="line">Finalizing VeryBig Weak 0</span><br><span class="line">In queue: Weak 1</span><br><span class="line">In queue: Weak 2</span><br><span class="line">In queue: Weak 0</span><br></pre></td></tr></table></figure></p><h1 id="4、虚引用（PhantomReference）"><a href="#4、虚引用（PhantomReference）" class="headerlink" title="4、虚引用（PhantomReference）"></a>4、虚引用（PhantomReference）</h1><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p><h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>java4种引用的级别由高到低依次为：<br><strong><font color="red">强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</font></strong><br>通过图来看一下他们之间在垃圾回收时的区别：<br><img src="https://img-blog.csdnimg.cn/20190313112115410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0MDk1MDU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当垃圾回收器回收时，某些对象会被回收，某些不会被回收。垃圾回收器会从根对象Object来标记存活的对象，然后将某些不可达的对象和一些引用的对象进行回收，如果对这方面不是很了解，可以参考如下的文章：</p><p>通过表格来说明一下，如下：<br><img src="https://img-blog.csdnimg.cn/20190313112144580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI0MDk1MDU1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-强引用（StrongReference）&quot;&gt;&lt;a href=&quot;#1-强引用（StrongReference）&quot; class=&quot;headerlink&quot; title=&quot;1. 强引用（StrongReference）&quot;&gt;&lt;/a&gt;1. 强引用（StrongRefere
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Guns集成dubbo分布式开发环境搭建</title>
    <link href="http://www.herobin.top/2019/03/04/Guns%E9%9B%86%E6%88%90dubbo%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.herobin.top/2019/03/04/Guns集成dubbo分布式开发环境搭建/</id>
    <published>2019-03-04T05:20:37.000Z</published>
    <updated>2019-05-15T14:53:50.410Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>首先项目是基于开源软件Guns为基础的。</p><p>码云地址：<a href="https://gitee.com/stylefeng/guns" target="_blank" rel="noopener">https://gitee.com/stylefeng/guns</a></p><p>官网介绍如下：Guns基于Spring Boot 2，致力于做更简洁的后台管理系统，完美整合springmvc + shiro + mybatis-plus + beetl，Guns项目代码简洁，注释丰富，上手容易，同时Guns包含许多基础模块(用户管理，角色管理，部门管理，字典管理等10个模块)，可以直接作为一个后台管理系统的脚手架！同时提供spring cloud版本！</p><p>这里我们使用的不是最新版本，而是比较方便集成dubbo进行分布式开发的一个版本，资料和本博客的项目源码在文章末尾的github中。</p><p>将压缩包在我们理想的目录下解压出来。</p><p><img src="/uploads/190304java1/1.png" alt=""></p><p>首先我们使用guns-rest/db/guns-rest.sql语句创建guns-rest数据库。</p><p><img src="/uploads/190304java1/2.png" alt=""></p><p>去yml中将数据库信息改为本机信息，启动GunsRestApplication，发现报错缺少log4j，在pom中将其引入。</p><p><img src="/uploads/190304java1/3.png" alt=""></p><p>题外话：我们使用开源软件的时候，如果一个版本使用的很好就不要老换，容易出现问题，如维护的人不多导致提交不规范等，可能会使软件变得不再好用。</p><p>上面的问题我们在rest的pom中加上依赖(去maven repository中找就好)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>再次运行发现还有报错MybatisPlusException，这里是因为数据库信息中使用了一个zeroDateTimeBehavior，这里我们将它换成serverTimezone就好了。</p><p><img src="/uploads/190304java1/4.png" alt=""></p><p>再次启动，运行成功。</p><p>这时我们访问rest提供的验证接口：<a href="http://localhost/auth?userName=admin&amp;password=admin" target="_blank" rel="noopener">http://localhost/auth?userName=admin&amp;password=admin</a> </p><p><img src="/uploads/190304java1/5.png" alt=""></p><p>如图，成功返回了token和随机密钥，也说明了我们的guns环境搭建成功了。</p><p>这里我们添加模块可以直接在项目上new module，也可以直接拷贝guns-rest然后改名即可，这里推荐第二种拷贝的方式。</p><p>我们通过copy rest模块新建一个模块guns-gateway，记住要将他添加到总工程的pom中。</p><p><img src="/uploads/190304java1/6.png" alt=""></p><p>在gateway的pom中将artifactId改为正确的名称。</p><p><img src="/uploads/190304java1/7.png" alt=""></p><p>这里会发现我们的gateway模块后面跟着一个guns-rest(1)，这是因为我们从rest拷贝过来的名字默认是rest(1)，去项目的project structure中修改掉即可。</p><p><img src="/uploads/190304java1/8.png" alt=""></p><p>启动一下gateway，启动成功了，再次访问auth接口，还是成功的。</p><p>接下来我们在Guns中集成dubbo。</p><p>首先将dubbo和zookeeper的依赖包拷贝进来。</p><p><img src="/uploads/190304java1/9.png" alt=""></p><p>在yml中配置dubbo信息：</p><p><img src="/uploads/190304java1/10.png" alt=""></p><p>启动类上开启dubbo注解：</p><p><img src="/uploads/190304java1/11.png" alt=""></p><p>然后我们编写一个模拟验证登录状态的服务接口以及他的实现类并通过@Service将它暴露给dubbo。</p><p><img src="/uploads/190304java1/12.png" alt=""></p><p>这样dubbo的一个基本环境就已经完成了。</p><p>将zookeeper启动，再启动我们的项目，会在zookeeper的日志中发现注册了新的服务，至此，集成dubbo成功。</p><p>再次执行auth接口，一切正常。</p><p>这里我们可以发现有一个问题，我们的模块中的接口和实现类都是一对一的，可是每个模块又要有其他模块的接口，这样接口的冗余会非常高，这样我们可以再单独建一个子工程，他的作用就是承载我们的业务接口以及各个模块中需要的实体类。<br>这样接口我们只写一遍，所有的工程就都可以共享了。</p><p>我们拷贝guns-core新命名为guns-api，将用不到的target删掉。<br>在父项目的pom中将它添加进去，再到project structure中将它改好名字，还要改好它自身的pom里的配置。<br>将原来的模块都删掉。</p><p><img src="/uploads/190304java1/13.png" alt=""></p><p>新建我们自己的模块，包名也可以改为我们想要的。然后就可以将我们在gateway中编写的UserAPI接口拷贝过来。</p><p><img src="/uploads/190304java1/13.1.png" alt=""></p><p>然后在gateway中继承一下api模块，就可以直接使用里面的接口了。</p><p><img src="/uploads/190304java1/14.png" alt=""></p><p>这样就可以将我们gateway里面的UserAPI接口删掉了，会自动继承我们写在api里的UserAPI。<br>注意要将我们的api模块放到maven库中，才能读取的到。</p><p><img src="/uploads/190304java1/15.png" alt=""></p><p>不要忘了在api的pom中将名字由core改为api。</p><p><img src="/uploads/190304java1/16.png" alt=""></p><p>再点击maven中api模块的Lifecycle中的install就可以安装api到maven中了，这样gateway里就能读到api里的接口了。</p><p><img src="/uploads/190304java1/17.png" alt=""></p><p>不要忘了去父节点中引入api包。</p><p><img src="/uploads/190304java1/18.png" alt=""></p><p>这时我们可以看到gateway中UserImpl引用的UserAPI接口就是来自api模块中的了。</p><p><img src="/uploads/190304java1/19.png" alt=""></p><p>以后将所有需要暴露的接口都放在api中就好了。</p><p>这样开发的架子就已经搭建好了。</p><p>项目github地址：<a href="https://github.com/zhangbin1995/guns.git" target="_blank" rel="noopener">https://github.com/zhangbin1995/guns.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先项目是基于开源软件Guns为基础的。&lt;/p&gt;
&lt;p&gt;码云地址：&lt;a href=&quot;https://gitee.com/styl
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
      <category term="Guns" scheme="http://www.herobin.top/tags/Guns/"/>
    
  </entry>
  
  <entry>
    <title>springboot集成zookeeper注册中心</title>
    <link href="http://www.herobin.top/2019/03/03/springboot%E9%9B%86%E6%88%90zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://www.herobin.top/2019/03/03/springboot集成zookeeper注册中心/</id>
    <published>2019-03-03T08:09:55.000Z</published>
    <updated>2019-05-15T14:50:31.288Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>前面的博客我们配置了springboot集成dubbo开发环境搭建，这里我们在之前的基础上集成zookeeper注册中心。</p><p>首先不要忘记在consumer和provider的pom中引入zookeeper的依赖</p><p><img src="/uploads/190303java4/1.png" alt=""></p><p>修改配置文件，由无注册中心的改为zookeeper注册中心的</p><p><img src="/uploads/190303java4/2.png" alt=""></p><p>这时启动我们项目就可以将这个服务注册到zookeeper上了，可以从zookeeper日志上看出。</p><p>去consumer消费者中填写注册中心地址</p><p><img src="/uploads/190303java4/3.png" alt=""></p><p>修改消费者接口将原来的直连提供者方式改为zookeeper配置。</p><p><img src="/uploads/190303java4/4.png" alt=""></p><p>启动consumer模块，得到目标输出，springboot配置dubbo成功。</p><p><img src="/uploads/190303java4/5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面的博客我们配置了springboot集成dubbo开发环境搭建，这里我们在之前的基础上集成zookeeper注册中心。&lt;/p
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
      <category term="zookeeper" scheme="http://www.herobin.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>spring集成zookeeper注册中心</title>
    <link href="http://www.herobin.top/2019/03/03/spring%E9%9B%86%E6%88%90zookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://www.herobin.top/2019/03/03/spring集成zookeeper注册中心/</id>
    <published>2019-03-03T07:58:34.000Z</published>
    <updated>2019-03-03T08:00:10.082Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>在spring+dubbo开发环境搭建好，及下载安装好zookeeper之后（相关步骤在前面的博客中），现在我们来配置spring集成zookeeper注册中心。<br>在provider的<code>application.xml</code>中配置提供者到注册中心zookeeper中，这里zookeeper为本机的zookeeper，zookeeper的默认端口号为<code>2181</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/uploads/190303java3/1.png" alt=""></p><p>记得将之前没有配置注册中心的写在<code>dubbo:service</code>中的<code>register=&quot;N/A&quot;</code>删掉。</p><p>使用命令行 <code>zkServer.sh start-foreground</code> 前台启动zookeeper后，再运行provider程序，可以看到日志输入，即我们服务者接口注册成功了。</p><p><img src="/uploads/190303java3/2.png" alt=""></p><p>接下来我们去consumer服务消费者这边配置，同样是在<code>application.xml</code>中配置注册中心</p><p><img src="/uploads/190303java3/3.png" alt=""></p><p>启动consumer服务，输入得到输出，配置成功。</p><p><img src="/uploads/190303java3/4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在spring+dubbo开发环境搭建好，及下载安装好zookeeper之后（相关步骤在前面的博客中），现在我们来配置sprin
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
      <category term="spring" scheme="http://www.herobin.top/tags/spring/"/>
    
      <category term="zookeeper" scheme="http://www.herobin.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper下载与安装</title>
    <link href="http://www.herobin.top/2019/03/03/zookeeper%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://www.herobin.top/2019/03/03/zookeeper下载与安装/</id>
    <published>2019-03-03T06:47:13.000Z</published>
    <updated>2019-03-03T07:17:35.342Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>在zookeeper官网：<a href="http://zookeeper.apache.org" target="_blank" rel="noopener">zookeeper.apache.org</a> 中点击download进入下载页面</p><p><img src="/uploads/190303java2/1.png" alt=""></p><p>点击进入下载，这里我们下载的版本是3.4.10</p><p>下载完成后，拷贝到我们想要放到的路径进行解压，注意路径不要有中文。</p><p>注意zookeeper的安装是要建立在jdk的安装上的，不过安装zookeeper的应该也都有jdk了。。。</p><p>首先我们要去conf文件夹中修改一个配置文件<code>zoo_sample.cfg</code>改名为<code>zoo.cfg</code></p><p>去bin文件夹下可以看到我们启动执行文件<code>zkServer.sh</code>(windows则为<code>zkServer.cmd</code>)<br>执行该文件<code>./zkServer.sh start</code>，如下图执行成功。</p><p><img src="/uploads/190303java2/2.png" alt=""></p><p>ZooKeeper下载与安装完毕。</p><p>另外说明一下，这里的<code>./zkServer.sh start</code>是后台启动，若要查看日志可用前台启动<br><code>zkServer.sh start-foreground</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在zookeeper官网：&lt;a href=&quot;http://zookeeper.apache.org&quot; target=&quot;_blan
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="zookeeper" scheme="http://www.herobin.top/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>springboot集成dubbo环境搭建</title>
    <link href="http://www.herobin.top/2019/03/03/springboot%E9%9B%86%E6%88%90dubbo%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.herobin.top/2019/03/03/springboot集成dubbo环境搭建/</id>
    <published>2019-03-03T04:31:12.000Z</published>
    <updated>2019-03-03T04:34:03.386Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>新建project</p><p><img src="/uploads/190303java1/1.png" alt=""></p><p>next取好项目名，一路next即可。<br>新建两个module，provider和consumer同样是springboot项目创建步骤同上。<br>将两个模块分别启动，均启动成功，说明springboot没有问题，接下来集成dubbo。<br>SpringBoot版本Dubbo集成中文地址：<a href="https://github.com/alibaba/dubbo-spring-boot-starter/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/alibaba/dubbo-spring-boot-starter/blob/master/README_zh.md</a></p><p>将dubbo的依赖引入到两个模块的pom中</p><p><img src="/uploads/190303java1/2.png" alt=""></p><p>在application.properties中添加dubbo的相关配置信息</p><p><img src="/uploads/190303java1/3.png" alt=""></p><p>接下来在ProviderApplication的上添加@EnableDubboConfiguration，表示要开启dubbo功能. (dubbo provider服务可以使用或者不使用web容器)</p><p><img src="/uploads/190303java1/4.png" alt=""></p><p>编写服务提供者的接口和实现类<br>编写你的dubbo服务，只需要添加要发布的服务实现上添加@Service（import com.alibaba.dubbo.config.annotation.Service）注解，其中interfaceClass是要发布服务的接口</p><p><img src="/uploads/190303java1/5.png" alt=""></p><p>启动服务者的Spring Boot应用，观察控制台，可以看到dubbo启动相关信息.<br>至此，provider的dubbo配置成功。</p><p>接下来配置consumer的dubbo配置<br>添加依赖</p><p><img src="/uploads/190303java1/6.png" alt=""></p><p>在application.properties中添加dubbo的相关配置信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=dubbo-spring-boot-starter</span><br></pre></td></tr></table></figure></p><p>这里这个name是可以自己命名的。</p><p>开启ConsumnerApplication启动类的<code>@EnableDubboConfiguration</code>注解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableDubboConfiguration</span><br></pre></td></tr></table></figure></p><p>在consumer中编写服务实用类，记得要将provider中的接口DemeService拷贝过来</p><p><img src="/uploads/190303java1/7.png" alt=""></p><p>编写ConsumerApplication类并执行</p><p><img src="/uploads/190303java1/8.png" alt=""></p><p>获得目标输出，springboot集成dubbo环境搭建成功。</p><p>代码github地址：<a href="https://github.com/zhangbin1995/springbootdubbo.git" target="_blank" rel="noopener">https://github.com/zhangbin1995/springbootdubbo.git</a></p><p>当然上面只是简单的springboot+dubbo的环境集成，这样是有瑕疵的。</p><p>我们的上面示例里消费者是直连提供者的，这种方式只可以在测试环境中使用，因为直连提供者限制了分布式的易扩展性，如果提供者部署在多节点，而我们在消费者中是直连写死的状态，那就只会访问一个节点，也违背了我们的分布式的初衷。</p><p>所以通常我们的消费者和提供者是要通过注册中心来注册调用的关于注册中心，后面会继续介绍，本篇博文介绍的springboot+dubbo的集成到此结束。</p><p><img src="/uploads/190303java1/9.png" alt=""></p><p><img src="/uploads/190303java1/10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新建project&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/190303java1/1.png&quot; alt=&quot;&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>spring集成dubbo开发环境搭建</title>
    <link href="http://www.herobin.top/2019/03/02/spring%E9%9B%86%E6%88%90dubbo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.herobin.top/2019/03/02/spring集成dubbo开发环境搭建/</id>
    <published>2019-03-02T08:21:15.000Z</published>
    <updated>2019-03-02T08:25:16.630Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><p>首先新建maven项目选择quickstart为项目原型。</p><p><img src="/uploads/190302java1/1.png" alt=""></p><p>点击项目添加两个module分别命名provider和consumer，原型同样选择quickstart分别作为服务提供者和消费者。（注意新建后暂时没有src文件夹，要等maven配置全部加载完才有，如果过慢，记得检查是否配置好idea的maven配置是否改为aliyun仓库）。<br>这里我们用不到测试用例，可以将test文件删掉。</p><p>添加放置资源文件的resources文件夹，并在project structrue中添加进Resources中。</p><p><img src="/uploads/190302java1/2.png" alt=""></p><p>将需要的jar包依赖拷贝到父工程的pom中，这样各个模块就都可以使用了，注意在实际开发中，应该是各个模块分别引入该模块要用到的jar包，再在各模块的resources中新建applicationContext.xml即spring配置文件。</p><p><img src="/uploads/190302java1/3.png" alt=""></p><p>这样简单的spring环境就搭好了，接下来我们要集成dubbo环境。<br>可以参考dubbo用户手册：<a href="https://dubbo.gitbooks.io/dubbo-user-book/content/quick-start.html" target="_blank" rel="noopener">https://dubbo.gitbooks.io/dubbo-user-book/content/quick-start.html</a></p><p><img src="/uploads/190302java1/4.png" alt=""></p><p>在provider中新建一个服务接口DemoService和它的实现类。<br>用Spring配置声明暴露服务。</p><p><img src="/uploads/190302java1/5.png" alt=""></p><p>编写服务启动类App.java</p><p><img src="/uploads/190302java1/6.png" alt=""></p><p>至此，我们的provider模块就写好了，将它启动起来。<br>编辑consumer里的applicationContext.xml文件通过spring配置引用远程服务。</p><p><img src="/uploads/190302java1/7.png" alt=""></p><p>这样就已经可以访问到provider接口提供的服务了。<br>编写App类加载consumer的spring配置文件并进行测试。</p><p><img src="/uploads/190302java1/8.png" alt=""></p><p>启动消费者服务，输入zhangbin，得到服务提供者接口的返回值，由此，spring与dubbo集成环境配置成功。</p><p>项目代码已放到github：<a href="https://github.com/zhangbin1995/springdubbo.git" target="_blank" rel="noopener">https://github.com/zhangbin1995/springdubbo.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先新建maven项目选择quickstart为项目原型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/190302ja
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="dubbo" scheme="http://www.herobin.top/tags/dubbo/"/>
    
      <category term="spring" scheme="http://www.herobin.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>第一个docker化的java应用</title>
    <link href="http://www.herobin.top/2019/02/23/%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E5%8C%96%E7%9A%84java%E5%BA%94%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/02/23/第一个docker化的java应用/</id>
    <published>2019-02-23T02:30:24.000Z</published>
    <updated>2019-03-02T08:44:07.148Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h1 id="制作镜像Dockerfile"><a href="#制作镜像Dockerfile" class="headerlink" title="制作镜像Dockerfile"></a>制作镜像Dockerfile</h1><p>这里制作镜像主要分为三步</p><blockquote><p>Dockerfile<br>docker build<br>Jpress：<a href="http://jpress.io/" target="_blank" rel="noopener">http://jpress.io/</a> (开源java web应用 博客平台)</p></blockquote><h2 id="下载tomcat镜像"><a href="#下载tomcat镜像" class="headerlink" title="下载tomcat镜像"></a>下载tomcat镜像</h2><p>首先我们的镜像是要依托tomcat运行的，所以先到网易云的镜像中心下载tomcat的镜像<br><code>docker pull hub.c.163.com/library/tomcat:latest</code><br>在tomcat镜像的介绍中可以看到使用方法，如找到启动方法，查看tomcat路径等。</p><p><img src="/uploads/190222java3/1.png" alt=""></p><h2 id="新建编辑Dockerfile"><a href="#新建编辑Dockerfile" class="headerlink" title="新建编辑Dockerfile"></a>新建编辑Dockerfile</h2><p><code>vi Dockerfile</code> </p><p><img src="/uploads/190222java3/2.png" alt=""></p><h2 id="通过docker-build生成镜像"><a href="#通过docker-build生成镜像" class="headerlink" title="通过docker build生成镜像"></a>通过docker build生成镜像</h2><p><img src="/uploads/190222java3/3.png" alt=""></p><p>这里<code>-t jpress:latest</code>是指定了镜像名字和标签，注意后面有个 . 用于查找当前目录下的构建文件，即Dockerfile<br>用<code>docker images</code>查看，发现有了jpress。</p><p><img src="/uploads/190222java3/4.png" alt=""></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>在tomcat的镜像中心我们可以看到运行指令，执行：<br><code>docker run -d -p 8888:8080 jpress</code><br>启动镜像，发现可以访问我们的jpress程序了。</p><p><img src="/uploads/190222java3/5.png" alt=""></p><p>这里要正常使用jpress需要配置好数据库信息。<br>我们也可以在docker中安装运行一个mysql数据库。<br>去镜像中心下载mysql镜像：<br><code>docker pull hub.c.163.com/library/mysql:latest</code><br>同样可以在介绍中看到使用方式。</p><p><img src="/uploads/190222java3/6.png" alt=""></p><p>下载完后新建一个名为jpress的数据库并将mysql运行起来：<br> <code>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql:latest</code><br>回到网站将信息配置好。</p><p><img src="/uploads/190222java3/7.png" alt=""></p><p>注意这里点击下一步的时候失败了，使用docker ps命令发现mysql镜像并没有执行，再次执行run发现启动报错。</p><p><img src="/uploads/190222java3/8.png" alt=""></p><p>因为本机有mysql服务正在使用，3306端口是占用状态的，将3306改为3307即可。<br>再下一页配置好网站信息，jpress网站即搭建成功可以正常使用了。</p><p><img src="/uploads/190222java3/9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;制作镜像Dockerfile&quot;&gt;&lt;a href=&quot;#制作镜像Dockerfile&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="服务器" scheme="http://www.herobin.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>docker运行nginx镜像</title>
    <link href="http://www.herobin.top/2019/02/22/docker%E8%BF%90%E8%A1%8Cnginx%E9%95%9C%E5%83%8F/"/>
    <id>http://www.herobin.top/2019/02/22/docker运行nginx镜像/</id>
    <published>2019-02-22T08:09:17.000Z</published>
    <updated>2019-03-02T08:38:45.258Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="mac下安装docker">TOC</a></p><p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h1 id="下载并运行nginx镜像"><a href="#下载并运行nginx镜像" class="headerlink" title="下载并运行nginx镜像"></a>下载并运行nginx镜像</h1><p>在网易云的镜像中心找到nginx的镜像<br><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">https://c.163yun.com/hub#/m/home/</a></p><p>复制nginx的下载地址：hub.c.163.com/library/nginx:latest<br>使用<code>docker pull hub.c.163.com/library/nginx:latest</code><br>下载nginx镜像到本地</p><p>这时再使用<code>docker images</code>可以查看到本地已有的nignx镜像</p><p>使用<code>docker run hub.c.163.com/library/nginx</code><br>发现没有任何输出，新建窗口输入<code>docker ps</code>可以查看本机当前运行的所有容器。</p><p><img src="/uploads/190222java2/1.png" alt=""></p><p>这时只要通过<code>ctrl+c</code>既可以停止程序，所以我们通常推荐在后台运行镜像 通过加 <code>-d</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d hub.c.163.com/library/nginx</span><br></pre></td></tr></table></figure></p><p>运行后可以通过docker exec命令进入指定镜像：</p><p><img src="/uploads/190222java2/3.png" alt=""></p><p>可以看到</p><blockquote><ol><li>docker run nginx镜像成功后返回一串此镜像运行的唯一标识id。</li><li>通过docker exec –help查看 docker exec命令帮助。</li><li>通过docker exec -it 603 bash来进入已运行的nginx镜像  这里只输入了604因为已经可以唯一标识确定，若不能再多输。</li><li>可通过exit命令退出镜像。</li><li>可以使用docker stop 603命令来结束nginx镜像的运行。</li></ol></blockquote><h1 id="网络访问nginx"><a href="#网络访问nginx" class="headerlink" title="网络访问nginx"></a>网络访问nginx</h1><p>运行了docker中的nginx后要怎样才能在网络（浏览器）中访问到nginx呢？</p><h2 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a>docker网络类型</h2><blockquote><ul><li><ol><li>bridge模式（桥接，默认类型，实现网络独立性）：docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</li></ol></li><li><ol start="2"><li>host模式：容器不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</li></ol></li><li><ol start="3"><li>none模式：Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。docker将不会和外界的任何网络进行通讯。</li></ol></li><li><ol start="4"><li>container模式：新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</li></ol></li></ul></blockquote><h2 id="进行访问"><a href="#进行访问" class="headerlink" title="进行访问"></a>进行访问</h2><blockquote><p>docker启动 -p 的使用： docker run -d -p 主机端口:容器端口 容器的名称<br>docker启动  -P 的使用（所有的监听端口都会和主机建立一个映射）： docker run -d -P 容器名称<br>停止docker：docker stop 容器Id</p></blockquote><p><strong>-p 的使用</strong> (注意这里是小写的p，下面是大写的P)</p><p><img src="/uploads/190222java2/4.png" alt=""></p><p><img src="/uploads/190222java2/5.png" alt=""></p><p><strong>-P 的使用</strong></p><p><img src="/uploads/190222java2/6.png" alt=""></p><p><img src="/uploads/190222java2/7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;mac下安装docker&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;下载并运行nginx镜像&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="服务器" scheme="http://www.herobin.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="docker" scheme="http://www.herobin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>centos下安装docker</title>
    <link href="http://www.herobin.top/2019/02/22/centos%E4%B8%8B%E5%AE%89%E8%A3%85docker/"/>
    <id>http://www.herobin.top/2019/02/22/centos下安装docker/</id>
    <published>2019-02-22T06:08:05.000Z</published>
    <updated>2019-02-22T06:09:06.810Z</updated>
    
    <content type="html"><![CDATA[<p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h2 id="1-检查内核版本"><a href="#1-检查内核版本" class="headerlink" title="1. 检查内核版本"></a>1. 检查内核版本</h2><p><code>uname -r</code><br>返回的值大于3.10即可。</p><h2 id="2-使用sudo或root权限的用户登录终端。"><a href="#2-使用sudo或root权限的用户登录终端。" class="headerlink" title="2. 使用sudo或root权限的用户登录终端。"></a>2. 使用sudo或root权限的用户登录终端。</h2><h2 id="3-卸载旧版本（如果安装过旧版本的话）"><a href="#3-卸载旧版本（如果安装过旧版本的话）" class="headerlink" title="3. 卸载旧版本（如果安装过旧版本的话）"></a>3. 卸载旧版本（如果安装过旧版本的话）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove docker \</span><br><span class="line">docker-common \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure><h2 id="4-安装需要的软件包"><a href="#4-安装需要的软件包" class="headerlink" title="4. 安装需要的软件包"></a>4. 安装需要的软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#yum-util提供yum-config-manager功能</span><br><span class="line">#另外两个是devicemapper驱动依赖的</span><br><span class="line">$ yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><h2 id="5-设置yum源"><a href="#5-设置yum源" class="headerlink" title="5. 设置yum源"></a>5. 设置yum源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="6-安装docker"><a href="#6-安装docker" class="headerlink" title="6. 安装docker"></a>6. 安装docker</h2><h3 id="6-1-安装最新版本"><a href="#6-1-安装最新版本" class="headerlink" title="6.1. 安装最新版本"></a>6.1. 安装最新版本</h3><p><code>yum install -y docker-ce</code></p><h3 id="6-2-安装指定版本"><a href="#6-2-安装指定版本" class="headerlink" title="6.2. 安装指定版本"></a>6.2. 安装指定版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查询版本列表</span><br><span class="line">$ yum list docker-ce --showduplicates | sort -r</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">已安装的软件包</span><br><span class="line">可安装的软件包</span><br><span class="line"> * updates: mirrors.163.com</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * extras: mirrors.163.com</span><br><span class="line">docker-ce.x86_64            17.09.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">docker-ce.x86_64            17.09.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">...</span><br><span class="line">#指定版本安装(这里的例子是安装上面列表中的第二个)</span><br><span class="line">$ yum install -y docker-ce-17.09.0.ce</span><br></pre></td></tr></table></figure><h2 id="7-启动docker"><a href="#7-启动docker" class="headerlink" title="7. 启动docker"></a>7. 启动docker</h2><p><code>systemctl start docker.service</code></p><h2 id="8-验证安装是否成功（有client和service两部分表示docker安装启动都成功了）"><a href="#8-验证安装是否成功（有client和service两部分表示docker安装启动都成功了）" class="headerlink" title="8.验证安装是否成功（有client和service两部分表示docker安装启动都成功了）"></a>8.验证安装是否成功（有client和service两部分表示docker安装启动都成功了）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.09.0-ce</span><br><span class="line"> API version:  1.32</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   afdb6d4</span><br><span class="line"> Built:        Tue Sep 26 22:41:23 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.09.0-ce</span><br><span class="line"> API version:  1.32 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   afdb6d4</span><br><span class="line"> Built:        Tue Sep 26 22:42:49 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><p>原文链接：<br><a href="https://www.imooc.com/article/16448" target="_blank" rel="noopener">https://www.imooc.com/article/16448</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-检查内核版本&quot;&gt;&lt;a href=&quot;#1-检查内核版本&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="服务器" scheme="http://www.herobin.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>mac下安装docker</title>
    <link href="http://www.herobin.top/2019/02/22/mac%E4%B8%8B%E5%AE%89%E8%A3%85docker/"/>
    <id>http://www.herobin.top/2019/02/22/mac下安装docker/</id>
    <published>2019-02-22T05:50:12.000Z</published>
    <updated>2019-03-02T08:27:39.152Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="mac下安装docker">TOC</a></p><p>更多文章欢迎访问个人博客 <a href="http://www.herobin.top">www.herobin.top</a></p><h1 id="mac下安装docker"><a href="#mac下安装docker" class="headerlink" title="mac下安装docker"></a>mac下安装docker</h1><h2 id="下载并安装docker"><a href="#下载并安装docker" class="headerlink" title="下载并安装docker"></a>下载并安装docker</h2><p>mac版的docker可以直接去docker官网下载桌面版，傻瓜式安装后运行docker，会发现在桌面的右上角出现了docker的图标</p><p><img src="/uploads/190222java1/1.png" alt=""></p><h2 id="验证docker"><a href="#验证docker" class="headerlink" title="验证docker"></a>验证docker</h2><p>打开终端输入命令：docker version</p><p><img src="/uploads/190222java1/2.png" alt=""></p><p>正常出现版本信息即安装成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@&lt;a href=&quot;mac下安装docker&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多文章欢迎访问个人博客 &lt;a href=&quot;http://www.herobin.top&quot;&gt;www.herobin.top&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;mac下安装docker&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="docker" scheme="http://www.herobin.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>对null字段的两种处理</title>
    <link href="http://www.herobin.top/2019/02/14/%E5%AF%B9null%E5%AD%97%E6%AE%B5%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%A4%84%E7%90%86/"/>
    <id>http://www.herobin.top/2019/02/14/对null字段的两种处理/</id>
    <published>2019-02-14T00:46:36.000Z</published>
    <updated>2019-02-14T00:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在查询订单列表时，有的订单详情为空返回值为null，不利于前端展示，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025663184309586&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: null</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025830175838897&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: null</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面<strong>orderDetailList</strong>的值为<strong>null</strong>。</p><p>这里我们可以给orderDTO添加注释<strong>JsonInclude</strong>来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@JsonInclude(JsonInclude.Include.NON_NULL)</span><br></pre></td></tr></table></figure><p>这样为空的属性就不会返回给前端了，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025663184309586&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025830175838897&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在<strong>application.yml</strong>中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: herobin</span><br><span class="line">    password: Zhangbin1995@</span><br><span class="line">    url: jdbc:mysql://101.132.138.185:3306/sell?characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    hibernate.ddl-auto: update</span><br><span class="line">  # 配置所有的类只返回非空属性 </span><br><span class="line">  jackson:</span><br><span class="line">    default-property-inclusion: non_null</span><br><span class="line">server:</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /sell</span><br></pre></td></tr></table></figure><p>可是有的时候我们想要返回orderDetailList，还是值不为空，而是一个方括号。</p><p>可以在orderDTO中给orderDetailList赋初值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;OrderDetail&gt; orderDetailList = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 0,</span><br><span class="line">    &quot;msg&quot;: &quot;成功&quot;,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025663184309586&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:41:06.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;orderId&quot;: &quot;1550025830175838897&quot;,</span><br><span class="line">            &quot;buyerName&quot;: &quot;admin&quot;,</span><br><span class="line">            &quot;buyerPhone&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;buyerAddress&quot;: &quot;11111&quot;,</span><br><span class="line">            &quot;buyerOpenid&quot;: &quot;123456&quot;,</span><br><span class="line">            &quot;orderAmount&quot;: 3.2,</span><br><span class="line">            &quot;orderStatus&quot;: 0,</span><br><span class="line">            &quot;payStatus&quot;: 0,</span><br><span class="line">            &quot;createTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;updateTime&quot;: &quot;2019-02-13T16:43:48.000+0000&quot;,</span><br><span class="line">            &quot;orderDetailList&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，String类型和int类型也都可以通过赋初值的方法避免null问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在查询订单列表时，有的订单详情为空返回值为null，不利于前端展示，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>PageRequest过时替换</title>
    <link href="http://www.herobin.top/2019/02/13/PageRequest%E8%BF%87%E6%97%B6%E6%9B%BF%E6%8D%A2/"/>
    <id>http://www.herobin.top/2019/02/13/PageRequest过时替换/</id>
    <published>2019-02-13T04:25:35.000Z</published>
    <updated>2019-02-13T04:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用SpringbootJPA的PageRequest时提示已过时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageRequest request = new PageRequest(page, size);</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>用PageRequest.of(page, size)替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PageRequest request = PageRequest.of(page, size);</span><br></pre></td></tr></table></figure><p>顺便列出一个分页的查询方法代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//订单列表</span><br><span class="line">   @GetMapping(&quot;/list&quot;)</span><br><span class="line">   public ResultVO&lt;List&lt;OrderDTO&gt;&gt; list(@RequestParam(&quot;openid&quot;) String openid,</span><br><span class="line">                                        @RequestParam(value = &quot;page&quot;, defaultValue = &quot;0&quot;) Integer page,</span><br><span class="line">                                        @RequestParam(value = &quot;size&quot;, defaultValue = &quot;10&quot;) Integer size)&#123;</span><br><span class="line">       if(StringUtils.isEmpty(openid))&#123;</span><br><span class="line">           log.error(&quot;[查询订单列表] openid为空&quot;);</span><br><span class="line">           throw new SellException(ResultEnum.PARAM_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //PageRequest已经过时 用PageRequest.of替换</span><br><span class="line">       //PageRequest request = new PageRequest(page, size);</span><br><span class="line">       PageRequest request = PageRequest.of(page, size);</span><br><span class="line">       Page&lt;OrderDTO&gt; orderDTOPage = orderService.findList(openid, request);</span><br><span class="line"></span><br><span class="line">       return ResultVOUtil.success(orderDTOPage.getContent());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>orderDTOPage中会有三个最主要的方法：</p><ul><li>getContent: 获得该页的记录集合</li><li>getTotalElements: 获得总记录条数</li><li>getTotalPages： 获得总页数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用SpringbootJPA的PageRequest时提示已过时&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot中Jpa的使用</title>
    <link href="http://www.herobin.top/2019/02/01/Springboot%E4%B8%ADJpa%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/02/01/Springboot中Jpa的使用/</id>
    <published>2019-02-01T10:57:47.000Z</published>
    <updated>2019-02-01T12:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>springboot中可以通过使用Jpa实现dao层的简单配置，使用jpa后可以省略复杂的sql语句编写，自带简单的增删改查功能。</p><h2 id="application-yml的配置"><a href="#application-yml的配置" class="headerlink" title="application.yml的配置"></a>application.yml的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    username: herobin</span><br><span class="line">    password: Zhangbin1995@</span><br><span class="line">    url: jdbc:mysql://101.132.138.185:3306/sell?characterEncoding=utf-8&amp;useSSL=false</span><br><span class="line">  jpa:</span><br><span class="line">    show-sql: true</span><br><span class="line">    database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">    hibernate.ddl-auto: update</span><br></pre></td></tr></table></figure><h2 id="dao类的编写"><a href="#dao类的编写" class="headerlink" title="dao类的编写"></a>dao类的编写</h2><p>dao接口直接集成JpaRepository接口即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.dao;</span><br><span class="line"></span><br><span class="line">import com.imooc.entity.ProductCategory;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/21.</span><br><span class="line"> */</span><br><span class="line">public interface ProductCategoryDao extends JpaRepository&lt;ProductCategory, Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ProductCategory&gt; findByCategoryTypeIn(List&lt;Integer&gt; categoryTypeList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dao层测试方法"><a href="#dao层测试方法" class="headerlink" title="dao层测试方法"></a>dao层测试方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.imooc.dao;</span><br><span class="line"></span><br><span class="line">import com.imooc.entity.ProductCategory;</span><br><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Ignore;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/21.</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProductCategoryDaoTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ProductCategoryDao pcDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Ignore</span><br><span class="line">    public void findOneTest()&#123;</span><br><span class="line"></span><br><span class="line">        ProductCategory productCategory = pcDao.findById(1).get();</span><br><span class="line">        System.out.println(productCategory.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findAllTest()&#123;</span><br><span class="line">        List&lt;ProductCategory&gt; pcList = pcDao.findAll();</span><br><span class="line">        for (ProductCategory pc : pcList)&#123;</span><br><span class="line">            System.out.println(pc.getCategoryName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void saveTest()&#123;</span><br><span class="line">        ProductInfo productInfo = new ProductInfo();</span><br><span class="line">        productInfo.setProductId(&quot;123456&quot;);</span><br><span class="line">        productInfo.setProductName(&quot;皮蛋粥&quot;);</span><br><span class="line">        productInfo.setProductPrice(new BigDecimal(3.2));</span><br><span class="line">        productInfo.setProductStock(100);</span><br><span class="line">        productInfo.setProductDescription(&quot;很好喝的粥&quot;);</span><br><span class="line">        productInfo.setProductIcon(&quot;xxx.png&quot;);</span><br><span class="line">        productInfo.setProductStatus(0);</span><br><span class="line">        productInfo.setCategoryType(2);</span><br><span class="line"></span><br><span class="line">        ProductInfo result = productInfoDao.save(productInfo);</span><br><span class="line">        Assert.assertNotNull(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findByCategoryTypeInTest()&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(2,3,4);</span><br><span class="line">        List&lt;ProductCategory&gt; result = pcDao.findByCategoryTypeIn(list);</span><br><span class="line">        Assert.assertNotEquals(0,result.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里测试了 单个查找的<code>findById()</code>方法和<code>findAll()</code>方法，注意这里的<code>findById()</code>方法返回的是<code>Optional&lt;T&gt;</code>,可以进到<code>JpaRepository</code>的<code>CrudRepository</code>里看到.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="line">// (powered by Fernflower decompiler)</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">package org.springframework.data.repository;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@NoRepositoryBean</span><br><span class="line">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123;</span><br><span class="line">    &lt;S extends T&gt; S save(S var1);</span><br><span class="line"></span><br><span class="line">    &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1);</span><br><span class="line"></span><br><span class="line">    Optional&lt;T&gt; findById(ID var1);</span><br><span class="line"></span><br><span class="line">    boolean existsById(ID var1);</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAll();</span><br><span class="line"></span><br><span class="line">    Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1);</span><br><span class="line"></span><br><span class="line">    long count();</span><br><span class="line"></span><br><span class="line">    void deleteById(ID var1);</span><br><span class="line"></span><br><span class="line">    void delete(T var1);</span><br><span class="line"></span><br><span class="line">    void deleteAll(Iterable&lt;? extends T&gt; var1);</span><br><span class="line"></span><br><span class="line">    void deleteAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在findById()后我们还要用get()方法才能得到我们想要查询的对象。</p><p>查看get方法的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NoSuchElementException(&quot;No value present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当查询结果为空时会抛出异常，所以在我们的代码中不要忘记做判断抛出异常。</p><h2 id="分页方法的使用"><a href="#分页方法的使用" class="headerlink" title="分页方法的使用"></a>分页方法的使用</h2><p>使用分页方法要将返回类型定义为PageAble。</p><p>dao方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/2/1.</span><br><span class="line"> */</span><br><span class="line">public interface OrderMasterDao extends JpaRepository&lt;OrderMaster,String&gt;&#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;OrderMaster&gt; findByBuyerOpenid(String buyerOpenId, Pageable pageable);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void findByBuyerOpenId() throws Exception &#123;</span><br><span class="line">    /** PageRequest实现了PageAble接口 */</span><br><span class="line">    PageRequest pageRequest = new PageRequest(0,1);</span><br><span class="line">    Page&lt;OrderMaster&gt; request = orderMasterDao.findByBuyerOpenid(&quot;123321&quot;,pageRequest);</span><br><span class="line">    //这个是总条数 不是分页返回的条数</span><br><span class="line">    System.out.println(request.getTotalElements());</span><br><span class="line">    System.out.println(request.getContent().get(0).getBuyerName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;springboot中可以通过使用Jpa实现dao层的简单配置，使用jpa后可以省略复杂的sql语句编写，自带简单的增删改查功能。&lt;/p&gt;
&lt;h2 id=&quot;application-yml的配置&quot;&gt;&lt;a href=&quot;#application-yml的配置&quot; class=&quot;he
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
      <category term="springboot" scheme="http://www.herobin.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-乐观锁与悲观锁</title>
    <link href="http://www.herobin.top/2019/01/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
    <id>http://www.herobin.top/2019/01/21/Java多线程-乐观锁与悲观锁/</id>
    <published>2019-01-21T05:20:00.000Z</published>
    <updated>2019-01-21T05:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h1><p><strong>悲观锁</strong></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p><p><strong>乐观锁</strong></p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h1 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h1><blockquote><p>乐观锁一般会使用版本号机制或CAS算法实现。</p></blockquote><h3 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h3><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>举一个简单的例子</strong>： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。</p><blockquote><ul><li>操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。</li><li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。</li><li>操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li><li>操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。</li></ul></blockquote><p>这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</p><h3 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h3><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p><blockquote><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></blockquote><p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p><h1 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h1><blockquote><p>ABA 问题是乐观锁一个常见的问题</p></blockquote><h3 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h3><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题</strong>。</p><p>JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就提供了此种能力，其中的 <code>compareAndSet</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h3 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h3><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p><h3 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h3><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作。</p><h1 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h1><blockquote><ul><li>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），</li><li>synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</li></ul></blockquote><blockquote><ol><li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li></ol></blockquote><p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，<strong>基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁与乐观锁&quot;&gt;&lt;/a&gt;悲观锁与乐观锁&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总是假设最坏的情况，每次去拿数据的时候都认为
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-线程池与Executor框架</title>
    <link href="http://www.herobin.top/2019/01/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8EExecutor%E6%A1%86%E6%9E%B6/"/>
    <id>http://www.herobin.top/2019/01/21/Java多线程-线程池与Executor框架/</id>
    <published>2019-01-21T01:35:22.000Z</published>
    <updated>2019-01-21T03:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-使用线程池的好处"><a href="#一-使用线程池的好处" class="headerlink" title="一 使用线程池的好处"></a>一 使用线程池的好处</h1><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>使用线程池的好处（《Java并发编程的艺术》）：</p><blockquote><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul></blockquote><h1 id="二-Executor框架"><a href="#二-Executor框架" class="headerlink" title="二 Executor框架"></a>二 Executor框架</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>Executor 框架是Java5之后引进的，在Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>补充：this逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><h2 id="2-2-Executor-框架结构-主要由三大部分组成"><a href="#2-2-Executor-框架结构-主要由三大部分组成" class="headerlink" title="2.2 Executor 框架结构(主要由三大部分组成)"></a>2.2 Executor 框架结构(主要由三大部分组成)</h2><h3 id="1-任务。"><a href="#1-任务。" class="headerlink" title="1 任务。"></a>1 任务。</h3><p>执行任务需要实现的<strong>Runnable接口</strong>或<strong>Callable接口</strong>。<br><strong>Runnable接口</strong>或<strong>Callable接口</strong>实现类都可以被<strong>ThreadPoolExecutor</strong>或<strong>ScheduledThreadPoolExecutor</strong>执行。</p><p><strong>两者的区别：</strong></p><blockquote><p>Runnable接口不会返回结果但是Callable接口可以返回结果。后面介绍Executors类的一些方法的时候会介绍到两者的相互转换。</p></blockquote><h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2 任务的执行"></a>2 任务的执行</h3><p>如下图所示，包括任务执行机制的<strong>核心接口Executor</strong> ，以及继承自Executor 接口的<strong>ExecutorService接口</strong>。<strong>ScheduledThreadPoolExecutor</strong>和<strong>ThreadPoolExecutor</strong>这两个关键类实现了<strong>ExecutorService接口</strong>。</p><blockquote><p>注意： 通过查看ScheduledThreadPoolExecutor源代码我们发现ScheduledThreadPoolExecutor实际上是继承了ThreadPoolExecutor并实现了ScheduledExecutorService ，而ScheduledExecutorService又实现了ExecutorService，正如我们下面给出的类关系图显示的一样。</p></blockquote><p>ThreadPoolExecutor类描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//AbstractExecutorService实现了ExecutorService接口</span><br><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor类描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//ScheduledExecutorService实现了ExecutorService接口</span><br><span class="line">public class ScheduledThreadPoolExecutor</span><br><span class="line">        extends ThreadPoolExecutor</span><br><span class="line">        implements ScheduledExecutorService</span><br></pre></td></tr></table></figure><p><img src="/uploads/190121java1/1.png" alt=""></p><h3 id="3-异步计算的结果"><a href="#3-异步计算的结果" class="headerlink" title="3 异步计算的结果"></a>3 异步计算的结果</h3><p><strong>Future接口</strong>以及Future接口的实现类<strong>FutureTask类</strong>。</p><p>当我们把<strong>Runnable接口</strong>或<strong>Callable接口</strong>的实现类提交（调用submit方法）给<strong>ThreadPoolExecutor</strong>或<strong>ScheduledThreadPoolExecutor</strong>时，会返回一个<strong>FutureTask对象</strong>。</p><p>我们以<strong>AbstractExecutorService接口</strong>中的一个submit方法为例子来看看源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的newTaskFor方法返回了一个FutureTask对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Executor框架的使用示意图"><a href="#2-3-Executor框架的使用示意图" class="headerlink" title="2.3 Executor框架的使用示意图"></a>2.3 Executor框架的使用示意图</h2><p><img src="/uploads/190121java1/2.png" alt=""></p><h3 id="1-主线程首先要创建实现Runnable或者Callable接口的任务对象。"><a href="#1-主线程首先要创建实现Runnable或者Callable接口的任务对象。" class="headerlink" title="1. 主线程首先要创建实现Runnable或者Callable接口的任务对象。"></a>1. 主线程首先要创建实现Runnable或者Callable接口的任务对象。</h3><p>备注： 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。</p><h3 id="2-然后可以把创建完成的Runnable对象直接交给ExecutorService执行"><a href="#2-然后可以把创建完成的Runnable对象直接交给ExecutorService执行" class="headerlink" title="2. 然后可以把创建完成的Runnable对象直接交给ExecutorService执行"></a>2. 然后可以把创建完成的Runnable对象直接交给ExecutorService执行</h3><p>（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（ExecutorService.submit（Runnable task）或ExecutorService.submit（Callable task））。</p><p>执行execute()方法和submit()方法的区别是什么呢？</p><blockquote><ul><li>1) execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>2) submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul></blockquote><h3 id="3-如果执行ExecutorService-submit（…），ExecutorService将返回一个实现Future接口的对象"><a href="#3-如果执行ExecutorService-submit（…），ExecutorService将返回一个实现Future接口的对象" class="headerlink" title="3. 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象"></a>3. 如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象</h3><p>（我们刚刚也提到过了执行execute()方法和submit()方法的区别，到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。</p><h3 id="4-最后，主线程可以执行FutureTask-get-方法来等待任务执行完成。主线程也可以执行FutureTask-cancel（boolean-mayInterruptIfRunning）来取消此任务的执行。"><a href="#4-最后，主线程可以执行FutureTask-get-方法来等待任务执行完成。主线程也可以执行FutureTask-cancel（boolean-mayInterruptIfRunning）来取消此任务的执行。" class="headerlink" title="4. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。"></a>4. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</h3><h1 id="三-ThreadPoolExecutor详解"><a href="#三-ThreadPoolExecutor详解" class="headerlink" title="三 ThreadPoolExecutor详解"></a>三 ThreadPoolExecutor详解</h1><p>线程池实现类ThreadPoolExecutor是Executor框架最核心的类，先来看一下这个类中比较重要的四个属性。</p><h2 id="3-1-ThreadPoolExecutor类的四个比较重要的属性"><a href="#3-1-ThreadPoolExecutor类的四个比较重要的属性" class="headerlink" title="3.1 ThreadPoolExecutor类的四个比较重要的属性"></a>3.1 ThreadPoolExecutor类的四个比较重要的属性</h2><p><img src="/uploads/190121java1/3.png" alt=""></p><h2 id="3-2-ThreadPoolExecutor类中提供的四个构造方法"><a href="#3-2-ThreadPoolExecutor类中提供的四个构造方法" class="headerlink" title="3.2 ThreadPoolExecutor类中提供的四个构造方法"></a>3.2 ThreadPoolExecutor类中提供的四个构造方法</h2><p>我们看最长的那个，其余三个都是在这个构造方法的基础上产生（给定某些默认参数的构造方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="line"></span><br><span class="line"> * @param keepAliveTime 当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，</span><br><span class="line"> *核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了keepAliveTime；</span><br><span class="line"> * @param unit  keepAliveTime参数的时间单位</span><br><span class="line"> * @param workQueue 等待队列，当任务提交时，如果线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列；</span><br><span class="line"> * </span><br><span class="line"> * @param threadFactory 执行者创建新线程时使用的工厂</span><br><span class="line"> * @param handler RejectedExecutionHandler类型的变量，表示线程池的饱和策略。</span><br><span class="line"> * 如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。</span><br><span class="line"> * 线程池提供了4种策略：</span><br><span class="line">    1.AbortPolicy：直接抛出异常，这是默认策略；</span><br><span class="line">    2.CallerRunsPolicy：用调用者所在的线程来执行任务；</span><br><span class="line">    3.DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</span><br><span class="line">    4.DiscardPolicy：直接丢弃任务；</span><br><span class="line"> */</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) &#123;</span><br><span class="line">    if (corePoolSize &lt; 0 ||</span><br><span class="line">        maximumPoolSize &lt;= 0 ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    this.corePoolSize = corePoolSize;</span><br><span class="line">    this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    this.workQueue = workQueue;</span><br><span class="line">    this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    this.threadFactory = threadFactory;</span><br><span class="line">    this.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-如何创建ThreadPoolExecutor"><a href="#3-3-如何创建ThreadPoolExecutor" class="headerlink" title="3.3 如何创建ThreadPoolExecutor"></a>3.3 如何创建ThreadPoolExecutor</h2><p>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</p><p>为什么呢？</p><blockquote><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>另外《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><blockquote><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</li></ul></blockquote><p><strong>方式一：通过构造方法实现</strong></p><p><img src="/uploads/190121java1/4.png" alt=""></p><p><strong>方式二：通过Executor 框架的工具类Executors来实现</strong></p><p>我们可以创建三种类型的ThreadPoolExecutor：</p><blockquote><ul><li>FixedThreadPool</li><li>SingleThreadExecutor</li><li>CachedThreadPool</li></ul></blockquote><p>对应Executors工具类中的方法如图所示：</p><p><img src="/uploads/190121java1/5.png" alt=""></p><h2 id="3-4-FixedThreadPool详解"><a href="#3-4-FixedThreadPool详解" class="headerlink" title="3.4 FixedThreadPool详解"></a>3.4 FixedThreadPool详解</h2><p>FixedThreadPool被称为可重用固定线程数的线程池。通过Executors类中的相关源代码来看一下相关实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">   * 创建一个可重用固定数量线程的线程池</span><br><span class="line">*在任何时候至多有n个线程处于活动状态</span><br><span class="line">*如果在所有线程处于活动状态时提交其他任务，则它们将在队列中等待，</span><br><span class="line">*直到线程可用。 如果任何线程在关闭之前的执行期间由于失败而终止，</span><br><span class="line">*如果需要执行后续任务，则一个新的线程将取代它。池中的线程将一直存在</span><br><span class="line">*知道调用shutdown方法</span><br><span class="line">   * @param nThreads 线程池中的线程数</span><br><span class="line">   * @param threadFactory 创建新线程时使用的factory</span><br><span class="line">   * @return 新创建的线程池</span><br><span class="line">   * @throws NullPointerException 如果threadFactory为null</span><br><span class="line">   * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125;</span><br><span class="line">   */</span><br><span class="line">  public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>另外还有一个FixedThreadPool的实现方法，和上面的类似，所以这里不多做阐述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的FixedThreadPool的corePoolSize和maximumPoolSize都被设置为nThreads。</p><p><strong>FixedThreadPool的execute()方法运行示意图（该图片来源：《Java并发编程的艺术》）：</strong></p><p><img src="/uploads/190121java1/6.png" alt=""></p><p>上图说明：</p><blockquote><ul><li><ol><li>如果当前运行的线程数小于corePoolSize，则创建新的线程来执行任务；</li></ol></li><li><ol start="2"><li>当前运行的线程数等于corePoolSize后，将任务加入LinkedBlockingQueue；</li></ol></li><li><ol start="3"><li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行；</li></ol></li></ul></blockquote><p><strong>FixedThreadPool使用无界队列 LinkedBlockingQueue（队列的容量为Intger.MAX_VALUE）作为线程池的工作队列会对线程池带来如下影响：</strong></p><blockquote><ul><li><ol><li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize；</li></ol></li><li><ol start="2"><li>由于1，使用无界队列时maximumPoolSize将是一个无效参数；</li></ol></li><li><ol start="3"><li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数；</li></ol></li><li><ol start="4"><li>运行中的FixedThreadPool（未执行shutdown()或shutdownNow()方法）不会拒绝任务</li></ol></li></ul></blockquote><h2 id="3-5-SingleThreadExecutor详解"><a href="#3-5-SingleThreadExecutor详解" class="headerlink" title="3.5 SingleThreadExecutor详解"></a>3.5 SingleThreadExecutor详解</h2><p>SingleThreadExecutor是使用单个worker线程的Executor。下面看看SingleThreadExecutor的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">   *创建使用单个worker线程运行无界队列的Executor</span><br><span class="line">*并使用提供的ThreadFactory在需要时创建新线程</span><br><span class="line">   *</span><br><span class="line">   * @param threadFactory 创建新线程时使用的factory</span><br><span class="line">   *</span><br><span class="line">   * @return 新创建的单线程Executor</span><br><span class="line">   * @throws NullPointerException 如果ThreadFactory为空</span><br><span class="line">   */</span><br><span class="line">  public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new FinalizableDelegatedExecutorService</span><br><span class="line">          (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">     return new FinalizableDelegatedExecutorService</span><br><span class="line">         (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                 0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                 new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从上面源代码可以看出新创建的SingleThreadExecutor的corePoolSize和maximumPoolSize都被设置为1.其他参数和FixedThreadPool相同。SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Intger.MAX_VALUE）。SingleThreadExecutor使用无界队列作为线程池的工作队列会对线程池带来的影响与FixedThreadPool相同。</p><p>SingleThreadExecutor的运行示意图（该图片来源：《Java并发编程的艺术》）：</p><p><img src="/uploads/190121java1/7.png" alt=""></p><p>上图说明;</p><blockquote><ul><li><ol><li>如果当前运行的线程数少于corePoolSize，则创建一个新的线程执行任务；</li></ol></li><li><ol start="2"><li>当前线程池中有一个运行的线程后，将任务加入LinkedBlockingQueue;</li></ol></li><li><ol start="3"><li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue中获取任务来执行；</li></ol></li></ul></blockquote><h2 id="3-6-CachedThreadPool详解"><a href="#3-6-CachedThreadPool详解" class="headerlink" title="3.6 CachedThreadPool详解"></a>3.6 CachedThreadPool详解</h2><p>CachedThreadPool是一个会根据需要创建新线程的线程池。下面通过源码来看看 CachedThreadPool的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它，</span><br><span class="line">*并在需要时使用提供的ThreadFactory创建新线程。</span><br><span class="line">   * @param threadFactory 创建新线程使用的factory</span><br><span class="line">   * @return 新创建的线程池</span><br><span class="line">   * @throws NullPointerException 如果threadFactory为空</span><br><span class="line">   */</span><br><span class="line">  public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                    60L, TimeUnit.SECONDS,</span><br><span class="line">                                    new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool的corePoolSize被设置为空（0），maximumPoolSize被设置为Integer.MAX.VALUE，即它是无界的，这也就意味着如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新的线程。极端情况下，这样会导致耗尽cpu和内存资源。</p><p>CachedThreadPool的execute()方法的执行示意图（该图片来源：《Java并发编程的艺术》）：</p><p><img src="/uploads/190121java1/8.png" alt=""></p><p>上图说明：</p><blockquote><ul><li><ol><li>首先执行SynchronousQueue.offer(Runnable task)。如果当前maximumPool中有闲线程正在执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成，否则执行下面的步骤2；</li></ol></li><li><ol start="2"><li>当初始maximumPool为空，或者maximumPool中没有空闲线程时，将没有线程执行SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤1将失败，此时CachedThreadPool会创建新线程执行任务，execute方法执行完成；</li></ol></li></ul></blockquote><h2 id="3-7-ThreadPoolExecutor使用示例"><a href="#3-7-ThreadPoolExecutor使用示例" class="headerlink" title="3.7 ThreadPoolExecutor使用示例"></a>3.7 ThreadPoolExecutor使用示例</h2><h3 id="3-7-1-示例代码"><a href="#3-7-1-示例代码" class="headerlink" title="3.7.1 示例代码"></a>3.7.1 示例代码</h3><p>首先创建一个Runnable接口的实现类（当然也可以是Callable接口，我们上面也说了两者的区别是：Runnable接口不会返回结果但是Callable接口可以返回结果。后面介绍Executors类的一些方法的时候会介绍到两者的相互转换。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span><br><span class="line"> */</span><br><span class="line">public class WorkerThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String command;</span><br><span class="line"></span><br><span class="line">    public WorkerThread(String s) &#123;</span><br><span class="line">        this.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; Start. Time = &quot; + new Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; End. Time = &quot; + new Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void processCommand() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return this.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试程序，我们这里以FixedThreadPool为例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutorDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建一个FixedThreadPool对象</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(5);</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span><br><span class="line">            Runnable worker = new WorkerThread(&quot;&quot; + i);</span><br><span class="line">            //执行Runnable</span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        //终止线程池</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        while (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-5 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Thu May 31 10:22:52 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-5 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Thu May 31 10:22:57 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Thu May 31 10:23:02 CST 2018</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h3 id="3-7-2-shutdown（）VS-shutdownNow（）"><a href="#3-7-2-shutdown（）VS-shutdownNow（）" class="headerlink" title="3.7.2 shutdown（）VS shutdownNow（）"></a>3.7.2 shutdown（）VS shutdownNow（）</h3><p>shutdown（）方法表明关闭已在Executor上调用，因此不会再向DelayedPool添加任何其他任务（由ScheduledThreadPoolExecutor类在内部使用）。 但是，已经在队列中提交的任务将被允许完成。<br>另一方面，shutdownNow（）方法试图终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的List。</p><h3 id="3-7-3-isTerminated-Vs-isShutdown"><a href="#3-7-3-isTerminated-Vs-isShutdown" class="headerlink" title="3.7.3 isTerminated() Vs isShutdown()"></a>3.7.3 isTerminated() Vs isShutdown()</h3><p>isShutdown（）表示执行程序正在关闭，但并非所有任务都已完成执行。<br>另一方面，isShutdown（）表示所有线程都已完成执行。</p><h1 id="四-ScheduledThreadPoolExecutor详解"><a href="#四-ScheduledThreadPoolExecutor详解" class="headerlink" title="四 ScheduledThreadPoolExecutor详解"></a>四 ScheduledThreadPoolExecutor详解</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h2><p>ScheduledThreadPoolExecutor主要用来在给定的延迟后运行任务，或者定期执行任务。</p><p>ScheduledThreadPoolExecutor使用的任务队列DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(ScheduledFutureTask的time变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(ScheduledFutureTask的squenceNumber变量小的先执行)。</p><p>ScheduledThreadPoolExecutor和Timer的比较：</p><blockquote><ul><li>Timer对系统时钟的变化敏感，ScheduledThreadPoolExecutor不是；</li><li>Timer只有一个执行线程，因此长时间运行的任务可以延迟其他任务。 ScheduledThreadPoolExecutor可以配置任意数量的线程。 此外，如果你想（通过提供ThreadFactory），你可以完全控制创建的线程;</li><li>在TimerTask中抛出的运行时异常会杀死一个线程，从而导致Timer死机:-( …即计划任务将不再运行。ScheduledThreadExecutor不仅捕获运行时异常，还允许您在需要时处理它们（通过重写afterExecute方法 ThreadPoolExecutor）。抛出异常的任务将被取消，但其他任务将继续运行。</li></ul></blockquote><p>综上，在JDK1.5之后，你没有理由再使用Timer进行任务调度了。</p><blockquote><p>备注： Quartz是一个由java编写的任务调度库，由OpenSymphony组织开源出来。在实际项目开发中使用Quartz的还是居多，比较推荐使用Quartz。因为Quartz理论上能够同时对上万个任务进行调度，拥有丰富的功能特性，包括任务调度、任务持久化、可集群化、插件等等。</p></blockquote><h2 id="4-2-ScheduledThreadPoolExecutor运行机制"><a href="#4-2-ScheduledThreadPoolExecutor运行机制" class="headerlink" title="4.2 ScheduledThreadPoolExecutor运行机制"></a>4.2 ScheduledThreadPoolExecutor运行机制</h2><p><img src="/uploads/190121java1/9.png" alt=""></p><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p><blockquote><ol><li>当调用ScheduledThreadPoolExecutor的 scheduleAtFixedRate() 方法或者scheduleWirhFixedDelay() 方法时，会向ScheduledThreadPoolExecutor的 DelayQueue 添加一个实现了 RunnableScheduledFutur 接口的 ScheduledFutureTask 。</li><li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li></ol></blockquote><p>ScheduledThreadPoolExecutor为了实现周期性的执行任务，对ThreadPoolExecutor做了如下修改：</p><blockquote><ul><li>使用 DelayQueue 作为任务队列；</li><li>获取任务的方不同</li><li>执行周期任务后，增加了额外的处理</li></ul></blockquote><h2 id="4-3-ScheduledThreadPoolExecutor执行周期任务的步骤"><a href="#4-3-ScheduledThreadPoolExecutor执行周期任务的步骤" class="headerlink" title="4.3 ScheduledThreadPoolExecutor执行周期任务的步骤"></a>4.3 ScheduledThreadPoolExecutor执行周期任务的步骤</h2><p><img src="/uploads/190121java1/10.png" alt=""></p><blockquote><ol><li>线程1从DelayQueue中获取已到期的ScheduledFutureTask（DelayQueue.take()）。到期任务是指ScheduledFutureTask的time大于等于当前系统的时间；</li><li>线程1执行这个ScheduledFutureTask；</li><li>线程1修改ScheduledFutureTask的time变量为下次将要被执行的时间；</li><li>线程1把这个修改time之后的ScheduledFutureTask放回DelayQueue中（DelayQueue.add())。</li></ol></blockquote><h2 id="4-4-ScheduledThreadPoolExecutor使用示例"><a href="#4-4-ScheduledThreadPoolExecutor使用示例" class="headerlink" title="4.4 ScheduledThreadPoolExecutor使用示例"></a>4.4 ScheduledThreadPoolExecutor使用示例</h2><blockquote><ol><li>创建一个简单的实现Runnable接口的类（我们上面的例子已经实现过）</li><li>测试程序使用ScheduledExecutorService和ScheduledThreadPoolExecutor实现的java调度。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用ScheduledExecutorService和ScheduledThreadPoolExecutor实现的java调度程序示例程序。</span><br><span class="line"> */</span><br><span class="line">public class ScheduledThreadPoolDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建一个ScheduledThreadPoolExecutor对象</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);</span><br><span class="line">        //计划在某段时间后运行</span><br><span class="line">        System.out.println(&quot;Current Time = &quot;+new Date());</span><br><span class="line">        for(int i=0; i&lt;3; i++)&#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;);</span><br><span class="line">            //创建并执行在给定延迟后启用的单次操作。 </span><br><span class="line">            scheduledThreadPool.schedule(worker, 10, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //添加一些延迟让调度程序产生一些线程</span><br><span class="line">        Thread.sleep(30000);</span><br><span class="line">        System.out.println(&quot;Current Time = &quot;+new Date());</span><br><span class="line">        //关闭线程池</span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        while(!scheduledThreadPool.isTerminated())&#123;</span><br><span class="line">            //等待所有任务完成</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Finished all threads&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Current Time = Wed May 30 17:11:16 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:11:27 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:11:28 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:11:29 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:11:32 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:11:33 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:11:34 CST 2018</span><br><span class="line">Current Time = Wed May 30 17:11:49 CST 2018</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h3 id="4-4-1-ScheduledExecutorService-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit-方法"><a href="#4-4-1-ScheduledExecutorService-scheduleAtFixedRate-Runnable-command-long-initialDelay-long-period-TimeUnit-unit-方法" class="headerlink" title="4.4.1 ScheduledExecutorService scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)方法"></a>4.4.1 ScheduledExecutorService scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)方法</h3><p>我们可以使用ScheduledExecutorService scheduleAtFixedRate方法来安排任务在初始延迟后运行，然后在给定的时间段内运行。</p><p>时间段是从池中第一个线程的开始，因此如果您将period指定为1秒并且线程运行5秒，那么只要第一个工作线程完成执行，下一个线程就会开始执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;);</span><br><span class="line">// schedule task to execute at fixed rate</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(worker, 0, 10,</span><br><span class="line">TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Current Time = Wed May 30 17:47:09 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:10 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:47:11 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:47:12 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:15 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:47:16 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:47:17 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:20 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:47:21 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:47:22 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:25 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:47:26 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:47:27 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:30 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:47:31 CST 2018</span><br><span class="line">pool-1-thread-5 Start. Time = Wed May 30 17:47:32 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:35 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:47:36 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Wed May 30 17:47:37 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:47:40 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:47:41 CST 2018</span><br><span class="line">Current Time = Wed May 30 17:47:42 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:47:45 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:47:46 CST 2018</span><br><span class="line">Finished all threads</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="4-4-2-ScheduledExecutorService-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit-方法"><a href="#4-4-2-ScheduledExecutorService-scheduleWithFixedDelay-Runnable-command-long-initialDelay-long-delay-TimeUnit-unit-方法" class="headerlink" title="4.4.2 ScheduledExecutorService scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)方法"></a>4.4.2 ScheduledExecutorService scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)方法</h3><p>ScheduledExecutorService scheduleWithFixedDelay方法可用于以初始延迟启动周期性执行，然后以给定延迟执行。 延迟时间是线程完成执行的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">WorkerThread worker = new WorkerThread(&quot;do heavy processing&quot;);</span><br><span class="line">scheduledThreadPool.scheduleWithFixedDelay(worker, 0, 1,</span><br><span class="line">TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Current Time = Wed May 30 17:58:09 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:10 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:11 CST 2018</span><br><span class="line">pool-1-thread-3 Start. Time = Wed May 30 17:58:12 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:15 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:16 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:16 CST 2018</span><br><span class="line">pool-1-thread-3 End. Time = Wed May 30 17:58:17 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:17 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:18 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:21 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:22 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:22 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:23 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:23 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:24 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:27 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:28 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:28 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:29 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:29 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:30 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:33 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:34 CST 2018</span><br><span class="line">pool-1-thread-1 Start. Time = Wed May 30 17:58:34 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:35 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:35 CST 2018</span><br><span class="line">pool-1-thread-4 Start. Time = Wed May 30 17:58:36 CST 2018</span><br><span class="line">pool-1-thread-1 End. Time = Wed May 30 17:58:39 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:40 CST 2018</span><br><span class="line">pool-1-thread-5 Start. Time = Wed May 30 17:58:40 CST 2018</span><br><span class="line">pool-1-thread-4 End. Time = Wed May 30 17:58:41 CST 2018</span><br><span class="line">pool-1-thread-2 Start. Time = Wed May 30 17:58:41 CST 2018</span><br><span class="line">Current Time = Wed May 30 17:58:42 CST 2018</span><br><span class="line">pool-1-thread-5 End. Time = Wed May 30 17:58:45 CST 2018</span><br><span class="line">pool-1-thread-2 End. Time = Wed May 30 17:58:46 CST 2018</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h3 id="4-4-3-scheduleWithFixedDelay-vs-scheduleAtFixedRate"><a href="#4-4-3-scheduleWithFixedDelay-vs-scheduleAtFixedRate" class="headerlink" title="4.4.3 scheduleWithFixedDelay() vs scheduleAtFixedRate()"></a>4.4.3 scheduleWithFixedDelay() vs scheduleAtFixedRate()</h3><p>scheduleAtFixedRate（…）将延迟视为两个任务开始之间的差异（即定期调用）<br>scheduleWithFixedDelay（…）将延迟视为一个任务结束与下一个任务开始之间的差异</p><blockquote><ul><li><strong>scheduleAtFixedRate()</strong>: 创建并执行在给定的初始延迟之后，随后以给定的时间段首先启用的周期性动作; 那就是执行将在initialDelay之后开始，然后initialDelay+period ，然后是initialDelay + 2 * period ，等等。 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行人终止。 如果任务执行时间比其周期长，则后续执行可能会迟到，但不会同时执行。</li><li><strong>scheduleWithFixedDelay()</strong> : 创建并执行在给定的初始延迟之后首先启用的定期动作，随后在一个执行的终止和下一个执行的开始之间给定的延迟。 如果任务的执行遇到异常，则后续的执行被抑制。 否则，任务将仅通过取消或终止执行终止。</li></ul></blockquote><h1 id="五-各种线程池的适用场景介绍"><a href="#五-各种线程池的适用场景介绍" class="headerlink" title="五 各种线程池的适用场景介绍"></a>五 各种线程池的适用场景介绍</h1><blockquote><p><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</p></blockquote><blockquote><p><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。</p></blockquote><blockquote><p><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</p></blockquote><blockquote><p><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景，</p></blockquote><blockquote><p><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</p></blockquote><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h1><p>本节只是简单的介绍了一下使用线程池的好处，然后花了大量篇幅介绍Executor 框架。详细介绍了Executor 框架中ThreadPoolExecutor和ScheduledThreadPoolExecutor，并且通过实例详细讲解了ScheduledThreadPoolExecutor的使用。对于FutureTask 只是粗略带过，因为篇幅问题，并没有深究它的原理，后面的文章会进行补充。这一篇文章只是大概带大家过一下线程池的基本概览，深入讲解的地方不是很多，后续会通过源码深入研究其中比较重要的一些知识点。</p><p>原博链接：<a href="https://blog.csdn.net/qq_34337272/article/details/79959271" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/79959271</a> （侵权删）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-使用线程池的好处&quot;&gt;&lt;a href=&quot;#一-使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;一 使用线程池的好处&quot;&gt;&lt;/a&gt;一 使用线程池的好处&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;线程池&lt;/strong&gt;提供了一种限制和管理资源（包括执行一
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-Lock锁的使用</title>
    <link href="http://www.herobin.top/2019/01/19/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-Lock%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/01/19/Java多线程-Lock锁的使用/</id>
    <published>2019-01-19T05:46:15.000Z</published>
    <updated>2019-01-19T06:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock锁的使用"><a href="#Lock锁的使用" class="headerlink" title="Lock锁的使用"></a>Lock锁的使用</h1><h2 id="一-Lock接口"><a href="#一-Lock接口" class="headerlink" title="一 Lock接口"></a>一 Lock接口</h2><h3 id="1-1-Lock接口简介"><a href="#1-1-Lock接口简介" class="headerlink" title="1.1 Lock接口简介"></a>1.1 Lock接口简介</h3><font color="red">锁是用于通过多个线程控制对共享资源的访问的工具</font>。通常，锁提供对共享资源的独占访问：一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，一些锁可能允许并发访问共享资源，如ReadWriteLock的读写锁。<br><br><font color="red">在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的。JDK1.5之后并发包中新增了Lock接口以及相关实现类来实现锁功能。</font><p>虽然synchronized方法和语句的范围机制使得使用监视器锁更容易编程，并且有助于避免涉及锁的许多常见编程错误，但是有时您需要以更灵活的方式处理锁。例如，用于遍历并发访问的数据结构的一些算法需要使用“手动”或“链锁定”：您获取节点A的锁定，然后获取节点B，然后释放A并获取C，然后释放B并获得D等。在这种场景中synchronized关键字就不那么容易实现了，使用Lock接口容易很多。</p><p><strong>Lock接口的实现类： </strong></p><p>ReentrantLock ， ReentrantReadWriteLock.ReadLock ， ReentrantReadWriteLock.WriteLock</p><h3 id="1-2-Lock的简单使用"><a href="#1-2-Lock的简单使用" class="headerlink" title="1.2 Lock的简单使用"></a>1.2 Lock的简单使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock=new ReentrantLock()；</span><br><span class="line">lock.lock();</span><br><span class="line"> try&#123;</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><font color="red">因为Lock是接口所以使用时要结合它的实现类，另外在finall语句块中释放锁的目的是保证获取到锁之后，最终能够被释放。</font><p>注意： 最好不要把获取锁的过程写在try语句块中，因为如果在获取锁时发生了异常，异常抛出的同时也会导致锁无法被释放。</p><h3 id="1-3-Lock接口的特性和常见方法"><a href="#1-3-Lock接口的特性和常见方法" class="headerlink" title="1.3 Lock接口的特性和常见方法"></a>1.3 Lock接口的特性和常见方法</h3><p>Lock接口提供的synchronized关键字不具备的主要特性：</p><blockquote><ul><li><strong>尝试非阻塞地获取锁</strong>    当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li><li><strong>能被中断地获取锁</strong>    获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li><li><strong>超时获取锁</strong>    在指定的截止时间之前获取锁， 超过截止时间后仍旧无法获取则返回</li></ul></blockquote><p>Lock接口基本的方法：</p><blockquote><ul><li><strong>void lock()</strong>    获得锁。如果锁不可用，则当前线程将被禁用以进行线程调度，并处于休眠状态，直到获取锁。</li><li><strong>void lockInterruptibly()</strong>    获取锁，如果可用并立即返回。如果锁不可用，那么当前线程将被禁用以进行线程调度，并且处于休眠状态，和lock()方法不同的是在锁的获取中可以中断当前线程（相应中断）。</li><li><strong>Condition newCondition()</strong>    获取等待通知组件，该组件和当前的锁绑定，当前线程只有获得了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁。</li><li><strong>boolean tryLock()</strong> 只有在调用时才可以获得锁。如果可用，则获取锁定，并立即返回值为true；如果锁不可用，则此方法将立即返回值为false 。</li><li><strong>boolean tryLock(long time, TimeUnit unit)</strong>    超时获取锁，当前线程在一下三种情况下会返回： 1. 当前线程在超时时间内获得了锁；2.当前线程在超时时间内被中断；3.超时时间结束，返回false.</li><li><strong>void unlock()</strong>    释放锁。</li></ul></blockquote><h2 id="二-Lock接口的实现类：ReentrantLock"><a href="#二-Lock接口的实现类：ReentrantLock" class="headerlink" title="二 Lock接口的实现类：ReentrantLock"></a>二 Lock接口的实现类：ReentrantLock</h2><p><strong>ReentrantLock</strong>和<strong>synchronized关键字</strong>一样可以用来实现线程之间的同步互斥，但是在功能是比synchronized关键字更强大而且更灵活。</p><p><strong>ReentrantLock类常见方法：</strong></p><p>构造方法：</p><p><strong>ReentrantLock()</strong>    创建一个 ReentrantLock的实例。<br><strong>ReentrantLock(boolean fair)</strong>    创建一个特定锁类型（公平锁/非公平锁）的ReentrantLock的实例</p><p>ReentrantLock类常见方法(Lock接口已有方法这里没加上)：</p><blockquote><ul><li>int getHoldCount()    查询当前线程保持此锁定的个数，也就是调用lock()方法的次数。</li><li>protected Thread getOwner()    返回当前拥有此锁的线程，如果不拥有，则返回 null</li><li>protected Collection getQueuedThreads()    返回包含可能正在等待获取此锁的线程的集合</li><li>int getQueueLength()    返回等待获取此锁的线程数的估计。</li><li>protected Collection getWaitingThreads(Condition condition)    返回包含可能在与此锁相关联的给定条件下等待的线程的集合。</li><li>int getWaitQueueLength(Condition condition)    返回与此锁相关联的给定条件等待的线程数的估计。</li><li>boolean hasQueuedThread(Thread thread)    查询给定线程是否等待获取此锁。</li><li>boolean hasQueuedThreads()    查询是否有线程正在等待获取此锁。</li><li>boolean hasWaiters(Condition condition)    查询任何线程是否等待与此锁相关联的给定条件</li><li>boolean isFair()    如果此锁的公平设置为true，则返回 true 。</li><li>boolean isHeldByCurrentThread()    查询此锁是否由当前线程持有。</li><li>boolean isLocked()    查询此锁是否由任何线程持有。</li></ul></blockquote><h3 id="2-1-第一个ReentrantLock程序"><a href="#2-1-第一个ReentrantLock程序" class="headerlink" title="2.1 第一个ReentrantLock程序"></a>2.1 第一个ReentrantLock程序</h3><p>ReentrantLockTest.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ReentrantLockTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        MyService service = new MyService();</span><br><span class="line"></span><br><span class="line">        MyThread a1 = new MyThread(service);</span><br><span class="line">        MyThread a2 = new MyThread(service);</span><br><span class="line">        MyThread a3 = new MyThread(service);</span><br><span class="line">        MyThread a4 = new MyThread(service);</span><br><span class="line">        MyThread a5 = new MyThread(service);</span><br><span class="line"></span><br><span class="line">        a1.start();</span><br><span class="line">        a2.start();</span><br><span class="line">        a3.start();</span><br><span class="line">        a4.start();</span><br><span class="line">        a5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyService &#123;</span><br><span class="line"></span><br><span class="line">        private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">        public void testMethod() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName() + (&quot; &quot; + (i + 1)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyService service;</span><br><span class="line"></span><br><span class="line">        public MyThread(MyService service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.testMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ThreadName=Thread-0 1</span><br><span class="line">ThreadName=Thread-0 2</span><br><span class="line">ThreadName=Thread-0 3</span><br><span class="line">ThreadName=Thread-0 4</span><br><span class="line">ThreadName=Thread-0 5</span><br><span class="line">ThreadName=Thread-1 1</span><br><span class="line">ThreadName=Thread-1 2</span><br><span class="line">ThreadName=Thread-1 3</span><br><span class="line">ThreadName=Thread-1 4</span><br><span class="line">ThreadName=Thread-1 5</span><br><span class="line">ThreadName=Thread-2 1</span><br><span class="line">ThreadName=Thread-2 2</span><br><span class="line">ThreadName=Thread-2 3</span><br><span class="line">ThreadName=Thread-2 4</span><br><span class="line">ThreadName=Thread-2 5</span><br><span class="line">ThreadName=Thread-3 1</span><br><span class="line">ThreadName=Thread-3 2</span><br><span class="line">ThreadName=Thread-3 3</span><br><span class="line">ThreadName=Thread-3 4</span><br><span class="line">ThreadName=Thread-3 5</span><br><span class="line">ThreadName=Thread-4 1</span><br><span class="line">ThreadName=Thread-4 2</span><br><span class="line">ThreadName=Thread-4 3</span><br><span class="line">ThreadName=Thread-4 4</span><br><span class="line">ThreadName=Thread-4 5</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，<font color="red">当一个线程运行完毕后才把锁释放，其他线程才能执行，其他线程的执行顺序是不确定的</font>。</p><h3 id="2-2-Condition接口简介"><a href="#2-2-Condition接口简介" class="headerlink" title="2.2 Condition接口简介"></a>2.2 Condition接口简介</h3><p>我们通过之前的学习知道了：<strong>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法</strong>。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在<strong>一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活</strong>。</p><p>在使用notify/notifyAll()方法进行通知时，被通知的线程是有JVM选择的，使用ReentrantLock类结合Condition实例可以实现<strong>“选择性通知”</strong>，这个功能非常重要，而且是Condition接口默认提供的。</p><p>而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</p><p><strong>Condition接口的常见方法：</strong></p><blockquote><ul><li>void await()    相当于Object类的wait方法</li><li>boolean await(long time, TimeUnit unit)    相当于Object类的wait(long timeout)方法</li><li>signal()    相当于Object类的notify方法</li><li>signalAll()    相当于Object类的notifyAll方法</li></ul></blockquote><h3 id="2-3-使用Condition实现等待-通知机制"><a href="#2-3-使用Condition实现等待-通知机制" class="headerlink" title="2.3 使用Condition实现等待/通知机制"></a>2.3 使用Condition实现等待/通知机制</h3><p><strong>1. 使用单个Condition实例实现等待/通知机制：</strong></p><p>UseSingleConditionWaitNotify.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class UseSingleConditionWaitNotify &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyService service = new MyService();</span><br><span class="line"></span><br><span class="line">        ThreadA a = new ThreadA(service);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        service.signal();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyService &#123;</span><br><span class="line"></span><br><span class="line">        private Lock lock = new ReentrantLock();</span><br><span class="line">        public Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        public void await() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot; await时间为&quot; + System.currentTimeMillis());</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(&quot;这是condition.await()方法之后的语句，condition.signal()方法之后我才被执行&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void signal() throws InterruptedException &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;signal时间为&quot; + System.currentTimeMillis());</span><br><span class="line">                condition.signal();</span><br><span class="line">                Thread.sleep(3000);</span><br><span class="line">                System.out.println(&quot;这是condition.signal()方法之后的语句&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyService service;</span><br><span class="line"></span><br><span class="line">        public ThreadA(MyService service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190119java1/1.png" alt=""></p><p><strong>在使用wait/notify实现等待通知机制的时候我们知道必须执行完notify()方法所在的synchronized代码块后才释放锁。在这里也差不多，必须执行完signal所在的try语句块之后才释放锁，condition.await()后的语句才能被执行。</strong></p><p>注意： 必须在condition.await()方法调用之前调用lock.lock()代码获得同步监视器，不然会报错。</p><p><strong>2. 使用多个Condition实例实现等待/通知机制：</strong></p><p>UseMoreConditionWaitNotify.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class UseMoreConditionWaitNotify &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyserviceMoreCondition service = new MyserviceMoreCondition();</span><br><span class="line"></span><br><span class="line">        ThreadA a = new ThreadA(service);</span><br><span class="line">        a.setName(&quot;A&quot;);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = new ThreadB(service);</span><br><span class="line">        b.setName(&quot;B&quot;);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line"></span><br><span class="line">        service.signalAll_A();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyserviceMoreCondition service;</span><br><span class="line"></span><br><span class="line">        public ThreadA(MyserviceMoreCondition service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.awaitA();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadB extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        private MyserviceMoreCondition service;</span><br><span class="line"></span><br><span class="line">        public ThreadB(MyserviceMoreCondition service) &#123;</span><br><span class="line">            super();</span><br><span class="line">            this.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            service.awaitB();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyserviceMoreCondition.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class MyserviceMoreCondition &#123;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line">    public Condition conditionA = lock.newCondition();</span><br><span class="line">    public Condition conditionB = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public void awaitA() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;begin awaitA时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionA.await();</span><br><span class="line">            System.out.println(&quot;  end awaitA时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void awaitB() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;begin awaitB时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionB.await();</span><br><span class="line">            System.out.println(&quot;  end awaitB时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void signalAll_A() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;  signalAll_A时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void signalAll_B() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(&quot;  signalAll_B时间为&quot; + System.currentTimeMillis()</span><br><span class="line">                    + &quot; ThreadName=&quot; + Thread.currentThread().getName());</span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190119java1/2.png" alt=""></p><p>只有A线程被唤醒了。</p><p><strong>3. 使用Condition实现顺序执行</strong></p><p>ConditionSeqExec.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class ConditionSeqExec &#123;</span><br><span class="line"></span><br><span class="line">    volatile private static int nextPrintWho = 1;</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    final private static Condition conditionA = lock.newCondition();</span><br><span class="line">    final private static Condition conditionB = lock.newCondition();</span><br><span class="line">    final private static Condition conditionC = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (nextPrintWho != 1) &#123;</span><br><span class="line">                        conditionA.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;ThreadA &quot; + (i + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = 2;</span><br><span class="line">                    //通知conditionB实例的线程运行</span><br><span class="line">                    conditionB.signalAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadB = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (nextPrintWho != 2) &#123;</span><br><span class="line">                        conditionB.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;ThreadB &quot; + (i + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = 3;</span><br><span class="line">                    //通知conditionC实例的线程运行</span><br><span class="line">                    conditionC.signalAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread threadC = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    while (nextPrintWho != 3) &#123;</span><br><span class="line">                        conditionC.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">                        System.out.println(&quot;ThreadC &quot; + (i + 1));</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextPrintWho = 1;</span><br><span class="line">                    //通知conditionA实例的线程运行</span><br><span class="line">                    conditionA.signalAll();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread[] aArray = new Thread[5];</span><br><span class="line">        Thread[] bArray = new Thread[5];</span><br><span class="line">        Thread[] cArray = new Thread[5];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            aArray[i] = new Thread(threadA);</span><br><span class="line">            bArray[i] = new Thread(threadB);</span><br><span class="line">            cArray[i] = new Thread(threadC);</span><br><span class="line"></span><br><span class="line">            aArray[i].start();</span><br><span class="line">            bArray[i].start();</span><br><span class="line">            cArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br><span class="line">ThreadA 1</span><br><span class="line">ThreadA 2</span><br><span class="line">ThreadA 3</span><br><span class="line">ThreadB 1</span><br><span class="line">ThreadB 2</span><br><span class="line">ThreadB 3</span><br><span class="line">ThreadC 1</span><br><span class="line">ThreadC 2</span><br><span class="line">ThreadC 3</span><br></pre></td></tr></table></figure><p>通过代码很好理解，说简单就是在一个线程运行完之后通过condition.singal()/condition.signalAll()方法通知下一个特定的线程运行，就这样循环往复即可。</p><p>注意：默认情况下ReentranLock类使用的是非公平锁。</p><p><strong>2.4 公平锁与非公平锁</strong></p><p>Lock锁分为：<strong>公平锁</strong> 和 <strong>非公平锁</strong>。公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的<strong>FIFO先进先出顺序</strong>。而非公平锁就是一种获取锁的抢占机制，是<strong>随机获取</strong>锁的，和公平锁不一样的就是先来的不一定先的到锁，这样可能造成某些线程一直拿不到锁，结果也就是不公平的了。</p><p>FairorNofairLock.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class FairorNofairLock &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Service service = new Service(true);//true为公平锁，false为非公平锁</span><br><span class="line"></span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;★线程&quot; + Thread.currentThread().getName()</span><br><span class="line">                        + &quot;运行了&quot;);</span><br><span class="line">                service.serviceMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread[] threadArray = new Thread[10];</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            threadArray[i] = new Thread(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            threadArray[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static public class Service &#123;</span><br><span class="line"></span><br><span class="line">        private ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">        public Service(boolean isFair) &#123;</span><br><span class="line">            super();</span><br><span class="line">            lock = new ReentrantLock(isFair);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void serviceMethod() &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()</span><br><span class="line">                        + &quot;获得锁定&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">★线程Thread-0运行了</span><br><span class="line">★线程Thread-2运行了</span><br><span class="line">★线程Thread-1运行了</span><br><span class="line">ThreadName=Thread-0获得锁定</span><br><span class="line">★线程Thread-3运行了</span><br><span class="line">★线程Thread-4运行了</span><br><span class="line">★线程Thread-5运行了</span><br><span class="line">ThreadName=Thread-2获得锁定</span><br><span class="line">ThreadName=Thread-1获得锁定</span><br><span class="line">★线程Thread-6运行了</span><br><span class="line">★线程Thread-7运行了</span><br><span class="line">ThreadName=Thread-3获得锁定</span><br><span class="line">ThreadName=Thread-4获得锁定</span><br><span class="line">★线程Thread-8运行了</span><br><span class="line">ThreadName=Thread-5获得锁定</span><br><span class="line">ThreadName=Thread-6获得锁定</span><br><span class="line">ThreadName=Thread-7获得锁定</span><br><span class="line">★线程Thread-9运行了</span><br><span class="line">ThreadName=Thread-8获得锁定</span><br><span class="line">ThreadName=Thread-9获得锁定</span><br></pre></td></tr></table></figure><p>公平锁的运行结果是有序的。</p><p>把Service的参数修改为false则为非公平锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Service service = new Service(false); //true为公平锁，false为非公平锁</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">★线程Thread-1运行了</span><br><span class="line">★线程Thread-3运行了</span><br><span class="line">★线程Thread-2运行了</span><br><span class="line">★线程Thread-0运行了</span><br><span class="line">★线程Thread-4运行了</span><br><span class="line">ThreadName=Thread-1获得锁定</span><br><span class="line">★线程Thread-5运行了</span><br><span class="line">ThreadName=Thread-5获得锁定</span><br><span class="line">★线程Thread-6运行了</span><br><span class="line">ThreadName=Thread-6获得锁定</span><br><span class="line">★线程Thread-7运行了</span><br><span class="line">ThreadName=Thread-2获得锁定</span><br><span class="line">ThreadName=Thread-3获得锁定</span><br><span class="line">★线程Thread-8运行了</span><br><span class="line">ThreadName=Thread-0获得锁定</span><br><span class="line">ThreadName=Thread-4获得锁定</span><br><span class="line">ThreadName=Thread-7获得锁定</span><br><span class="line">★线程Thread-9运行了</span><br><span class="line">ThreadName=Thread-8获得锁定</span><br><span class="line">ThreadName=Thread-9获得锁定</span><br></pre></td></tr></table></figure><p>非公平锁的运行结果是无序的。</p><h2 id="三-ReadWriteLock接口的实现类：ReentrantReadWriteLock"><a href="#三-ReadWriteLock接口的实现类：ReentrantReadWriteLock" class="headerlink" title="三 ReadWriteLock接口的实现类：ReentrantReadWriteLock"></a>三 ReadWriteLock接口的实现类：ReentrantReadWriteLock</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>我们刚刚接触到的<strong>ReentrantLock（排他锁）</strong>具有完全互斥排他的效果，即<strong>同一时刻只允许一个线程访问</strong>，这样做虽然虽然保证了实例变量的线程安全性，但效率非常低下。ReadWriteLock接口的实现类-ReentrantReadWriteLock读写锁就是为了解决这个问题。</p><p><strong>读写锁维护了两个锁，一个是读操作相关的锁也成为共享锁，一个是写操作相关的锁 也称为排他锁。通过分离读锁和写锁，其并发性比一般排他锁有了很大提升。</strong></p><p><strong>多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥（只要出现写操作的过程就是互斥的）</strong>。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。</p><h3 id="3-2-ReentrantReadWriteLock的特性与常见方法"><a href="#3-2-ReentrantReadWriteLock的特性与常见方法" class="headerlink" title="3.2 ReentrantReadWriteLock的特性与常见方法"></a>3.2 ReentrantReadWriteLock的特性与常见方法</h3><p>ReentrantReadWriteLock的特性：</p><blockquote><ul><li><strong>公平性选择</strong>    支持非公平（默认）和公平的锁获取方式，吞吐量上来看还是非公平优于公平</li><li><strong>重进入</strong>    该锁支持重进入，以读写线程为例：读线程在获取了读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁也能够同时获取读锁</li><li><strong>锁降级</strong>    遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁</li></ul></blockquote><p>ReentrantReadWriteLock常见方法： </p><p>构造方法</p><blockquote><ul><li>ReentrantReadWriteLock()    创建一个 ReentrantReadWriteLock()的实例</li><li>ReentrantReadWriteLock(boolean fair)    创建一个特定锁类型（公平锁/非公平锁）的ReentrantReadWriteLock的实例</li></ul></blockquote><p>常见方法： </p><p>和ReentrantLock类 类似。</p><h3 id="3-3-ReentrantReadWriteLock的使用"><a href="#3-3-ReentrantReadWriteLock的使用" class="headerlink" title="3.3 ReentrantReadWriteLock的使用"></a>3.3 ReentrantReadWriteLock的使用</h3><p><strong>1. 读读共享</strong></p><p>两个线程同时运行read方法，你会发现两个线程可以同时或者说是几乎同时运行lock()方法后面的代码，输出的两句话显示的时间一样。这样提高了程序的运行效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot; &quot; + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 写写互斥</strong></p><p>把上面的代码的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.readLock().lock();</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.writeLock().lock();</span><br></pre></td></tr></table></figure><p>两个线程同时运行read方法，你会发现同一时间只允许一个线程执行lock()方法后面的代码。</p><p><strong>3. 读写互斥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">public void read() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(&quot;获得读锁&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot; &quot; + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(&quot;获得写锁&quot; + Thread.currentThread().getName()</span><br><span class="line">                    + &quot; &quot; + System.currentTimeMillis());</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Service service = new Service();</span><br><span class="line"></span><br><span class="line">ThreadA a = new ThreadA(service);</span><br><span class="line">a.setName(&quot;A&quot;);</span><br><span class="line">a.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">ThreadB b = new ThreadB(service);</span><br><span class="line">b.setName(&quot;B&quot;);</span><br><span class="line">b.start();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获得读锁A 1547869177028</span><br><span class="line">获得写锁B 1547869187031</span><br></pre></td></tr></table></figure><p>第一条语句和第二条语句间隔10秒，第二条语句和结束间隔10秒，说明是互斥的。</p><p>运行两个使用同一个Service对象实例的线程a,b，线程a执行上面的read方法，线程b执行上面的write方法。你会发现同一时间只允许一个线程执行lock()方法后面的代码。记住：只要出现写操作的过程就是互斥的。</p><p><strong>4. 写读互斥</strong></p><p>和读写互斥类似。记住：只要出现写操作的过程就是互斥的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lock锁的使用&quot;&gt;&lt;a href=&quot;#Lock锁的使用&quot; class=&quot;headerlink&quot; title=&quot;Lock锁的使用&quot;&gt;&lt;/a&gt;Lock锁的使用&lt;/h1&gt;&lt;h2 id=&quot;一-Lock接口&quot;&gt;&lt;a href=&quot;#一-Lock接口&quot; class=&quot;head
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-join和ThreadLocal的使用</title>
    <link href="http://www.herobin.top/2019/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-join%E5%92%8CThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.herobin.top/2019/01/18/Java多线程-join和ThreadLocal的使用/</id>
    <published>2019-01-18T03:49:38.000Z</published>
    <updated>2019-01-18T06:56:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h2><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是<strong>主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。另外，一个线程需要等待另一个线程也需要用到join()方法</strong>。</p><p>Thread类除了提供<strong>join()方法</strong>之外，还提供了<strong>join(long millis)、join(long millis, int nanos)</strong>两个具有超时特性的方法。这两个超时方法表示，如果线程thread在指定的超时时间没有终止，那么将会从该超时方法中返回。</p><h3 id="2-1-join方法使用"><a href="#2-1-join方法使用" class="headerlink" title="2.1 join方法使用"></a>2.1 join方法使用</h3><p><strong>不使用join方法的问题：</strong></p><p>Test.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyThread threadTest = new MyThread();</span><br><span class="line">        threadTest.start();</span><br><span class="line"></span><br><span class="line">        //Thread.sleep(?);//因为不知道子线程要花的时间这里不知道填多少时间</span><br><span class="line">        System.out.println(&quot;我想当threadTest对象执行完毕后我再执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;我想先执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/1.png" alt=""></p><p>可以看到子线程中后被执行，这里的例子只是一个简单的演示，我们想一下：<strong>假如子线程运行的结果被主线程运行需要怎么办？sleep方法？</strong>当然可以，但是子线程运行需要的时间是不确定的，所以sleep多长时间当然也就不确定了。这里就需要使用join方法解决上面的问题。</p><p><strong>使用join方法解决上面的问题：</strong></p><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        MyThread threadTest = new MyThread();</span><br><span class="line">        threadTest.start();</span><br><span class="line"></span><br><span class="line">        //Thread.sleep(?);//因为不知道子线程要花的时间这里不知道填多少时间</span><br><span class="line">        threadTest.join();</span><br><span class="line">        System.out.println(&quot;我想当threadTest对象执行完毕后我再执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;我想先执行&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码仅仅加了一句：<strong>threadTest.join()</strong>。在这里join方法的作用就是<strong>主线程需要等待子线程执行完成之后再结束</strong>。</p><h3 id="2-2-join-long-millis-方法的使用"><a href="#2-2-join-long-millis-方法的使用" class="headerlink" title="2.2 join(long millis)方法的使用"></a>2.2 join(long millis)方法的使用</h3><p>join(long millis)中的参数就是设定的等待时间。</p><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MyThread threadTest = new MyThread();</span><br><span class="line">            threadTest.start();</span><br><span class="line"></span><br><span class="line">            threadTest.join(2000);// 只等2秒</span><br><span class="line">            //Thread.sleep(2000);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;  end timer=&quot; + System.currentTimeMillis());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;begin Timer=&quot; + System.currentTimeMillis());</span><br><span class="line">                Thread.sleep(10000);</span><br><span class="line">                System.out.println(&quot;last Timer=&quot; + System.currentTimeMillis());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/uploads/190118java3/2.png" alt=""></p><p>可以看到begin和end之间间隔两秒，end和last之间间隔八秒。<br>而且在main中不管是用threadTest.join(2000)还是Thread.sleep(2000)，begin和end的间隔都是两秒，threadTest.join(2000) 和Thread.sleep(2000) 和区别在于： <strong>Thread.sleep(2000)不会释放锁，threadTest.join(2000)会释放锁</strong> 。</p><h2 id="三-ThreadLocal的使用"><a href="#三-ThreadLocal的使用" class="headerlink" title="三 ThreadLocal的使用"></a>三 ThreadLocal的使用</h2><p>变量值的共享可以使用public static变量的形式，所有线程都使用一个public static变量。<strong>如果想实现每一个线程都有自己的共享变量该如何解决呢？</strong>JDK中提供的<strong>ThreadLocal类</strong>正是为了解决这样的问题。ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p><strong>再举个简单的例子： </strong><br>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。</p><p><strong>ThreadLocal类相关方法：</strong><br><strong>get()</strong>    返回当前线程的此线程局部变量的副本中的值。<br><strong>set(T value)</strong>    将当前线程的此线程局部变量的副本设置为指定的值<br><strong>remove()</strong>    删除此线程局部变量的当前线程的值。<br><strong>initialValue()</strong>    返回此线程局部变量的当前线程的“初始值”</p><h3 id="3-1-ThreadLocal类的初试"><a href="#3-1-ThreadLocal类的初试" class="headerlink" title="3.1 ThreadLocal类的初试"></a>3.1 ThreadLocal类的初试</h3><p>Test1.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">    public static ThreadLocal&lt;String&gt; t1 = new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (t1.get() == null) &#123;</span><br><span class="line">            System.out.println(&quot;为ThreadLocal类对象放入值:aaa&quot;);</span><br><span class="line">            t1.set(&quot;aaaֵ&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.get());//aaa</span><br><span class="line">        System.out.println(t1.get());//aaa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为ThreadLocal类对象放入值:aaa</span><br><span class="line">aaaֵ</span><br><span class="line">aaaֵ</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，第一次调用ThreadLocal对象的<strong>get()方法</strong>时返回的值是<strong>null</strong>,通过调用<strong>set()方法</strong>可以为ThreadLocal对象赋值。</p><p>如果想要解决get()方法null的问题，可以使用ThreadLocal对象的<strong>initialValue方法</strong>。如下：</p><p>Test2.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">    public static ThreadLocalExt t1 = new ThreadLocalExt();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        if (t1.get() == null) &#123;</span><br><span class="line">            System.out.println(&quot;从未放过值&quot;);</span><br><span class="line">            t1.set(&quot;我的值&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t1.get());</span><br><span class="line">        System.out.println(t1.get());</span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadLocalExt extends ThreadLocal &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object initialValue() &#123;</span><br><span class="line">            return &quot;我是默认值 第一次get不再为null&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是默认值 第一次get不再为null</span><br><span class="line">我是默认值 第一次get不再为null</span><br></pre></td></tr></table></figure><h3 id="3-2-验证线程变量间的隔离性"><a href="#3-2-验证线程变量间的隔离性" class="headerlink" title="3.2 验证线程变量间的隔离性"></a>3.2 验证线程变量间的隔离性</h3><p>Test3.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line">/**</span><br><span class="line"> *TODO 验证线程变量间的隔离性</span><br><span class="line"> */</span><br><span class="line">public class Test3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                System.out.println(&quot;       在Main线程中取值=&quot; + Tools.tl.get());</span><br><span class="line">                Thread.sleep(100);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            ThreadA a = new ThreadA();</span><br><span class="line">            a.start();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static public class Tools &#123;</span><br><span class="line">        public static ThreadLocalExt tl = new ThreadLocalExt();</span><br><span class="line">    &#125;</span><br><span class="line">    static public class ThreadLocalExt extends ThreadLocal &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Object initialValue() &#123;</span><br><span class="line">            return new Date().getTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;在ThreadA线程中取值=&quot; + Tools.tl.get());</span><br><span class="line">                    Thread.sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                // TODO Auto-generated catch block</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/3.png" alt=""></p><p>从运行结果可以看出子线程和父线程各自拥有各自的值。</p><h3 id="3-3-InheritableThreadLocal"><a href="#3-3-InheritableThreadLocal" class="headerlink" title="3.3 InheritableThreadLocal"></a>3.3 InheritableThreadLocal</h3><p><strong>ThreadLocal类固然很好，但是子线程并不能取到父线程的ThreadLocal类的变量，InheritableThreadLocal类就是解决这个问题的。</strong></p><p>取父线程的值：</p><p>修改Test3.java的内部类Tools 和ThreadLocalExt类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static public class Tools &#123;</span><br><span class="line">       public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt();</span><br><span class="line">   &#125;</span><br><span class="line">   static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123;</span><br><span class="line">       @Override</span><br><span class="line">       protected Object initialValue() &#123;</span><br><span class="line">           return new Date().getTime();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/4.png" alt=""></p><p>取父线程的值并修改：</p><p>修改Test3.java的内部类Tools和InheritableThreadLocalExt类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static public class Tools &#123;</span><br><span class="line">    public static InheritableThreadLocalExt tl = new InheritableThreadLocalExt();</span><br><span class="line">&#125;</span><br><span class="line">static public class InheritableThreadLocalExt extends InheritableThreadLocal &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected Object initialValue() &#123;</span><br><span class="line">        return new Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object childValue(Object parentValue) &#123;</span><br><span class="line">        return parentValue + &quot; 我在子线程加的~!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java3/5.png" alt=""></p><p>在使用InheritableThreadLocal类需要注意的一点是：<strong>如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的还是旧值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Thread-join-的使用&quot;&gt;&lt;a href=&quot;#Thread-join-的使用&quot; class=&quot;headerlink&quot; title=&quot;Thread.join()的使用&quot;&gt;&lt;/a&gt;Thread.join()的使用&lt;/h2&gt;&lt;p&gt;在很多情况下，主线程生成并起动了
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-wait/notify机制</title>
    <link href="http://www.herobin.top/2019/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-wait-notify%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.herobin.top/2019/01/18/Java多线程-wait-notify机制/</id>
    <published>2019-01-18T02:30:01.000Z</published>
    <updated>2019-01-18T03:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="等待-通知（wait-notify）机制"><a href="#等待-通知（wait-notify）机制" class="headerlink" title="等待/通知（wait/notify）机制"></a>等待/通知（wait/notify）机制</h1><h2 id="一-等待-通知机制介绍"><a href="#一-等待-通知机制介绍" class="headerlink" title="一 等待/通知机制介绍"></a>一 等待/通知机制介绍</h2><h3 id="1-1-不使用等待-通知机制"><a href="#1-1-不使用等待-通知机制" class="headerlink" title="1.1 不使用等待/通知机制"></a>1.1 不使用等待/通知机制</h3><p>当两个线程之间存在<strong>生产和消费者关系</strong>，也就是说<strong>第一个线程（生产者）做相应的操作然后第二个线程（消费者）感知到了变化又进行相应的操作</strong>。比如像下面的whie语句一样，假设这个value值就是第一个线程操作的结果，doSomething()是第二个线程要做的事，当满足条件value=desire后才执行doSomething()。</p><p>但是这里有个问题就是：第二个语句不停的通过轮询机制来检测判断条件是否成立。<strong>如果轮询时间的间隔太小会浪费CPU资源，轮询时间的间隔太大，就可能取不到自己想要的数据。所以这里就需要我们今天讲到的等待/通知（wait/notify）机制来解决这两个矛盾</strong>。</p><pre><code>while(value=desire){    doSomething();}</code></pre><h3 id="1-2-什么是等待-通知机制？"><a href="#1-2-什么是等待-通知机制？" class="headerlink" title="1.2 什么是等待/通知机制？"></a>1.2 什么是等待/通知机制？</h3><p><strong>通俗来讲：</strong></p><p>等待/通知机制在我们生活中比比皆是，一个形象的例子就是厨师和服务员之间就存在等待/通知机制。</p><blockquote><ul><li><ol><li>厨师做完一道菜的时间是不确定的，所以菜到服务员手中的时间是不确定的； </li></ol></li><li><ol start="2"><li>服务员就需要去“等待（wait）”； </li></ol></li><li><ol start="3"><li>厨师把菜做完之后，按一下铃，这里的按铃就是“通知（nofity）”； </li></ol></li><li><ol start="4"><li>服务员听到铃声之后就知道菜做好了，他可以去端菜了。</li></ol></li></ul></blockquote><p><strong>用专业术语讲：</strong></p><p>等待/通知机制，是指一个线程A调用了对象O的<strong>wait()方法</strong>进入<strong>等待状态</strong>，而另一个线程B调用了对象O的<strong>notify()/notifyAll()方法</strong>，线程A收到通知后退出<strong>等待队列</strong>，进入可运行状态，进而执行后续操作。上诉两个线程通过对象O来完成交互，而对象上的<strong>wait()方法</strong>和<strong>notify()/notifyAll()方法</strong>的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><h3 id="1-3-等待-通知机制的相关方法"><a href="#1-3-等待-通知机制的相关方法" class="headerlink" title="1.3 等待/通知机制的相关方法"></a>1.3 等待/通知机制的相关方法</h3><p><strong>notify()</strong>    随机唤醒等待队列中等待同一共享资源的 <strong>“一个线程”</strong>，并使该线程退出等待队列，进入可运行状态，也就是<strong>notify()方法仅通知“一个线程”</strong>.</p><p><strong>notifyAll()</strong>    使所有正在等待队列中等待同一共享资源的 <strong>“全部线程”</strong> 退出等待队列，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这取决于JVM虚拟机的实现.</p><p><strong>wait()</strong>    使调用该方法的线程释放共享资源锁，然后从运行状态退出，进入等待队列，直到被再次唤醒</p><p><strong>wait(long)</strong>    超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回.</p><p><strong>wait(long，int)</strong>    对于超时时间更细力度的控制，可以达到纳秒.</p><h2 id="二-等待-通知机制的实现"><a href="#二-等待-通知机制的实现" class="headerlink" title="二 等待/通知机制的实现"></a>二 等待/通知机制的实现</h2><h3 id="2-1-我的第一个等待-通知机制程序"><a href="#2-1-我的第一个等待-通知机制程序" class="headerlink" title="2.1 我的第一个等待/通知机制程序"></a>2.1 我的第一个等待/通知机制程序</h3><p>MyList.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class MyList &#123;</span><br><span class="line">    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    public static void add() &#123;</span><br><span class="line">        list.add(&quot;anyString&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int size() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public ThreadA(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (MyList.size() != 5) &#123;</span><br><span class="line">                    System.out.println(&quot;wait begin &quot;</span><br><span class="line">                            + System.currentTimeMillis());</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(&quot;wait end  &quot;</span><br><span class="line">                            + System.currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadB.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class ThreadB extends Thread &#123;</span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public ThreadB(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                    MyList.add();</span><br><span class="line">                    if (MyList.size() == 5) &#123;</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        System.out.println(&quot;已发出通知！&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Object lock = new Object();</span><br><span class="line">            ThreadA a = new ThreadA(lock);</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            ThreadB b = new ThreadB(lock);</span><br><span class="line">            b.start();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java2/1.png" alt=""></p><p>可以看到：<strong>nofify()执行后并不会立即释放锁</strong>。</p><p><strong>synchronized关键字</strong>可以将任何一个Object对象作为同步对象来看待，而<strong>Java为每个Object都实现了等待/通知（wait/notify）机制的相关方法</strong>，它们必须用在synchronized关键字同步的Object的临界区内。通过调用<strong>wait()方法</strong>可以使处于临界区内的线程进入<strong>等待状态</strong>，同时<strong>释放被同步对象的锁</strong>。而notify()方法可以唤醒一个因调用wait操作而处于阻塞状态中的线程，使其进入就绪状态。被重新唤醒的线程会视图重新获得临界区的控制权也就是锁，并继续执行wait方法之后的代码。如果发出notify操作时没有处于阻塞状态中的线程，那么该命令会被忽略。</p><p>如果我们这里不通过<strong>等待/通知（wait/notify）机制</strong>实现，而是使用如下的<strong>while循环</strong>实现的话，我们上面也讲过会有很大的弊端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(MyList.size() == 5)&#123;</span><br><span class="line">       doSomething();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-线程的基本状态"><a href="#2-2-线程的基本状态" class="headerlink" title="2.2 线程的基本状态"></a>2.2 线程的基本状态</h3><p>上面我们已经提到了和线程有关的大部分API，这些API可以改变线程对象的状态。如下图所示：</p><p><img src="/uploads/190118java2/2.png" alt=""></p><blockquote><p> <strong>新建(new)</strong>：新创建了一个线程对象。 </p></blockquote><blockquote><p> <strong>可运行(runnable)</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。 </p></blockquote><blockquote><p> <strong>运行(running)</strong>：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。 </p></blockquote><blockquote><p> <strong>阻塞(block)</strong>：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种：</p></blockquote><blockquote><ul><li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。</li></ul></blockquote><blockquote><ul><li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li></ul></blockquote><blockquote><ul><li>其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul></blockquote><blockquote><p><strong>死亡(dead)</strong>：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p></blockquote><p><strong>备注：<br>可以用早起坐地铁来比喻这个过程：</strong></p><blockquote><ul><li>还没起床：sleeping</li></ul></blockquote><blockquote><ul><li>起床收拾好了，随时可以坐地铁出发：Runnable</li></ul></blockquote><blockquote><ul><li>等地铁来：Waiting</li></ul></blockquote><blockquote><ul><li>地铁来了，但要排队上地铁：I/O阻塞</li></ul></blockquote><blockquote><ul><li>上了地铁，发现暂时没座位：synchronized阻塞</li></ul></blockquote><blockquote><ul><li>地铁上找到座位：Running</li></ul></blockquote><blockquote><ul><li>到达目的地：Dead</li></ul></blockquote><h3 id="2-3-notify-锁不释放"><a href="#2-3-notify-锁不释放" class="headerlink" title="2.3 notify()锁不释放"></a>2.3 notify()锁不释放</h3><p><strong>当方法wait()被执行后，锁自动被释放，但执行完notify()方法后，锁不会自动释放。必须执行完notify()方法所在的synchronized代码块后才释放。</strong></p><h3 id="2-4-当interrupt方法遇到wait方法"><a href="#2-4-当interrupt方法遇到wait方法" class="headerlink" title="2.4 当interrupt方法遇到wait方法"></a>2.4 当interrupt方法遇到wait方法</h3><p><strong>当线程呈现wait状态时，对线程对象调用interrupt方法会出现interruptedException异常。</strong></p><p>service.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/17.</span><br><span class="line"> */</span><br><span class="line">public class Service &#123;</span><br><span class="line">    public void testMethod(Object lock) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                System.out.println(&quot;begin wait()&quot;);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(&quot;  end wait()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(&quot;出现异常了，因为呈wait状态的线程被interrupt了！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadA.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Object lock;</span><br><span class="line"></span><br><span class="line">    public ThreadA(Object lock) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Service service = new Service();</span><br><span class="line">        service.testMethod(lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Object lock = new Object();</span><br><span class="line">            ThreadA a = new ThreadA(lock);</span><br><span class="line">            a.start();</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            a.interrupt();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java2/3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;等待-通知（wait-notify）机制&quot;&gt;&lt;a href=&quot;#等待-通知（wait-notify）机制&quot; class=&quot;headerlink&quot; title=&quot;等待/通知（wait/notify）机制&quot;&gt;&lt;/a&gt;等待/通知（wait/notify）机制&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程-volatile关键字</title>
    <link href="http://www.herobin.top/2019/01/18/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.herobin.top/2019/01/18/Java多线程-volatile关键字/</id>
    <published>2019-01-18T02:05:34.000Z</published>
    <updated>2019-01-18T02:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h2><p><strong>Java中的“volatile关键字”：</strong></p><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存（即共享内存）读取变量</strong>，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。 </p><p><img src="/uploads/190118java1/1.png" alt=""></p><p>要解决这个问题，就需要把变量声明为 <strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。 </p><p><img src="/uploads/190118java1/2.png" alt=""></p><h2 id="二-volatile关键字的可见性"><a href="#二-volatile关键字的可见性" class="headerlink" title="二 volatile关键字的可见性"></a>二 volatile关键字的可见性</h2><p><strong>volatile 修饰的成员变量</strong>在每次被线程访问时，都强迫<strong>从主存（共享内存）中重读该成员变量的值</strong>。而且，当成员变量发生变化时，<strong>强迫线程将变化值回写到主存（共享内存）</strong>。这样在任何时刻，<strong>两个不同的线程总是看到某个成员变量的同一个值</strong>，这样也就保证了同步数据的<strong>可见性</strong>。</p><p>RunThread.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class RunThread extends Thread&#123;</span><br><span class="line">    private boolean isRunning = true;</span><br><span class="line">    int m;</span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setRunning(boolean isRunning) &#123;</span><br><span class="line">        this.isRunning = isRunning;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;进入run了&quot;);</span><br><span class="line">        while (isRunning == true) &#123;</span><br><span class="line">            int a=2;</span><br><span class="line">            int b=3;</span><br><span class="line">            int c=a+b;</span><br><span class="line">            m=c;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">        System.out.println(&quot;线程被停止了！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by binzhang on 19/1/16.</span><br><span class="line"> */</span><br><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        RunThread thread = new RunThread();</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        thread.setRunning(false);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;已经赋值为false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/uploads/190118java1/3.png" alt=""></p><p>RunThread类中的isRunning变量没有加上<strong>volatile关键字</strong>时，运行以上代码会出现<strong>死循环</strong>，这是因为isRunning变量虽然被修改但是没有被写到<strong>主存</strong>中，这也就导致该线程在<strong>本地内存中</strong>的值一直为true，这样就导致了死循环的产生。</p><p>解决办法也很简单：isRunning变量前加上<strong>volatile关键字</strong>即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatile private boolean isRunning = true;</span><br></pre></td></tr></table></figure><p>这样运行就不会出现死循环了。<br>加上volatile关键字后的运行结果： </p><p><img src="/uploads/190118java1/4.png" alt=""></p><p>奇怪的是如果我们在while循环代码里加上任意一个输出语句或者sleep方法你会发现死循环也会停止，不管isRunning变量是否被加上volatile关键字。</p><p><img src="/uploads/190118java1/5.png" alt=""></p><p>这是为什么呢？</p><p><strong>因为：JVM会尽力保证内存的可见性，即使这个变量没有加同步关键字</strong>。换句话说，只要CPU有时间，JVM会尽力去保证变量值的更新。这种与volatile关键字的不同在于，volatile关键字会强制的保证线程的可见性。而不加这个关键字，JVM也会尽力去保证可见性，但是如果CPU一直有其他的事情在处理，它也没办法。最开始的代码，一直处于死循环中，CPU处于一直占用的状态，这个时候CPU没有时间，JVM也不能强制要求CPU分点时间去取最新的变量值。<strong>而加了输出或者sleep语句之后，CPU就有可能有时间去保证内存的可见性，于是while循环可以被终止</strong>。</p><h2 id="三-volatile关键字能保证原子性吗？"><a href="#三-volatile关键字能保证原子性吗？" class="headerlink" title="三 volatile关键字能保证原子性吗？"></a>三 volatile关键字能保证原子性吗？</h2><p>没有确切的说法，《Java并发编程艺术》这本书上说保证但是在自增操作（非原子操作）上不保证，《Java多线程编程核心艺术》这本书说不保证。不过应该是<strong>volatile无法保证对变量原子性的，要保证数据的原子性还是要使用synchronized关键字</strong>。</p><h2 id="四-synchronized关键字和volatile关键字比较"><a href="#四-synchronized关键字和volatile关键字比较" class="headerlink" title="四 synchronized关键字和volatile关键字比较"></a>四 synchronized关键字和volatile关键字比较</h2><p><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用synchronized关键字还是更多一些</strong>。</p><p><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></p><p><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></p><p><strong>volatile关键字用于解决变量在多个线程之间的可见性，而ynchronized关键字解决的是多个线程之间访问资源的同步性。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;volatile关键字&quot;&gt;&lt;a href=&quot;#volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;volatile关键字&quot;&gt;&lt;/a&gt;volatile关键字&lt;/h1&gt;&lt;h2 id=&quot;一-简介&quot;&gt;&lt;a href=&quot;#一-简介&quot; class=&quot;
      
    
    </summary>
    
      <category term="java" scheme="http://www.herobin.top/categories/java/"/>
    
    
      <category term="java" scheme="http://www.herobin.top/tags/java/"/>
    
  </entry>
  
</feed>
